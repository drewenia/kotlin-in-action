# Getting rid of static utility classes: Top-level functions and properties

Hepimiz biliyoruz ki, Java bir object-oriented language olduğu için, tüm code’un class’ların method’u olarak yazılmasını
gerektirir. Genellikle bu güzel işler, ancak gerçekte neredeyse her büyük project, açıkça herhangi bir single class’a
ait olmayan çok fazla code ile sonuçlanır. Bazen bir operation, eşit derecede önemli bir rol oynayan iki farklı class’ın
object’leriyle çalışır. Diğer zamanlarda, bir primary object vardır, ancak operation’ı instance method olarak ekleyerek
onun API’sini şişirmek istemezsin. Sonuç olarak, hiçbir state veya instance method içermeyen class’larla karşılaşırsın.
Bu tür class’lar yalnızca birkaç static method için container olarak davranır. Bunun mükemmel bir örneği, JDK’daki
Collections class’ıdır. Kendi code’unda başka örnekler bulmak için, adı içinde Util geçen class’lara bakabilirsin.
Kotlin’de, bu anlamsız class’ları oluşturman gerekmez. Bunun yerine, function’ları doğrudan bir source file’ın top
level’ına, herhangi bir class dışında yerleştirebilirsin. Bu tür function’lar hâlâ file’ın en üstünde declare edilen
package’in member’larıdır ve başka package’lardan çağırmak istiyorsan hâlâ import etmen gerekir, ancak gereksiz ekstra
nesting seviyesi artık yoktur. joinToString function’ını doğrudan strings package’ına yerleştirelim. **join.kt** adında
bir file oluştur ve aşağıdaki içeriği ekle (bu seçim keyfi; başka bir filename de aynı şekilde çalışır).

```
package strings

fun <T> joinToString(
    collection: Collection<T>,
    seperator: String = ", ",
    prefix: String = "[",
    postfix: String = "]"
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in collection.withIndex()) {
        if (index > 0) result.append(seperator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
```

Bu nasıl çalışır? File’ı compile ettiğinde, bazı class’lar oluşturulacaktır çünkü JVM yalnızca class içindeki code’u
çalıştırabilir. Sadece Kotlin ile çalışıyorsan, bilmen gereken tek şey budur. Ancak böyle bir function’ı Java’dan
çağırman gerekiyorsa, nasıl compile edileceğini anlaman gerekir. Bunu netleştirmek için, aynı class’a compile olacak
Java code’una bakalım:

```
package strings;
public class JoinKt {
    public static String joinToString(/* ... */) { /* ... */ }
}
```

Kotlin compiler tarafından oluşturulan class’ın adının, function’ı içeren file’ın adıyla eşleştiğini görebilirsin —
Java’nın naming scheme’ine uyması için baş harfi büyük yapılır ve sonuna Kt eklenir. File’daki tüm top-level
function’lar, bu class’ın static method’ları olarak compile edilir. Bu nedenle, bu function’ı Java’dan çağırmak,
herhangi bir diğer static method’u çağırmak kadar kolaydır:

```
import strings.JoinKt;
/* ... */
JoinKt.joinToString(list, ", ", "", "");
```

Default olarak, compiler tarafından oluşturulan class name’i, filename’e Kt suffix’i eklenerek oluşturulur. Kotlin
top-level function’ları içeren generated class’ın adını değiştirmek için, file-wide bir annotation ekle:
```@file:JvmName("…")```. Bunu file’ın başına, package name’den önce yerleştir.

```
@file:JvmName("StringFunctions")
fun joinToString(/* ... */): String { /* ... */ }
```

Artık function şu şekilde call edilebilir:

```
import strings.StringFunctions;
StringFunctions.joinToString(list, ", ", "", "");
```

Function’lar gibi, property’ler de bir file’ın top level’ına yerleştirilebilir. Tek tek data parçalarını bir class
dışında saklamak çok sık gerekmez, ancak yine de faydalıdır. Örneğin, bir operation’ın kaç kez gerçekleştirildiğini
saymak için bir var property kullanabilirsin:

```kotlin
var opCount = 0

fun performOperation() {
    opCount++
}

fun reportOperationCount() {
    println("Operation performed $opCount times")
}
```

Bu tür bir property’nin value’su bir static field’da saklanır. Top-level property’ler, code içinde constant’lar
tanımlamana da olanak tanır:

```kotlin
val UNIX_LINE_SEPARATOR = "\n"
```

Default olarak, top-level property’ler de diğer tüm property’ler gibi Java code’una accessor method’lar olarak
açılır (bir val property için bir getter, bir var property için ise bir getter–setter çifti). Bir constant’ı Java
code’una public static final field olarak expose etmek ve kullanımını daha doğal hale getirmek istiyorsan, onu const
modifier ile işaretleyebilirsin (bu, primitive type’ların property’leri ile String için geçerlidir).

```kotlin
const val UNIX_LINE_SEPARATORv2 = "\n"
```

Bu, aşağıdaki Java code’una eşdeğer bir sonuç sağlar:

```java
public static final String UNIX_LINE_SEPARATOR = "\n";
```

Kotlin standard library, birçok kullanışlı top-level function ve property de içerir. Bunun bir örneği kotlin.math
package’idir. İki sayının maksimumunu hesaplayan max function’ı gibi, tipik matematiksel ve trigonometrik operation’lar
için kullanışlı function’lar sağlar. Ayrıca Euler’s number veya pi gibi bazı matematiksel constant’larla birlikte gelir.

```kotlin
fun main() {
    println(max(PI, E)) // 3.141592653589793
}
```