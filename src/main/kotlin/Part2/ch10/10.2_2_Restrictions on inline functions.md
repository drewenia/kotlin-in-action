# Restrictions on inline functions

Inlining’in nasıl gerçekleştirildiği nedeniyle, lambda kullanan her function inline edilemez. Function inline
edildiğinde, argument olarak geçirilen lambda expression’ın body’si ortaya çıkan code’un içine doğrudan yerleştirilir.
Bu durum, function body’si içinde ilgili parameter’ın olası kullanımlarını kısıtlar. Lambda parameter’ı invoke
ediliyorsa, bu tür code kolayca inline edilebilir. Ancak parameter daha sonra kullanılmak üzere bir yerde saklanıyorsa,
lambda expression’ın code’u inline edilemez; çünkü bu code’u içeren bir object’in var olması gerekir.

```kotlin
class FunctionStorage {
    var myStoredFunction: ((Int) -> Unit)? = null
    inline fun storeFunction(f: (Int) -> Unit) {
        /* Geçirilen parameter’ı saklar; bu da compiler’ın her call site’ta code’u yerleştirmesini engeller ve inline
        parameter f için illegal kullanım bildirir. */
        myStoredFunction = f // Error
        // Illegal usage of inline parameter 'f: (Int) -> Unit'
    }
}
```

Genel olarak, parameter doğrudan call ediliyorsa veya başka bir inline function’a argument olarak geçiriliyorsa inline
edilebilir. Aksi halde compiler, parameter’ın inline edilmesini şu error message ile engeller: “Illegal usage of
inline-parameter.”

Örneğin, sequence’ler üzerinde çalışan çeşitli function’lar, ilgili sequence operation’ını temsil eden class’ların
instance’larını döndürür ve lambda’yı constructor parameter’ı olarak alır. Sequence.map function’ının nasıl define
edildiği aşağıda gösterilmiştir:

```kotlin
fun <T, R> Sequence<T>.map(transform: (T) -> R): Sequence<R> {
    return TransformingSequence(this, transform)
}
```

map function’ı, transform parameter’ı olarak geçirilen function’ı doğrudan call etmez. Bunun yerine, bu function’ı bir
property içinde saklayan bir class’ın constructor’ına geçirir. Bunu desteklemek için, transform argument’ı olarak
geçirilen lambda’nın, bir function interface’ini implement eden anonymous class olarak standart non-inline
representation'ınına compile edilmesi gerekir.

İki veya daha fazla lambda’yı argument olarak bekleyen bir function’ınız varsa, bunların yalnızca bazılarını inline
etmeyi seçebilirsiniz. Bu, lambda’lardan birinin çok fazla code içermesinin beklendiği veya inline edilmeye izin
vermeyen bir şekilde kullanıldığı durumlarda anlamlıdır. Inline edilemeyen bu tür lambda’ları alan parameter’ları
noinline modifier’ı ile işaretleyebilirsiniz:

```kotlin
inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {
    // ...
}
```

Compiler, modüller arasında veya third-party library’lerde define edilmiş function’ları inline etmeyi tamamen destekler.
Çoğu inline function’ı Java’dan da call edebilirsiniz; bu tür call’lar inline edilmez, normal function call’lar olarak
compile edilir. Chapter 11’de, (ancak Java interoperability üzerinde bazı kısıtlamalarla birlikte) noinline kullanmanın
mantıklı olduğu bir başka case daha göreceksiniz.

### Extra description

noinline, bir fonksiyonu inline (satır içi) olarak işaretlediğinde, onun tüm lambda parametrelerinin değil, sadece
istediğin parametrelerin satır içine alınmasını sağlayan bir anahtar kelimedir.

Normalde bir fonksiyonu inline yaptığında, Kotlin derleyicisi o fonksiyona parametre olarak gelen tüm lambdaları da
satır içine (inline) alır. Ama bazen bazı lambdaların "nesne" (object) olarak kalmasını istersin. İşte o zaman noinline
devreye girer.

Bir lambda inline edildiğinde, o artık bir "fonksiyon nesnesi" değildir; sadece bir kod parçasıdır. Bu yüzden:

* Onu bir değişkene atayamazsın.

* Başka bir fonksiyona parametre olarak gönderemezsin.

Eğer lambdanın bir object olarak kalmasına ihtiyacın varsa (örneğin bir listede saklayacaksan veya başka bir yere
paslayacaksan), onu noinline yapmalısın.

Diyelim ki bir Görev Yönetici (Task Manager) yazıyorsun. Bir fonksiyonun var; hem bir işi hemen yapacak, hem de başka
bir işi daha sonra çalıştırılmak üzere bir listeye kaydedecek.

```kotlin
val eventListeners = mutableListOf<() -> Unit>()

inline fun manageEvent(
    onImmediateAction: () -> Unit,
    // Stored edilebilmesi için noinline olmalıdır
    noinline onDelayedAction: () -> Unit
) {
    // Code buraya kopyalanır (fast)
    onImmediateAction()

    // noinline değilse ERROR: “Illegal usage of inline-parameter”
    eventListeners.add(onDelayedAction)
}

fun main() {
    manageEvent(
        onImmediateAction = { println("Acting now") },
        onDelayedAction = { println("Acting later") }
    )

    if (eventListeners.isNotEmpty()){
        // Call the first listener specifically
        eventListeners[0]()
    }

    println("--- Executing all listeners ---")
    eventListeners.forEach { it.invoke() }
    // Acting now
    // --- Executing all listeners ---
    // Acting later
}
```

onDelayedAction lambdasını bir listeye kaydettiğin için, onu dilediğin zaman o listeye erişerek çağırabilirsin.
Kaydettiğin şey artık gerçek bir nesne (object) olduğu için, listenin içinden onu çekip .invoke() diyerek veya sadece ()
parantezlerini kullanarak çalıştırabilirsin.

Example;

```kotlin
// Bu, regular, inline olmayan bir function’dır
fun logCallBack(callback: () -> Unit) {
    println("Registering callback : $callback")
    callback()
}

inline fun processData(
    data: String,
    // Argument olarak geçirilebilmesi için noinline olmalıdır
    noinline onComplete: () -> Unit
) {
    println("Processing : $data")
    // noinline değilse ERROR: Inlined bir lambda’yı normal bir function’a geçiremezsiniz
    logCallBack (onComplete)
}

fun main() {
    processData("UserFile101.txt"){
        println("Cleanup finished")
        // Processing : UserFile101.txt
        // Registering callback : PlaygroundKt$$Lambda/0x000003e001000c30@28d93b30
        // Cleanup finished
    }
}
```