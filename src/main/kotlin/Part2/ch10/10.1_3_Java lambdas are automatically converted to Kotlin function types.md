# Java lambdas are automatically converted to Kotlin function types

Chapter 5’de zaten keşfettiğin gibi, Kotlin lambda’sını, functional interface bekleyen herhangi bir Java method’una
automatic SAM (single abstract method) conversion aracılığıyla geçirebilirsin. Bu, Kotlin code’unun Java library’lerine
güvenebileceği ve Java’da define edilmiş higher-order function’ları problemsiz bir şekilde çağırabileceği anlamına
gelir. Benzer şekilde, function type kullanan Kotlin function’ları Java’dan kolayca çağrılabilir. Java lambda’ları,
function type value’larına otomatik olarak dönüştürülür, aşağıdaki listing’de gösterildiği gibi.

```kotlin
/* Kotlin declaration */
fun processTheAnswer(f: (Int) -> Int) {
    println(f(42))
}

fun main() {
    processTheAnswer { it * 2 } // 84
}
```

* Buradaki f bir sayı veya metin değil, bir fonksiyondur.

* (Int): Bu fonksiyon bir tam sayı (Int) kabul eder.

* -> Int: Bu fonksiyon işlem sonucunda bize yine bir tam sayı (Int) döndürür.

```
/* Java */
processTheAnswer(number -> number + 3); // 45
```

Java’da, argument olarak lambda bekleyen Kotlin standard library extension function’larını kolayca kullanabilirsin.
Ancak, Kotlin’deki kadar güzel görünmediklerini unutma—receiver object’i first argument olarak açıkça geçirmen gerekir:

```java
public static void main(String[] args) {
    List<String> strings = new ArrayList<>();
    strings.add("42");
    // Java code’unda Kotlin standard library’den bir function kullanabilirsin.
    CollectionsKt.forEach(strings, s -> {
        System.out.println(s);
        // Unit type’ında bir value’yu explicit olarak return etmen gerekir.
        return Unit.INSTANCE;
    });
}
```

Java’da function veya lambda Unit return edebilir. Ancak, Unit type’ının Kotlin’de bir value’su olduğu için, bunu
explicit olarak return etmen gerekir. Önceki örnekteki gibi (String) -> Unit olan bir function type’ın argument’i olarak
void return eden bir lambda geçiremezsin.

### Function types: Implementation details

Kotlin function type’larının altında, normal interface’ler vardır: bir function type variable’ı, bir FunctionN interface
implementasyonu olur. Kullanabileceğin interface’ler, function argument sayısına göre numaralandırılmıştır:

Function0<R> (bu function hiç argument almaz ve sadece return type’ını specify eder), Function1<P1, R> (bu function bir
argument alır) ve devamı. Her interface tek bir invoke method define eder ve onu çağırmak function’ı execute eder. (
invoke operator’ı 13. chapter’da daha detaylı olarak tartışılacaktır.) Kısaca, FunctionN interface’leri şöyle görünür:

```kotlin
interface Function1<P1, out R> {
    operator fun invoke(p1: P1): R
}
```

Bir function type variable’ı, ilgili FunctionN interface’ini implement eden bir class’ın instance’ıdır ve invoke
method’u lambda’nın body’sini içerir. Altında, bu:

```kotlin
fun processTheAnswer(f: Function1<Int, Int>) {
    println(f.invoke(42))
}
```

Bu functional type’lar aslında sadece Kotlin interface’leri olduğu için, interface kullanabileceğin her yerde
kullanılabilirler. Örneğin, bir class bir FunctionN interface’inden veya onun eşdeğer functional type’ından inherit
edebilir (her ne kadar pratikte nadiren kullanılsa da):

```kotlin
// Function2<Int, Int, Int> ile eşdeğer
class Adder : (Int, Int) -> Int {
    override fun invoke(
        p1: Int,
        p2: Int
    ): Int {
        return p1 + p2
    }
}
```

FunctionN interface’leri, synthetic compiler-generated type’lardır; yani Kotlin standard library’de declaration’larını
bulamazsın. Bunun yerine, compiler gerektiğinde onları senin için generate eder; bu da herhangi bir sayıda parameter’a
sahip bir function için interface kullanmanı sağlar ve function type parameter sayısı üzerinde yapay bir kısıtlama
olmaz.

### Extra description

Function’ları object olarak represent etmek için, onları represent edecek bir type’a ihtiyacımız vardır. Bir type, bir
object ile ne yapabileceğimizi specify eder; örneğin, hangi method’lara ve property’lere sahip olduğunu belirterek.
Function type, bir object’in function olması gerektiğini specify eden bir type’tır. Bu function’ı invoke method’u ile
çağırabiliriz. Ancak, function’ların farklı parameter ve result type’ları olabileceği için, birçok olası function type
vardır.

Bir function type, parantez ile başlar ve içinde parameter type’larını virgülle ayırarak specify eder. Parantezden sonra
bir ok (->) ve result type gelmelidir. Kotlin’de tüm function’ların bir result type’a sahip olması gerektiğinden,
anlamlı bir value return etmeyen bir function, result type olarak `Unit[^02_1]` declare etmelidir.

![img_4.png](img_4.png)

İşte birkaç function type:

* () -> Unit - en basit function type, hiç argument beklemeyen ve anlamlı bir şey return etmeyen function’ı represent
  eder `[^02_5]`.

* (Int) -> Unit - bir Int type’ında tek bir argument bekleyen ve anlamlı bir şey return etmeyen function’ı represent
  eden function type.

* (String, String) -> Unit - iki String type’ında argument bekleyen ve anlamlı bir şey return etmeyen function’ı
  represent eden function type.

* () -> User - hiç argument beklemeyen ve User type’ında bir object return eden function’ı represent eden function type.

* (String, String) -> String - String türünde iki argument bekleyen ve String türünde bir object döndüren bir function
  type.

* (String) -> Name - String türünde tek bir argument bekleyen ve Name türünde bir object döndüren bir function type.

Boolean döndüren functions, örneğin `(T) -> Boolean`, genellikle predicate olarak adlandırılır. Bir değeri başka bir
değere dönüştüren functions, örneğin `(T) -> R`, genellikle transformation olarak adlandırılır. Unit döndüren functions,
örneğin `(T) -> Unit`, genellikle operation olarak adlandırılır.

Bir function type yalnızca bir method sunar: invoke. Parametreleri ve result type, function type tarafından tanımlandığı
ile aynıdır.

```kotlin
fun fetchText(
    onSuccess: (String) -> Unit,
    onFailure: (Throwable) -> Boolean
) {
    onSuccess.invoke("Some Text") // returns Unit

    val handled: Boolean =
        onFailure.invoke(Error("Some error"))
}

fun main() {
    fetchText(
        onSuccess = { text ->
            println("Success : $it")
        },
        onFailure = { error ->
            println("Error : ${error.message}")
            true // handled
        }
    )
}
```

Senin fetchText fonksiyonun içinde neler olduğunu adım adım takip edelim:

* fetchText çağrılır: Sen iki tane "işlem paketi" (lambda) gönderirsin.

* onSuccess.invoke("Some Text"): Bu satır çalıştığında, senin main içinde { text -> ... } içine yazdığın kod tetiklenir.
  Ekrana "Success..." yazar.

* onFailure.invoke(...): Bu satır çalıştığında, main içindeki ikinci blok tetiklenir. Sen orada true veya false
  döndürürsün. fetchText içindeki val handled değişkeni senin gönderdiğin bu sonucu alır.

Sen main içinde bu fonksiyonu çağırırken aslında fetchText'e iki tane "tarif" veriyorsun:

* "İşler iyi giderse bu tarifi uygula."

* "İşler kötü giderse şu tarifi uygula ve bana durumun çözülüp çözülmediğini (Boolean) söyle."

Invoke bir operator olduğu için `[^02_4]`, bu methoda sahip bir object'i "çağırabiliriz". Bu, implicit bir invoke
call'dur.

```kotlin
fun fetchText(
    onSuccess: (String) -> Unit,
    onFailure: (Throwable) -> Boolean
) {
    onSuccess("Some Text") // returns Unit

    val handled: Boolean = onFailure(Error("Some error"))
}
```

Hangi yaklaşımı tercih edeceğinize kendiniz karar verebilirsiniz. Explicit invoke call'lar daha az deneyimli developer'
lar için daha okunabilirdir. Implicit call ise daha kısadır ve kavramsal açıdan bir object'i çağırmayı daha iyi temsil
eder.

Eğer bir function type nullable ise (bu durumda, parantez ile sarıp sonuna bir soru işareti ekleyin), safe call yalnızca
explicit invoke ile kullanılabilir.

```kotlin
fun someOperations(
    onStart: (() -> Unit)? = null,
    onCompletion: (() -> Unit)? = null
) {
    onStart?.invoke()
    onCompletion?.invoke()
}

fun main() {
    someOperations() // null kontrollerinden dolayı hiç birşey yapmaz

    // Sadece başlangıçta bir şey yapmak istiyorsak:
    someOperations(onStart = {
        println("Process started")
    })

    // Sadece bittiğinde bir şey yapmak istiyorsak:
    someOperations(onCompletion = {
        println("Process done!")
    })

    someOperations(onStart = { println("Started") }) {
        // Bu onCompletion yerine geçer
        println("Process done!")
    }
}
```

Bir function type, bir type beklendiği her yerde kullanılabilir. Örneğin, bir class definition içinde, bir generic type
argument olarak veya bir parameter definition içinde.

```kotlin
class Button(val text: String, val onClick: () -> Unit)

fun logOut() {
    println("Oturum kapatıldı, ana sayfaya yönlendiriliyor...")
}

fun main() {
    val saveButton = Button("Save") {
        println("Save to database")
        println("Saved")
    }

    saveButton.onClick()
    // Save to database
    // Saved

    val logOutButton = Button("Logout", ::logOut)
    logOutButton.onClick() // Oturum kapatıldı, ana sayfaya yönlendiriliyor...
}
```

Bir function type, bir function type definition’ın bir parçası olarak da kullanılabilir. Bir function type’ın bir
function type içerebileceğini anlamak iyidir, her ne kadar bu tür function type’lar nadiren faydalı olsa da.

`(() -> Unit) -> Unit` - argument olarak `() -> Unit` function type’ını bekleyen ve önemsiz bir şey döndüren bir
function type.

`() -> () -> Unit` - hiçbir argument beklemeyen ve `() -> Unit` function type’ını döndüren bir function type.