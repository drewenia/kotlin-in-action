# Java lambdas are automatically converted to Kotlin function types

Chapter 5’de zaten keşfettiğin gibi, Kotlin lambda’sını, functional interface bekleyen herhangi bir Java method’una
automatic SAM (single abstract method) conversion aracılığıyla geçirebilirsin. Bu, Kotlin code’unun Java library’lerine
güvenebileceği ve Java’da define edilmiş higher-order function’ları problemsiz bir şekilde çağırabileceği anlamına
gelir. Benzer şekilde, function type kullanan Kotlin function’ları Java’dan kolayca çağrılabilir. Java lambda’ları,
function type value’larına otomatik olarak dönüştürülür, aşağıdaki listing’de gösterildiği gibi.

```kotlin
/* Kotlin declaration */
fun processTheAnswer(f: (Int) -> Int) {
    println(f(42))
}

fun main() {
    processTheAnswer { it * 2 } // 84
}
```

* Buradaki f bir sayı veya metin değil, bir fonksiyondur.

* (Int): Bu fonksiyon bir tam sayı (Int) kabul eder.

* -> Int: Bu fonksiyon işlem sonucunda bize yine bir tam sayı (Int) döndürür.

```
/* Java */
processTheAnswer(number -> number + 3); // 45
```

Java’da, argument olarak lambda bekleyen Kotlin standard library extension function’larını kolayca kullanabilirsin.
Ancak, Kotlin’deki kadar güzel görünmediklerini unutma—receiver object’i first argument olarak açıkça geçirmen gerekir:

```java
public static void main(String[] args) {
    List<String> strings = new ArrayList<>();
    strings.add("42");
    // Java code’unda Kotlin standard library’den bir function kullanabilirsin.
    CollectionsKt.forEach(strings, s -> {
        System.out.println(s);
        // Unit type’ında bir value’yu explicit olarak return etmen gerekir.
        return Unit.INSTANCE;
    });
}
```

Java’da function veya lambda Unit return edebilir. Ancak, Unit type’ının Kotlin’de bir value’su olduğu için, bunu
explicit olarak return etmen gerekir. Önceki örnekteki gibi (String) -> Unit olan bir function type’ın argument’i olarak
void return eden bir lambda geçiremezsin.

### Function types: Implementation details

Kotlin function type’larının altında, normal interface’ler vardır: bir function type variable’ı, bir FunctionN interface
implementasyonu olur. Kullanabileceğin interface’ler, function argument sayısına göre numaralandırılmıştır:

Function0<R> (bu function hiç argument almaz ve sadece return type’ını specify eder), Function1<P1, R> (bu function bir
argument alır) ve devamı. Her interface tek bir invoke method define eder ve onu çağırmak function’ı execute eder. (
invoke operator’ı 13. chapter’da daha detaylı olarak tartışılacaktır.) Kısaca, FunctionN interface’leri şöyle görünür:

```kotlin
interface Function1<P1, out R> {
    operator fun invoke(p1: P1): R
}
```

Bir function type variable’ı, ilgili FunctionN interface’ini implement eden bir class’ın instance’ıdır ve invoke
method’u lambda’nın body’sini içerir. Altında, bu:

```kotlin
fun processTheAnswer(f: Function1<Int, Int>) {
    println(f.invoke(42))
}
```

Bu functional type’lar aslında sadece Kotlin interface’leri olduğu için, interface kullanabileceğin her yerde
kullanılabilirler. Örneğin, bir class bir FunctionN interface’inden veya onun eşdeğer functional type’ından inherit
edebilir (her ne kadar pratikte nadiren kullanılsa da):

```kotlin
// Function2<Int, Int, Int> ile eşdeğer
class Adder : (Int, Int) -> Int {
    override fun invoke(
        p1: Int,
        p2: Int
    ): Int {
        return p1 + p2
    }
}
```

FunctionN interface’leri, synthetic compiler-generated type’lardır; yani Kotlin standard library’de declaration’larını
bulamazsın. Bunun yerine, compiler gerektiğinde onları senin için generate eder; bu da herhangi bir sayıda parameter’a
sahip bir function için interface kullanmanı sağlar ve function type parameter sayısı üzerinde yapay bir kısıtlama
olmaz.