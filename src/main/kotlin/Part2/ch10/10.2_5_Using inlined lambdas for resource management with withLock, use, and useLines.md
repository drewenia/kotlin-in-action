# Using inlined lambdas for resource management with withLock, use, and useLines

Lambda’ların duplicate code’u ortadan kaldırabileceği yaygın bir pattern, resource management’tır: bir operation’dan
önce resource’u edinmek ve sonra serbest bırakmak. Buradaki resource birçok şeyi ifade edebilir: bir file, bir lock, bir
database transaction vb. Bu tür bir pattern’ı implement etmenin standart yolu, resource’un try bloğundan önce edinildiği
ve finally bloğunda serbest bırakıldığı bir try/finally statement’ı kullanmak veya Java’daki try-with-resources gibi
özel language construct’larını kullanmaktır.

Section 10.2.1’de, try/finally statement’ın logic’ini bir function içinde nasıl encapsulate edebileceğinizi ve
resource’u kullanan code’u lambda olarak bu function’a nasıl geçirebileceğinizi gösteren bir örnek gördünüz. Örnek,
Java’daki synchronized statement ile aynı syntax’a sahip synchronized function’ını gösteriyordu: lock object’i argument
olarak alır. Kotlin standard library, aynı görev için daha idiomatic bir API’ye sahip olan withLock adında başka bir
function da define eder: bu, Lock interface’i üzerinde bir extension function’dır. İşte nasıl kullanılabileceği:

```kotlin
fun main() {
    val l: Lock = ReentrantLock()
    // Verilen action’ı lock altında çalıştırır
    l.withLock {
        // Bu lock ile korunan resource’a erişir
    }
}
```

Kotlin library’de withLock function’ı şu şekilde define edilmiştir:

```kotlin
// Lock’larla çalışma idiomu, ayrı bir function’a çıkarılmıştır.
inline fun <T> Lock.withLock(action: () -> T): T {
    lock()
    try {
        return action()
    } finally {
        unlock()
    }
}
```

Section 14.7.4’te, Kotlin coroutine’ları ve concurrent programming’i daha derinlemesine incelerken, aynı zamanda Lock
varyantına benzer şekilde davranan bir withLock function sağlayan Mutex ile karşılaşacaksınız.

File’lar, bu pattern’ın kullanıldığı bir başka yaygın resource türüdür. Aşağıdaki code, bir file’dan ilk satırı okuyan
bir Kotlin function’ını gösterir. Bunu yapmak için, Kotlin standard library’den use function’ını kullanır. use
function’ı, closable bir resource (Closable interface’ini implement eden bir object) üzerinde çağrılan bir extension
function’dır; argument olarak bir lambda alır. Function, lambda’yı çağırır ve lambda normal şekilde tamamlanmış veya bir
exception fırlatmış olsun, resource’un kapatılmasını garanti eder. Bu örnekte, her ikisi de Closeable’ı implement eden
BufferedReader ve FileReader’ın kullanım sonrası düzgün şekilde kapatılmasını sağlar.

```kotlin
fun readFirstLineFromFile(filename: String): String {
    /* BufferedReader’ı oluşturur, use function’ını çağırır ve file üzerinde operation’ı gerçekleştirmek için bir
    lambda geçirir. */
    BufferedReader(FileReader(filename)).use { br ->
        return br.readLine()
    }
}
```

Elbette, use function’ı inline olduğu için kullanımı herhangi bir performance overhead yaratmaz. Diğer birçok durumda
olduğu gibi, Kotlin standard library daha özel extension function’larla da gelir. use, herhangi bir Closeable türü ile
çalışacak şekilde tasarlanmışken, useLines function’ı File ve Path object’leri için define edilmiştir ve lambda’ya bir
string sequence’e erişim sağlar (chapter 6’da tanıdığınız şekilde). Bu, code’u daha kısa ve idiomatic hâle getirmenize
olanak tanır.

```kotlin
fun readFirstLineFromFile(filename: String): String {
    Path(filename).useLines {
        // it, input file’daki metin satırlarını içeren bir string sequence’idir.
        return it.first()
    }
}
```

### No try-with-resources in Kotlin

Java, file gibi closable resource’larla çalışmak için özel bir syntax’a sahiptir: try-with-resources statement. Java
code’u, bir file’dan ilk satırı okumak için şu şekilde olurdu:

```java
/* Java */
static String readFirstLineFromFile(String fileName) throws IOException {
    try (BufferedReader br =
                 new BufferedReader(new FileReader(fileName))) {
        return br.readLine();
    }
}
```

Kotlin’in eşdeğer özel bir syntax’ı yoktur, çünkü aynı görev use ile aynı şekilde sorunsuz bir biçimde
gerçekleştirilebilir. Bu, lambda’ları argument olarak bekleyen higher-order function’ların ne kadar çok yönlü
olabileceğini bir kez daha güzel şekilde gösterir.

___
___

Lambda’ların body’sinde yukarıda ki iki code'da da, readFirstLineFromFile function’dan bir değer döndürmek için
non-local return kullandığınızı unutmayın — lambda’dan değil, body’sinde lambda çağrısı bulunan
readFirstLineFromFile’dan return edersiniz. Lambda’larda return expression’larının kullanımını detaylı olarak
tartışalım.

### Extra description

Kotlin'de withLock, çoklu iş parçacığı (multi-threading) ortamlarında paylaşılan verilere güvenli erişim sağlamak için
kullanılan bir extension (genişletme) ve higher-order (yüksek seviyeli) fonksiyondur.

Java'daki klasik lock.lock() ve lock.unlock() kullanımının Kotlin tarzı, daha güvenli ve kısa halidir.

```kotlin
class SafeDatabase {
    private val lock = ReentrantLock()
    private val data = mutableListOf<String>()

    fun addData(value: String) {
        lock.withLock {
            // Bu bloğa aynı anda yalnızca bir thread girebilir
            data.add(value)
            println("Added : $value by ${Thread.currentThread().name}")
            // Added : Data-0 by main
            // Added : Data-1 by main
            // Added : Data-2 by main
            // Added : Data-3 by main
            // Added : Data-4 by main
        }
    }
}

fun main() {
    val db = SafeDatabase()
    repeat(5) { i ->
        db.addData("Data-$i")
    }
}
```

finally bloğunu otomatik yönettiği için kilit açık kalmaz. inline olduğu için nesne maliyeti yoktur.

Kotlin'deki use fonksiyonu, "kaynak yönetimi" (resource management) için tasarlanmış harika bir yardımcıdır. Java'daki
try-with-resources yapısının Kotlin'deki karşılığıdır.

En temel amacı şudur: Bir dosyayı, veritabanı bağlantısını veya ağ akışını (stream) açtığında, işin bittiğinde (veya bir
hata oluştuğunda) o kaynağın mutlaka kapatılmasını garanti eder.

```kotlin
fun saveConfig(config: String) {
    File("config.txt").bufferedWriter().use { writer ->
        writer.write(config)
    }
}
fun main() {
    saveConfig("Theme=Dark\nFontSize=14")
    println("Config saved successfully.")
}
```

close() çağırmayı unutma ihtimalini sıfıra indirir. Gereksiz try-finally kalabalığını ortadan kaldırır.

useLines, Kotlin'de büyük dosyaları okurken hem bellek (RAM) dostu hem de güvenli bir yol sunan çok güçlü bir extension
function'dır. Az önce konuştuğumuz use fonksiyonunun "satır satır okuma" versiyonudur diyebiliriz. useLines(): Dosyayı
bir Sequence (akış) olarak açar. Satırları tek tek okur, işler ve bittiğinde dosyayı otomatik olarak kapatır. Tüm
dosyayı aynı anda RAM'e yüklemez.

```kotlin
fun findErrors(filePath: String) {
    File(filePath).useLines { lines ->
        val errors = lines
            .filter { it.contains("ERROR") }
            .map { it.uppercase() }
            .take(5) // Only process until 5 errors are found
            .toList()

        errors.forEach { println(it) }
    } // File is closed here automatically
}
```

Eğer okuyacağınız dosyanın boyutundan emin değilseniz veya dosya büyükse, her zaman useLines tercih etmelisiniz. Bu, "
temiz kod" ve "performanslı kod" prensiplerinin mükemmel bir birleşimidir.