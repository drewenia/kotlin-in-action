# Inlining collection operations

Collection’lar üzerinde çalışan Kotlin standard library function’larının performansını ele alalım. Standard library’deki
collection function’larının çoğu argument olarak lambda expression’lar alır. Bu operation’ları standard library
function’larını kullanmak yerine doğrudan implement etmek daha mı verimli olurdu? Örneğin, bir people list’ini
filtrelemenin yollarını, bir sonraki iki code’da gösterildiği gibi karşılaştıralım.

```kotlin
data class Person(val name: String, val age: Int)

val people = listOf(
    Person("Alice", 29),
    Person("Bob", 31),
)
fun main() {
    val filtered = people.filter { it.age < 30 }
    println(filtered) // [Person(name=Alice, age=29)]
}
```

Önceki code, lambda expression’lar olmadan yeniden yazılabilir.

```kotlin
data class Person(val name: String, val age: Int)

val people = listOf(
    Person("Alice", 29),
    Person("Bob", 31),
)

fun main() {
    val result = mutableListOf<Person>()
    for (p in people) {
        if (p.age < 30) result.add(p)
    }
    println(result) // [Person(name=Alice, age=29)]
}
```

Kotlin’de filter function’ı inline olarak declare edilmiştir. Bu, filter function’ının bytecode’unun, ona geçirilen
lambda’nın bytecode’u ile birlikte, filter’ın çağrıldığı yerde inline edileceği anlamına gelir. Sonuç olarak, filter
kullanan ilk sürüm için üretilen bytecode, ikinci sürüm için üretilen bytecode ile yaklaşık olarak aynıdır.
Collection’lar üzerinde idiomatic operation’ları güvenle kullanabilirsiniz ve Kotlin’in inline function desteği
sayesinde performance konusunda endişelenmenize gerek yoktur. Şimdi, filter ve map olmak üzere iki operation’ı bir chain
içinde uyguladığınızı hayal edin:

```kotlin
data class Person(val name: String, val age: Int)

val people = listOf(
    Person("Alice", 29),
    Person("Bob", 31),
)

fun main() {
    val filteredAndMapping = people.filter { it.age > 30 }.map(Person::name)
    println(filteredAndMapping) // [Bob]
}
```

Bu örnek, bir lambda expression ve bir member reference kullanır. Bir kez daha, hem filter hem de map inline olarak
declare edilmiştir; bu nedenle body’leri inline edilir ve ek class’lar veya object’ler oluşturulmaz. Ancak code, list’i
filtrelemenin sonucunu saklamak için bir intermediate collection oluşturur. filter function’ından üretilen code,
element’leri bu collection’a ekler ve map’ten üretilen code ise buradan okur.

Process edilecek element sayısı büyükse ve intermediate collection’ın overhead’i bir endişe haline geliyorsa, chain’e
bir asSequence call ekleyerek sequence kullanabilirsiniz. Sequence’leri chapter 6’da tartışmıştık; ancak section
10.2.2’de gördüğünüz gibi, sequence’i işlemek için kullanılan lambda’lar inline edilmez. Her intermediate sequence,
field’ında bir lambda saklayan bir object olarak temsil edilir ve terminal operation, her intermediate sequence
üzerinden bir call chain’inin gerçekleştirilmesine neden olur. Bu nedenle, sequence’ler üzerindeki operation’lar lazy
olsa bile, code’unuzdaki her collection operation chain’ine bir asSequence call eklemeye çalışmamalısınız. Bu yaklaşım
yalnızca büyük collection’lar için faydalıdır; daha küçük olanlar, normal collection operation’larıyla rahatlıkla
process edilebilir.