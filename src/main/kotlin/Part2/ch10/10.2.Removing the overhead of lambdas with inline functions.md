# Removing the overhead of lambdas with inline functions

Muhtemelen, Kotlin’de bir lambda’yı function’a argument olarak geçmenin kısa syntax’ının, if ve for gibi normal
statement’ların syntax’ına benzer göründüğünü fark etmişsinizdir. Bunu, chapter 5’te with ve apply function’larını
tartışırken görmüştünüz. Peki performans ne olacak? Java statement’larıyla tamamen aynı görünen function’ları
tanımlayarak hoş olmayan sürprizler yaratmıyor muyuz, çünkü bunlar çok daha yavaş çalışıyor olabilir mi?

Chapter 5’te lambda’ların normalde anonymous class’lara compile edildiğini açıkladık. Ancak bu, her lambda expression
kullandığınızda ek bir class oluşturulacağı anlamına gelir ve eğer lambda bazı variable’ları capture ediyorsa, her
invocation’da yeni bir object oluşturulur. Bu, runtime overhead yaratır ve lambda kullanan bir implementation’ın, aynı
code’u doğrudan çalıştıran bir function’dan daha az verimli olmasına neden olur.

Compiler’a, code’u doğrudan çalıştırmak kadar verimli olacak şekilde code üretmesini söylemek, ama yine de tekrarlanan
mantığı bir library function’a çıkarmak mümkün mü? Aslında, Kotlin compiler bunu yapmanıza izin verir. Bir function’ı
inline modifier ile işaretlerseniz, compiler bu function kullanıldığında bir function call oluşturmaz; bunun yerine
function’a yapılan her çağrıyı, function’ı gerçekleştiren gerçek code ile değiştirir. Bunun nasıl çalıştığını detaylı
olarak inceleyelim ve bazı örnekleri gözden geçirelim.