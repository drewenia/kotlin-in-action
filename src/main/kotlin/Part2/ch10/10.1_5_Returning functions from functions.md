# Returning functions from functions

Bir function’dan başka bir function döndürme gereksinimi, function’ları başka function’lara argument olarak geçirmek
kadar sık ortaya çıkmaz, ancak yine de faydalıdır. Örneğin, bir programdaki bir logic parçasının, programın state’ine
veya diğer koşullara bağlı olarak değişebildiğini hayal edin — örneğin, seçilen gönderim yöntemine bağlı olarak kargo
maliyetinin hesaplanması. Uygun mantık varyantını seçen ve onu başka bir function olarak döndüren bir function define
edebilirsiniz. Aşağıda bunun code olarak nasıl göründüğünü gösterir.

```kotlin
enum class Delivery { STANDART, EXPEDITED }

class Order(val itemCount: Int)

// Bir function döndüren bir function declare eder
fun getShippingCostCalculator(delivery: Delivery): (Order) -> Double {
    if (delivery == Delivery.EXPEDITED) {
        // Function’dan lambda’lar döndürür
        return { order -> 6 + 2.1 * order.itemCount }
    }

    // Function’dan lambda’lar döndürür
    return { order -> 1.2 * order.itemCount }
}

fun main() {
    // Döndürülen function’ı bir variable’da saklar
    val calculator = getShippingCostCalculator(Delivery.EXPEDITED)

    // Döndürülen function’ı invoke eder
    println("Shipping costs ${calculator(Order(3))}")
}
```

Başka bir function döndüren bir function declare etmek için, return type olarak bir function type belirtirsiniz.
getShippingCostCalculator bir Order alan ve Double döndüren bir function döndürür. Bir function döndürmek için,
return ifadesinin ardından bir lambda; bir member reference; ya da local bir variable gibi başka bir function type
ifadesi yazarsınız.

Function’lardan function döndürmenin faydalı olduğu bir başka örneğe bakalım. Bir GUI contact-management application
üzerinde çalıştığınızı ve UI’nin state’ine bağlı olarak hangi contact’ların gösterileceğini belirlemeniz gerektiğini
varsayın. UI’nin bir string girmenize izin verdiğini ve ardından adı bu string ile başlayan contact’ları gösterdiğini;
ayrıca phone number belirtilmemiş contact’ları gizlemenize olanak tanıdığını düşünelim. Seçeneklerin state’ini saklamak
için ContactListFilters class’ını kullanacaksınız:

```kotlin
class ContactListFilters {
    var prefix: String = ""
    var onlyWithPhoneNumber: Boolean = false
}
```

Bir kullanıcı, first veya last name’i D ile başlayan contact’ları görmek için D yazdığında, prefix value’su güncellenir.
Gerekli değişiklikleri yapan code’u çıkardık. (Tam bir UI application bu kitap için fazla code olurdu, bu yüzden burada
sadeleştirilmiş bir örnek sunuyoruz.)

Contact list display logic’ini filtering UI’den ayırmak için, aşağıdaki code’da gösterildiği gibi contact list’i
filtrelemek için kullanılan bir predicate oluşturan bir function define edebilirsiniz. Bu predicate, prefix’i kontrol
eder ve gerekliyse phone number’ın mevcut olup olmadığını da kontrol eder.

```kotlin
data class Person(
    val firstName: String,
    val lastName: String,
    val phoneNumber: String?
)

class ContactListFilters {
    var prefix: String = ""
    var onlyWithPhoneNumber: Boolean = false

    fun getPredicate(): (Person) -> Boolean {
        // Bir function döndüren bir function declare eder
        val startsWithPrefix = { p: Person ->
            p.firstName.startsWith(prefix) ||
                    p.lastName.startsWith(prefix)
        }
        if (!onlyWithPhoneNumber) {
            // Bir function type türünde bir variable döndürür
            return startsWithPrefix
        }
        // Bu function’dan bir lambda döndürür
        return { startsWithPrefix(it) && it.phoneNumber != null }
    }
}

fun main() {
    val contacts = listOf(
        Person("Dimitry", "Jemerov", "123-4567"),
        Person("Swetlana", "Isakova", null)
    )

    val contactListFilters = ContactListFilters()
    with(contactListFilters) {
        prefix = "D"
        onlyWithPhoneNumber = true
    }

    // contacts.filter(contactListFilters.getPredicate())
    // getPredicate tarafından döndürülen function’ı filter’a argument olarak geçirir
    val filtered = contacts.filter(contactListFilters.getPredicate())
    println(filtered) // [Person(firstName=Dimitry, lastName=Jemerov, phoneNumber=123-4567)]

    val contactListFilters2 = ContactListFilters();
    with(contactListFilters2) {
        onlyWithPhoneNumber = false
    }

    val filtered2 = contacts.filter(contactListFilters2.getPredicate())
    println(filtered2)
    // [Person(firstName=Dimitry, lastName=Jemerov, phoneNumber=123-4567),
    // Person(firstName=Swetlana, lastName=Isakova, phoneNumber=null)]
}
```

getPredicate method’u, filter function’ına argument olarak geçirdiğiniz bir function value döndürür. Kotlin function
type’ları, bunu string gibi diğer type’ların value’ları için olduğu kadar kolay bir şekilde yapmanıza olanak tanır.
Higher-order function’lar, code’unuzun structure’ını iyileştirmek ve tekrarları ortadan kaldırmak için son derece güçlü
bir araçtır. Sırada, lambda’ların code’unuzdan tekrarlanan mantığı nasıl çıkarmaya yardımcı olabildiğini görelim.