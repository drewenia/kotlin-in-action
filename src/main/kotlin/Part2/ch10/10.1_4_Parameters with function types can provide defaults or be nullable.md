# Parameters with function types can provide defaults or be nullable

Bir function type türünde bir parameter declare ettiğinizde, onun default value’sunu da belirtebilirsiniz. Bunun nerede
faydalı olabileceğini görmek için, chapter 3’te tartıştığımız joinToString function’ına geri dönelim. İşte ulaştığımız
implementation.

```kotlin
fun <T> Collection<T>.joinToString(
    seperator: String = ", ",
    prefix: String = "#",
    postfix: String = "#"
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(seperator)
        // object’i string’e dönüştürür, default toString method’unu kullanarak
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
```

Bu implementation esnektir, ancak conversion'ın önemli bir yönünü kontrol etmenize izin vermez: collection içindeki tek
tek value’ların string’e nasıl dönüştürüldüğü. Kod, her zaman object’i toString method’unu kullanarak string’e
dönüştüren `StringBuilder.append(o: Any?)` kullanır. Bu, birçok casede iyi çalışır ancak her zaman değil. Artık
value’ların string’e nasıl dönüştürüleceğini belirtmek için bir lambda geçebileceğinizi biliyorsunuz. Ancak tüm
caller’ların bu lambda’yı geçmesini zorunlu kılmak zahmetli olurdu, çünkü çoğu default behavior ile sorun yaşamaz. Bunu
çözmek için, bir function type türünde parameter define edebilir ve onun için lambda olarak bir default value
belirleyebilirsiniz.

```kotlin
fun <T> Collection<T>.joinToString(
    seperator: String = ", ",
    prefix: String = "#",
    postfix: String = "#",
    // Lambda’yı default value olarak kullanan bir function type türünde bir parameter declare eder
    transform: (T) -> String = { it.toString() }
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(seperator)
        // transform parameter’ı için argument olarak geçirilen function’ı call eder
        result.append(transform(element))
    }
    result.append(postfix)
    return result.toString()
}

fun main() {
    val letters = listOf("Alpha", "Beta")

    // Default conversion function’ı kullanır
    println(letters.joinToString()) // #Alpha, Beta#

    // Argument olarak bir lambda geçirir
    println(letters.joinToString { it.lowercase() }) // #alpha, beta#

    // Bir lambda dahil olmak üzere birden fazla argument geçirmek için named argument syntax’ını kullanır
    println(letters.joinToString(seperator = "$", prefix = "∫", postfix = "∫", transform = { it.uppercase() }))
    // ∫ALPHA$BETA∫
}
```

Bu function’ın generic olduğuna dikkat edin: collection içindeki element’in type’ını ifade eden bir type parameter T’ye
sahiptir. transform lambda’sı bu type’tan bir argument alacaktır. Bir function type için default value declare etmek
özel bir syntax gerektirmez — değeri = işaretinden sonra bir lambda olarak yazmanız yeterlidir. Yukarıda ki örnekte,
function’ı çağırmanın farklı yollarını gösterir: lambda’yı tamamen atlamak (böylece default toString() dönüşümü
kullanılır), onu parantezlerin dışında geçirmek (çünkü joinToString function’ının son argument’ıdır) ve onu named
argument olarak geçirmek.

Alternatif bir yaklaşım, nullable bir function type türünde bir parameter declare etmektir. Böyle bir parameter ile
geçirilen function’ı doğrudan call edemezsiniz: Kotlin bu durumda null pointer exception olasılığını tespit ettiği için
bu kodu compile etmeyi reddeder. Bir seçenek, null durumunu explicit olarak kontrol etmektir:

```kotlin
fun foo(callback: (() -> Unit)?) {
// ...
    if (callback != null) {
        callback()
    }
}
```

Daha kısa bir sürüm, bir function type’ın invoke method’una sahip bir interface’in implementation’ı olduğu gerçeğinden
yararlanır. Normal bir method olarak invoke, safe-call syntax’ı üzerinden çağrılabilir: `callback?.invoke()`. Aşağıdaki
code, bu tekniği kullanarak joinToString function’ını nasıl yeniden yazabileceğinizi gösterir.

```kotlin
fun <T> Collection<T>.joinToString(
    seperator: String = ", ",
    prefix: String = "#",
    postfix: String = "#",
    // Nullable bir function type türünde bir parameter declare eder
    transform: ((T) -> String)? = null
): String {
    val result = StringBuilder(prefix)
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(seperator)
        // Function’ı call etmek için safe-call syntax’ını kullanır
        val str = transform?.invoke(element)
        // Callback’in belirtilmediği durumu handle etmek için Elvis operator’ünü kullanır
            ?: element.toString()
        result.append(str)
    }
    result.append(postfix)
    return result.toString()
}
```

transform, nullable bir function type türünde bir parameter’dır ancak non-nullable bir return type’a sahiptir. transform
null değilse, String type’ında non-null bir value döndüreceği garanti edilir. Artık function’ları argument olarak alan
function’ları nasıl yazacağınızı biliyorsunuz. Şimdi higher-order function’ların diğer türüne bakalım: başka
function’lar döndüren function’lar.