# Making code more reusable by reducing duplication with lambdas

Birlikte, function type’lar ve lambda expression’lar yeniden kullanılabilir code oluşturmak için harika bir araç
oluşturur. Önceden yalnızca zahmetli yapılarla kaçınılabilecek birçok code tekrarını, artık kısa ve öz lambda
expression’lar kullanarak ortadan kaldırabilirsiniz. Bir web sitesine yapılan ziyaretleri analiz eden bir örneğe
bakalım. SiteVisit class’ı, her ziyaretin path’ini, süresini ve kullanıcının OS’ini saklar. Çeşitli OS’ler bir enum ile
temsil edilir.

Windows makinelerinden yapılan ziyaretlerin ortalama süresini görüntülemeniz gerektiğini hayal edin. Bu görevi average
function’ını kullanarak gerçekleştirebilirsiniz.

```kotlin
enum class OS {
    WINDOWS,
    LINUX,
    MACOS,
    IOS,
    ANDROID
}

data class SiteVisit(
    val path: String,
    val duration: Double,
    val os: OS
)

val log = listOf(
    SiteVisit("/", 34.0, OS.WINDOWS),
    SiteVisit("/", 22.0, OS.MACOS),
    SiteVisit("/login", 12.0, OS.WINDOWS),
    SiteVisit("/signup", 8.0, OS.IOS),
    SiteVisit("/", 16.3, OS.ANDROID)
)

val averageWindowsDuration = log
    .filter { it.os == OS.WINDOWS }
    .map(SiteVisit::duration)
    .average()


fun main() {
    println(averageWindowsDuration) // 23.0
}
```

Şimdi de Mac kullanıcıları için aynı istatistikleri hesaplamanız gerektiğini varsayın. Tekrarı önlemek için platform’u
bir parameter olarak çıkarabilirsiniz.

```kotlin
enum class OS {
    WINDOWS,
    LINUX,
    MACOS,
    IOS,
    ANDROID
}

data class SiteVisit(
    val path: String,
    val duration: Double,
    val os: OS
)

val log = listOf(
    SiteVisit("/", 34.0, OS.WINDOWS),
    SiteVisit("/", 22.0, OS.MACOS),
    SiteVisit("/login", 12.0, OS.WINDOWS),
    SiteVisit("/signup", 8.0, OS.IOS),
    SiteVisit("/", 16.3, OS.ANDROID)
)

// Tekrarlanan code, function’ın içine çıkarılır
fun List<SiteVisit>.averageDurationFor(os: OS) =
    log.filter { it.os == os }.map(SiteVisit::duration).average()


fun main() {
    println(log.averageDurationFor(OS.MACOS)) // 22.0
}
```

Bu function’ı bir extension olarak yapmanın okunabilirliği nasıl artırdığına dikkat edin. Hatta yalnızca local
context’te anlamlıysa bu function’ı local bir extension function olarak da declare edebilirsiniz.

Ancak bu yeterince güçlü değildir. Mobile platform’lardan (şu anda ikisini tanıyorsunuz: iOS ve Android) gelen
ziyaretlerin ortalama süresiyle ilgilendiğinizi hayal edin.

```kotlin
fun main() {
    val averageMobileDuration = log
        .filter { it.os in setOf(OS.IOS, OS.ANDROID) }
        .map(SiteVisit::duration)
        .average()
    println(averageMobileDuration) // 12.15
}
```

Artık platform’u temsil eden basit bir parameter işinizi görmez. Ayrıca log’u daha karmaşık koşullarla sorgulamak
isteyeceğiniz de muhtemeldir; örneğin, “iOS’tan signup page’e yapılan ziyaretlerin ortalama süresi nedir?” Lambda’lar
burada yardımcı olabilir. Gerekli koşulu bir parameter içine çıkarmak için function type’ları kullanabilirsiniz.

```kotlin
enum class OS {
    WINDOWS,
    LINUX,
    MACOS,
    IOS,
    ANDROID
}

data class SiteVisit(
    val path: String,
    val duration: Double,
    val os: OS
)

val log = listOf(
    SiteVisit("/", 34.0, OS.WINDOWS),
    SiteVisit("/", 22.0, OS.MACOS),
    SiteVisit("/login", 12.0, OS.WINDOWS),
    SiteVisit("/signup", 8.0, OS.IOS),
    SiteVisit("/", 16.3, OS.ANDROID)
)

fun List<SiteVisit>.averageDurationFor(predicate: (SiteVisit) -> Boolean) =
    filter(predicate).map(SiteVisit::duration).average()


fun main() {
    val averageDuration = log.averageDurationFor { it.os == OS.IOS && it.path == "/signup" }
    println(averageDuration) // 8.0
}
```

Function type’lar code tekrarını ortadan kaldırmaya yardımcı olabilir. Bir code parçasını kopyalayıp yapıştırma isteği
duyuyorsanız, bu tekrarın büyük olasılıkla önlenebileceğini gösterir. Lambda’lar ile yalnızca tekrar eden data’yı değil,
behavior’ı da dışarı çıkarabilirsiniz.

Bazı iyi bilinen design pattern’lar, function type’lar ve lambda expression’lar kullanılarak basitleştirilebilir.
Örneğin strategy pattern’ı ele alalım. Lambda expression’lar olmadan, her olası strategy için bir interface declare
etmenizi ve birden fazla implementation yazmanızı gerektirir. Dilinizde function type’lar olduğunda, strategy’yi
tanımlamak için genel bir function type kullanabilir ve farklı lambda expression’ları farklı strategy’ler olarak
geçebilirsiniz.

Higher-order function’ların nasıl oluşturulacağını tartıştık. Şimdi de performanslarına bakalım. Her şey için
higher-order function’lar kullanmaya başlarsanız, iyi eski loop’lar ve condition’lar yazmak yerine code’unuz daha yavaş
olmaz mı? Bir sonraki bölüm, bunun neden her zaman böyle olmadığını ve inline keyword’ünün nasıl yardımcı olabileceğini
ele alır.