# Applying an operation and immediately assigning its value: Overloading compound assignment operators

Normalde, 9.1.1 bölümünde yaptığınız gibi plus gibi bir operator define ettiğinizde, Kotlin yalnızca + operation’ını
değil, += operation’ını da destekler. +=, -= ve benzeri operator’lere compound assignment operator’leri denir. Aşağıda
bir örnek verilmiştir:

```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}

fun main() {
    var point = Point(1, 2)
    point += Point(3, 4)
    println(point) // Point(x=4, y=6)
}
```

Bu, `point = point + Point(3, 4)` yazmakla aynıdır. Elbette bu, yalnızca point variable’ı mutable ise çalışır.
Bazı case’lerde, += operation’ını, kullanıldığı variable’ın referansını yeniden assign etmeden, o referansın işaret
ettiği object’i değiştirecek şekilde define etmek anlamlıdır. Bunun bir örneği, mutable bir collection’a bir element
eklemektir:

```kotlin
fun main() {
    val numbers = mutableListOf<Int>()
    numbers += 42
    println(numbers[0]) // 42
}
```

Unit dönüş type’ına sahip plusAssign adlı bir function define eder ve bunu operator keyword’ü ile işaretlerseniz, +=
operator’ü kullanıldığında Kotlin bu function’ı call eder. Diğer binary aritmetik operator’lerin de benzer şekilde
adlandırılmış karşılıkları vardır: minusAssign, timesAssign ve benzerleri.

Kotlin standart kütüphanesi, mutable bir collection üzerinde plusAssign adlı bir function define eder ve önceki örnek
bunu (+=) kullanır.

```kotlin
operator fun <T> MutableCollection<T>.plusAssign(element: T) {
    this.add(element)
}
```

Code’unuzda += yazdığınızda, teorik olarak hem plus hem de plusAssign function’ları call edilebilir.

+= operator’ü, ya plus ya da plusAssign function call’una dönüştürülebilir.

![img_3.png](img_3.png)

Eğer durum böyleyse ve her iki function da define edilmiş ve uygulanabilirse, compiler bir hata raporlar. Bunu çözmenin
bir yolu, operator kullanımınızı normal bir function call ile değiştirmektir. Bir diğer yol ise var’ı val ile
değiştirmektir; böylece plusAssign operation’ı uygulanamaz hale gelir. Ancak genel olarak, yeni class’ları tutarlı bir
şekilde tasarlamak en iyisidir: aynı anda hem plus hem de plusAssign operation’larını eklememeye çalışın. Class’ınız,
önceki örneklerden biri olan Point gibi immutable ise, yalnızca yeni bir değer döndüren operation’lar (örneğin plus)
sağlamalısınız. Eğer mutable bir class tasarlıyorsanız, örneğin bir builder, yalnızca plusAssign ve benzeri
operation’ları sağlamalısınız.

Kotlin standart kütüphanesi, collection’lar için her iki yaklaşımı da destekler. + ve - operator’leri her zaman yeni bir
collection döndürür. += ve -= operator’leri, mutable collection’lar üzerinde onları yerinde değiştirerek çalışır;
read-only collection’lar üzerinde ise değiştirilen bir kopyayı döndürür. (Bu, += ve -= operator’lerinin yalnızca onu
refer eden variable var olarak declare edilmişse read-only collection ile kullanılabileceği anlamına gelir.) Bu
operator’lerin operand’ları olarak, ya tek tek element’ler ya da eşleşen element type’ına sahip diğer collection’ları
kullanabilirsiniz:

```kotlin
fun main() {
    val list = mutableListOf(1, 2)
    list += 3

    val newList = list + listOf(4, 5)

    println(list) // [1, 2, 3]
    println(newList) // [1, 2, 3, 4, 5]
}
```

Şimdiye kadar, iki değer üzerinde uygulanan operator’ler olan binary operator’lerin overload edilmesini tartıştık;
örneğin a + b. Buna ek olarak, Kotlin, -a gibi tek bir değer üzerinde uygulanan unary operator’leri de overload etmenize
izin verir.