# Plus, times, divide, and more: Overloading binary arithmetic operations

Destekleyeceğiniz ilk operation, iki point’i birbirine eklemektir. Bu operation, point’lerin x ve y koordinatlarını
toplar. Bunun nasıl implement edilebileceği aşağıda gösterilmektedir.

```kotlin
fun main() {
    val p1 = Point(10, 20)
    val p2 = Point(30, 40)

    // + işaretini kullanarak plus function’ını call eder
    val p3 = p1 + p2
    println(p3) // Point(x=40, y=60)
}

data class Point(val x: Int, val y: Int) {
    // plus adlı bir operator function define eder
    operator fun plus(other: Point): Point {
        // Koordinatları ekler ve yeni bir point döner
        return Point(x + other.x, y + other.y)
    }
}
```

operator keyword’ünü kullanarak plus function’ını declare ettiğinize dikkat edin. Operator’leri overload etmek için
kullanılan tüm function’lar bu keyword ile işaretlenmelidir. Bu, function’ı ilgili convention’ın bir implementasyonu
olarak kullanmayı amaçladığınızı açıkça belirtir ve yanlışlıkla aynı isme sahip bir function define etmediğinizi
gösterir.

operator modifier ile plus function’ını declare ettikten sonra, object’lerinizi yalnızca `+` işaretini kullanarak
toplayabilirsiniz: a + b, a.plus(b). Arka planda, plus function’ına başvurulur:

`+` operator’ü, bir plus function call’una dönüştürülür.

![img.png](img.png)

Operator’ü bir member olarak declare etmeye alternatif olarak, operator’ü bir extension function olarak define
edebilirsiniz.

```kotlin
fun main() {
    val p1 = Point(10, 20)
    val p2 = Point(15, 33)
    println(p1 + p2) // Point(x=25, y=53)
}

data class Point(val x: Int, val y: Int)

operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}
```

Implementasyon tamamen aynıdır. İlerideki örnekler extension function syntax’ını kullanacaktır; çünkü external library
class’ları için convention extension function’ları define etmek yaygın bir pattern’dir ve aynı syntax kendi
class’larınız için de sorunsuz şekilde çalışır.

Bazı diğer dillere kıyasla, Kotlin’de overload edilmiş operator’leri define etmek ve kullanmak daha basittir; çünkü
kendi operator’lerinizi define edemezsiniz. İki operand arasında bir function kullanabilmek istediğiniz case’ler için (
yani a myOp b), Kotlin infix function’lar sunar; bunlar 3.4 bölümünde ele alınmıştır ve 13.4.1 bölümünde tekrar
incelenecektir. Bunlar, custom operator’lerin temel syntax avantajını — function call’unun her iki tarafında
operand’ların bulunmasını — sağlar; ancak anlamlarını zahmetle hatırlamanız gereken keyfi sembol kombinasyonlarını
tanıtmadan bunu yapar.

Kotlin’de overload edebileceğiniz sınırlı sayıda operator vardır ve her biri, class’ınızda define etmeniz gereken
function ismine karşılık gelir. Tablo 9.1, define edebileceğiniz tüm binary operator’leri ve bunlara karşılık gelen
function isimlerini listeler.

![img_1.png](img_1.png)

Kendi type’larınız için operator’ler her zaman standart numeric type’larla aynı precedence’ı kullanır. Örneğin, a + b *
c yazarsanız, bu operator’leri kendiniz define etmiş olsanız bile çarpma her zaman toplama işleminden önce execute
edilir. *, / ve % operator’leri aynı precedence’a sahiptir ve bu precedence, + ve - operator’lerinin precedence’ından
daha yüksektir.

### Operator functions and Java

Kotlin operator’leri Java’dan kolayca call edilebilir: çünkü overload edilmiş her operator, bir Kotlin function’ı
olarak (operator modifier ile) define edilir ve bunları tam adını kullanarak normal function’lar gibi call edersiniz.
Kotlin’den Java’yı call ettiğinizde, isimleri Kotlin conventions’larıyla eşleşen herhangi bir method için operator
syntax’ını kullanabilirsiniz. Java, operator function’ları işaretlemek için herhangi bir syntax define etmediğinden,
operator modifier kullanma gereksinimi geçerli değildir ve eşleşen isim ile parameter sayısı tek kısıtlamadır. Eğer bir
Java class’ı ihtiyacınız olan behavior’a sahip bir method define ediyor ancak ona farklı bir isim veriyorsa, mevcut Java
method’una delegate eden doğru isimli bir extension function define edebilirsiniz.

___
___

Bir operator define ettiğinizde, iki operand için aynı type’ları kullanmanız gerekmez. Örneğin, bir point’i belirli bir
sayı ile ölçeklemenize izin veren bir operator define edelim. Bunu, point’leri farklı koordinat sistemleri arasında
dönüştürmek için kullanabilirsiniz.

```kotlin
fun main() {
    val p = Point(10, 20)

    println(p * 1.5) // Point(x=15, y=30)
}

data class Point(val x: Int, val y: Int)

operator fun Point.times(scale: Double): Point =
    Point((x * scale).toInt(), (y * scale).toInt())
```

Kotlin operator’lerinin otomatik olarak commutativity’yi (bir operator’ün sol ve sağ taraflarının yer değiştirebilme
özelliği) desteklemediğine dikkat edin. Kullanıcıların p * 1.5’e ek olarak 1.5 * p yazabilmesini istiyorsanız, bunun
için ayrı bir operator define etmeniz gerekir:

```kotlin
operator fun Double.times(p: Point): Point
```

Bir operator function’ın dönüş type’ı, operand type’larının herhangi birinden de farklı olabilir. Örneğin, bir karakteri
belirli sayıda tekrar ederek bir string oluşturan bir operator define edebilirsiniz.

```kotlin
operator fun Char.times(count: Int): String {
    return toString().repeat(count)
}

fun main() {
    val a = 'a'
    println(a * 3) // aaa
}
```

Bu operator, sol operand olarak bir Char, sağ operand olarak bir Int alır ve sonuç type’ı String’dir. Operand ve sonuç
type’larının bu tür kombinasyonları tamamen kabul edilebilirdir.

Operator function’ları normal function’lar gibi overload edebileceğinizi unutmayın: aynı method adı için farklı
parameter type’larına sahip birden fazla method define edebilirsiniz.

### No special operators for bitwise operations

Kotlin, standart number type’lar için (8.1 bölümünde tanıdığınız üzere hem signed hem de unsigned) herhangi bir bitwise
operator define etmez; dolayısıyla bunları kendi type’larınız için de define etmenize izin vermez. Bunun yerine, 3.4
bölümünde gördüğünüz infix call syntax’ını destekleyen normal function’ları kullanır. Kendi type’larınızla çalışan
benzer function’ları define edebilirsiniz.

Kotlin tarafından bitwise operation’ları gerçekleştirmek için sağlanan function’ların tam listesi aşağıdadır:

![img_2.png](img_2.png)

```kotlin
fun main() {
    println(0x0F and 0xF0) // 0

    println(0x0F or 0xF0) // 255

    println(0x1 shl 4) // 16
}
```

Şimdi, assignment ile karşılık gelen aritmetik operator’ü birleştiren += gibi operator’leri ele alalım.