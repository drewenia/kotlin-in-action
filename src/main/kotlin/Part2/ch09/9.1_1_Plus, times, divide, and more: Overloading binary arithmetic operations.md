# Plus, times, divide, and more: Overloading binary arithmetic operations

Destekleyeceğiniz ilk operation, iki point’i birbirine eklemektir. Bu operation, point’lerin x ve y koordinatlarını
toplar. Bunun nasıl implement edilebileceği aşağıda gösterilmektedir.

```kotlin
data class Point(val x: Int, val y: Int) {
    // plus adlı bir operator function define eder
    operator fun plus(other: Point): Point {
        // Koordinatları ekler ve yeni bir point döner
        return Point(x + other.x, y + other.y)
    }
}

fun main() {
    val p1 = Point(10, 20)
    val p2 = Point(30, 40)

    // + işaretini kullanarak plus function’ını call eder
    val p3 = p1 + p2
    println(p3) // Point(x=40, y=60)
}


```

operator keyword’ünü kullanarak plus function’ını declare ettiğinize dikkat edin. Operator’leri overload etmek için
kullanılan tüm function’lar bu keyword ile işaretlenmelidir. Bu, function’ı ilgili convention’ın bir implementasyonu
olarak kullanmayı amaçladığınızı açıkça belirtir ve yanlışlıkla aynı isme sahip bir function define etmediğinizi
gösterir.

operator modifier ile plus function’ını declare ettikten sonra, object’lerinizi yalnızca `+` işaretini kullanarak
toplayabilirsiniz: a + b, a.plus(b). Arka planda, plus function’ına başvurulur:

`+` operator’ü, bir plus function call’una dönüştürülür.

![img.png](img.png)

Operator’ü bir member olarak declare etmeye alternatif olarak, operator’ü bir extension function olarak define
edebilirsiniz.

```kotlin
fun main() {
    val p1 = Point(10, 20)
    val p2 = Point(15, 33)
    println(p1 + p2) // Point(x=25, y=53)
}

data class Point(val x: Int, val y: Int)

operator fun Point.plus(other: Point): Point {
    return Point(x + other.x, y + other.y)
}
```

Implementasyon tamamen aynıdır. İlerideki örnekler extension function syntax’ını kullanacaktır; çünkü external library
class’ları için convention extension function’ları define etmek yaygın bir pattern’dir ve aynı syntax kendi
class’larınız için de sorunsuz şekilde çalışır.

Bazı diğer dillere kıyasla, Kotlin’de overload edilmiş operator’leri define etmek ve kullanmak daha basittir; çünkü
kendi operator’lerinizi define edemezsiniz. İki operand arasında bir function kullanabilmek istediğiniz case’ler için (
yani a myOp b), Kotlin infix function’lar sunar; bunlar 3.4 bölümünde ele alınmıştır ve 13.4.1 bölümünde tekrar
incelenecektir. Bunlar, custom operator’lerin temel syntax avantajını — function call’unun her iki tarafında
operand’ların bulunmasını — sağlar; ancak anlamlarını zahmetle hatırlamanız gereken keyfi sembol kombinasyonlarını
tanıtmadan bunu yapar.

Kotlin’de overload edebileceğiniz sınırlı sayıda operator vardır ve her biri, class’ınızda define etmeniz gereken
function ismine karşılık gelir. Tablo 9.1, define edebileceğiniz tüm binary operator’leri ve bunlara karşılık gelen
function isimlerini listeler.

![img_1.png](img_1.png)

Kendi type’larınız için operator’ler her zaman standart numeric type’larla aynı precedence’ı kullanır. Örneğin, a + b *
c yazarsanız, bu operator’leri kendiniz define etmiş olsanız bile çarpma her zaman toplama işleminden önce execute
edilir. *, / ve % operator’leri aynı precedence’a sahiptir ve bu precedence, + ve - operator’lerinin precedence’ından
daha yüksektir.

### Operator functions and Java

Kotlin operator’leri Java’dan kolayca call edilebilir: çünkü overload edilmiş her operator, bir Kotlin function’ı
olarak (operator modifier ile) define edilir ve bunları tam adını kullanarak normal function’lar gibi call edersiniz.
Kotlin’den Java’yı call ettiğinizde, isimleri Kotlin conventions’larıyla eşleşen herhangi bir method için operator
syntax’ını kullanabilirsiniz. Java, operator function’ları işaretlemek için herhangi bir syntax define etmediğinden,
operator modifier kullanma gereksinimi geçerli değildir ve eşleşen isim ile parameter sayısı tek kısıtlamadır. Eğer bir
Java class’ı ihtiyacınız olan behavior’a sahip bir method define ediyor ancak ona farklı bir isim veriyorsa, mevcut Java
method’una delegate eden doğru isimli bir extension function define edebilirsiniz.

Kotlin'de operator anahtar kelimesiyle tanımladığınız her şey, arka planda aslında özel bir isimle fonksiyona dönüşür.
Java operator overloading desteklemediği için bu fonksiyonları normal ismiyle çağırmanız gerekir.

Kotlin tarafı;

```kotlin
class Point(val x: Int, val y: Int) {
    operator fun plus(other: Point): Point {
        return Point(x + other.x, y + other.y)
    }
}
```

Java tarafı;

```java
public class Playground {
    public static void main(String[] args) {
        Point p1 = new Point(10, 20);
        Point p2 = new Point(5, 5);

        Point result = p1.plus(p2);
        System.out.println(result.getX()); // 15
        System.out.println(result.getY()); // 25
    }
}
```

Java'da operator diye bir kelime yoktur. Ancak Java'daki bir metodun ismi Kotlin'in beklediği standart isimlerden
biriyse (örneğin: plus, minus, times, get, contains), Kotlin bunu otomatik olarak operatör gibi kullanmanıza izin verir.

Java tarafı;

```java
public class Money {
    private int amount;

    public Money(int amount) {
        this.amount = amount;
    }

    // Kotlin'in '*' operatörü için beklediği isim 'times'dır
    public Money times(int quotient) {
        return new Money(amount * quotient);
    }

    public int getAmount() {
        return amount;
    }
}
```

Kotlin tarafı;

```kotlin
fun main() {
    val m1 = Money(100)
    val result = m1 * 2
    println(result.amount) // 200
}
```

Eğer Java tarafındaki metodun ismi Kotlin'in standartlarına uymuyorsa (örneğin plus yerine add denmişse), Kotlin'de bir
extension function yazarak bu bridge'i kurabiliriz.

Java tarafı;

```java
public class Box {
    private int weight;

    public Box(int weight) {
        this.weight = weight;
    }

    public Box addWeight(int extra){
        return new Box(this.weight + extra);
    }

    public int getWeight() {
        return weight;
    }
}
```

Kotlin tarafı;

```kotlin
// 'addWeight' metodunu '+' operatörüne (plus) bağlıyoruz
operator fun Box.plus(extra: Int): Box {
    return this.addWeight(extra)
}

fun main() {
    val myBox = Box(10)
    // Artık '+' kullanabiliriz çünkü extension function bunu 'addWeight'e yönlendiriyor
    val heavyBox = myBox + 5
    println(heavyBox.weight) // 15
}
```

___
___

Bir operator define ettiğinizde, iki operand için aynı type’ları kullanmanız gerekmez. Örneğin, bir point’i belirli bir
sayı ile ölçeklemenize izin veren bir operator define edelim. Bunu, point’leri farklı koordinat sistemleri arasında
dönüştürmek için kullanabilirsiniz.

```kotlin
data class Point(val x: Int, val y: Int)

operator fun Point.times(scale: Double): Point =
    Point((x * scale).toInt(), (y * scale).toInt())

fun main() {
    val p = Point(10, 20)

    println(p * 1.5) // Point(x=15, y=30)
}
```

Kotlin operator’lerinin otomatik olarak commutativity’yi (bir operator’ün sol ve sağ taraflarının yer değiştirebilme
özelliği) desteklemediğine dikkat edin. Kullanıcıların p * 1.5’e ek olarak 1.5 * p yazabilmesini istiyorsanız, bunun
için ayrı bir operator define etmeniz gerekir:

```kotlin
operator fun Double.times(p: Point): Point
```

Bir operator function’ın dönüş type’ı, operand type’larının herhangi birinden de farklı olabilir. Örneğin, bir karakteri
belirli sayıda tekrar ederek bir string oluşturan bir operator define edebilirsiniz.

```kotlin
operator fun Char.times(count: Int): String {
    return toString().repeat(count)
}

fun main() {
    val a = 'a'
    println(a * 3) // aaa
}
```

Bu operator, sol operand olarak bir Char, sağ operand olarak bir Int alır ve sonuç type’ı String’dir. Operand ve sonuç
type’larının bu tür kombinasyonları tamamen kabul edilebilirdir.

Operator function’ları normal function’lar gibi overload edebileceğinizi unutmayın: aynı method adı için farklı
parameter type’larına sahip birden fazla method define edebilirsiniz.

### No special operators for bitwise operations

Kotlin, standart number type’lar için (8.1 bölümünde tanıdığınız üzere hem signed hem de unsigned) herhangi bir bitwise
operator define etmez; dolayısıyla bunları kendi type’larınız için de define etmenize izin vermez. Bunun yerine, 3.4
bölümünde gördüğünüz infix call syntax’ını destekleyen normal function’ları kullanır. Kendi type’larınızla çalışan
benzer function’ları define edebilirsiniz.

Kotlin tarafından bitwise operation’ları gerçekleştirmek için sağlanan function’ların tam listesi aşağıdadır:

![img_2.png](img_2.png)

```kotlin
fun main() {
    println(0x0F and 0xF0) // 0

    println(0x0F or 0xF0) // 255

    println(0x1 shl 4) // 16
}
```

Şimdi, assignment ile karşılık gelen aritmetik operator’ü birleştiren += gibi operator’leri ele alalım.