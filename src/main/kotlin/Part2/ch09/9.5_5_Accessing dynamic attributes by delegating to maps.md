# Accessing dynamic attributes by delegating to maps

Delegated property’lerin devreye girdiği bir diğer yaygın pattern, kendileriyle ilişkili dinamik olarak tanımlanan bir
attribute set’ine sahip object’lerdir. (C# gibi diğer diller, bu tür object’lere expando object der.) Örneğin,
contact-management system’da contact’larınız hakkında arbitrary bilgileri saklamanıza izin veren bir sistemi düşünün.

Sistemdeki her person’ın, özel bir şekilde handle edilen birkaç required property’si vardır (örneğin name). Her
person’ın ayrıca, her biri için farklı olabilen herhangi sayıda ek attribute’u da olabilir (örneğin, en küçük çocuğunun
birthday’i).

Böyle bir sistemi implement etmenin bir yolu, bir person’ın tüm attribute’larını bir map’te saklamak ve özel handling
gerektiren bilgilere erişim için property’ler sağlamaktır. İşte bir örnek.

```kotlin
class Person {
    private val _attributes = mutableMapOf<String, String>()

    val attributes: Map<String, String>
        get() = _attributes

    fun setAttribute(attributeName: String, value: String) {
        _attributes[attributeName] = value
    }

    var name: String
        // Attribute’u map’ten alır
        get() = _attributes["name"]!!
        set(value) {
            // Attribute’u map’e kaydeder
            _attributes["name"] = value
        }
}

fun main() {
    val p = Person()
    val data = mapOf("name" to "Alice", "company" to "jetbrains")
    for ((attributeName, value) in data) {
        p.setAttribute(attributeName, value)
    }
    println(p.name) // Alice
    p.name = "Seb"
    println(p.name) // Seb
    println(p.attributes) // {name=Seb, company=jetbrains}
}
```

Burada, datayı object’e yüklemek için generic bir API kullanıyorsunuz (gerçek bir projede bu JSON deserialization veya
benzeri bir şey olabilir) ve ardından tek bir property’nin value’suna erişmek için specific bir API kullanıyorsunuz.
Bunu delegated property kullanacak şekilde değiştirmek çok basittir; map’i doğrudan by keyword’ünden sonra
koyabilirsiniz.

```kotlin
class Person {
    private val _attributes = mutableMapOf<String, String>()

    fun setAttribute(attributeName: String, value: String) {
        _attributes[attributeName] = value
    }

    var name: String by _attributes
}

fun main() {
    val p = Person()
    val data = mapOf("name" to "Alice", "company" to "jetbrains")
    for ((attributeName, value) in data) {
        p.setAttribute(attributeName, value)
    }
    println(p.name) // Alice
    p.name = "Seb"
    println(p.name) // Seb
}
```

Bu, standard library’nin standart Map ve MutableMap interface’leri üzerinde getValue ve setValue extension
function’larını tanımlamış olması sayesinde çalışır. Property’nin adı, value’yu map’te saklamak için otomatik olarak key
olarak kullanılır. Bir önceki kod da olduğu gibi, `p.name` ifadesi `_attributes.getValue(p, prop)` çağrısını gizler; bu
da kendi içinde `_attributes[prop.name]` olarak implement edilmiştir.

### Extra Description

Map’i delegate olarak kullanmanın bazı use case’leri nelerdir? Çoğu application’da buna ihtiyaç duymanız gerekmez. Ancak
bazı durumlarda, bir API tarafından object’leri, bazı expected key’lere sahip olan ve gelecekte dinamik olarak
eklenebilecek başka key’ler de içerebilen map’ler olarak ele almaya zorlanabilirsiniz.

Kastedilen durumlar şuna benzer: “Bu endpoint, id, displayName vb. property’lere sahip bir user’ı temsil eden bir object
döndürecek ve profile page’de, önceden bilinmeyenler de dahil olmak üzere tüm bu property’ler üzerinde iterate etmeniz
ve her biri için uygun bir view göstermeniz gerekiyor.”

Böyle bir gereksinim için, bir object’i Map kullanarak represent etmemiz gerekir; ardından bu map’i delegate olarak
kullanabiliriz, böylece beklediğimizi bildiğimiz property’leri daha kolay şekilde kullanabiliriz.

```kotlin
class User(val map: Map<String, Any>) {
    val id: Long by map
    val name: String by map
    val age: Int by map
}

fun main() {
    val user = User(
        mapOf<String, Any>(
            "id" to 1234L,
            "name" to "Alice",
            "age" to 29
        )
    )

    println(user.id) // 1234
    println(user.name) // Alice
    println(user.age) // 29
    println(user.map) // {id=1234, name=Alice, age=29}
}
```

Map yalnızca read-only property’ler için kullanılabilir, çünkü read-only bir interface’tir. Read-write property’ler için
MutableMap kullanılmalıdır. Her delegated property değişikliği, delegate ettiği map’te bir değişikliktir ve bu map’teki
herhangi bir değişiklik, property value’sunun farklı olmasına yol açar. MutableMap’e delegate etmek, read/write bir data
source’un shared state’ine erişmek gibidir.

```kotlin
class User(val map : MutableMap<String,Any>){
    var id : Long by map
    var name : String by map
}

fun main() {
    val user = User(
        mutableMapOf(
            "id" to 1234L,
            "name" to "Alice"
        )
    )
    println(user.id) // 1234
    println(user.name) // Alice

    user.id = 2345L
    user.name = "Derek"
    println(user.id) // 2345
    println(user.name) // Derek
    println(user.map) // {id=2345, name=Derek}
}
```