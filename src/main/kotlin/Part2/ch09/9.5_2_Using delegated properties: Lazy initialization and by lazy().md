# Using delegated properties: Lazy initialization and by lazy()

Lazy initialization, bir object’in bir kısmının ilk kez erişildiğinde talep üzerine oluşturulmasını içeren yaygın bir
pattern’dir. Bu, initialization süreci önemli kaynaklar tükettiğinde ve object kullanıldığında verinin her zaman gerekli
olmadığı durumlarda faydalıdır.

Örneğin, bir kişinin yazdığı email’lerin listesini erişmenizi sağlayan bir Person class’ını düşünün. Email’ler bir
database’de saklanır ve erişimi uzun sürer. Email’leri, property’ye ilk erişimde yüklemek ve bunu yalnızca bir kez
yapmak istersiniz. Diyelim ki, email’leri database’den alan aşağıdaki loadEmails function’ına sahipsiniz:

```kotlin
data class Email(val subject: String, val body: String)
data class Person(val name: String)

fun loadEmails(person: Person): List<Email> {
    println("Load emails for ${person.name}")
    return listOf(
        Email("Hey", "How are u?"),
        Email("Meeting", "At 18.00 a clock")
    )
}
```

İşte, her şey yüklenmeden önce null ve sonrasında email listesini saklayan ek bir _emails property kullanarak lazy
loading’i nasıl implement edebileceğiniz. Emails property’si, section 2.2.2’de tanıdığınız custom accessor’ları
kullanır.

```kotlin
data class Email(val subject: String, val body: String)
data class Person(val name: String) {
    // Veriyi saklayan ve emails’in delegate ettiği _emails property
    private var _emails: List<Email>? = null

    val emails: List<Email>
        get() {
            if(_emails == null) {
                // Access edildiğinde veriyi yükler
                _emails = loadEmails(this)
            }
            // Veri daha önce yüklenmişse, onu return eder (cache)
            return _emails!!
        }
}

fun loadEmails(person: Person): List<Email> {
    println("Load emails for ${person.name}")
    return listOf(
        Email("Hey", "How are u?"),
        Email("Meeting", "At 18.00 a clock")
    )
}

fun main() {
    val p = Person("Alice")
    val emails = p.emails
    println(emails)
    // Load emails for Alice
    // [Email(subject=Hey, body=How are u?), Email(subject=Meeting, body=At 18.00 a clock)]
    println(emails)
    // [Email(subject=Hey, body=How are u?), Email(subject=Meeting, body=At 18.00 a clock)]
}
```

Burada, sözde backing property tekniğini kullanıyorsunuz. Bir property’niz var: _emails, değeri saklar; bir diğeri ise
emails, buna read access sağlar. İki property kullanmanız gerekir çünkü property’ler farklı type’lara sahiptir: _emails
nullable, emails ise non-null. İsimlendirmeleri basit bir convention’u takip eder: class’ınızda aynı konsepti temsil
eden iki property olduğunda, private property’ye underscore öneki konur (_emails), public property ise öneksiz olur (
emails).

Bu teknik oldukça sık kullanılabilir, bu yüzden alışmakta fayda var. Ancak code biraz hantal olur: birkaç lazy
property’niz olsaydı ne kadar daha uzun olacağını hayal edin. Üstelik, her zaman doğru çalışmaz: implementasyon thread
safe değildir. İki thread aynı anda emails property’sine erişirse, pahalı loadEmails function’ının iki kez çağrılmasını
önleyecek bir mekanizma yoktur. En iyi ihtimalle bu sadece bazı kaynakların boşa gitmesine yol açar; en kötü ihtimalle
ise uygulamanızda tutarsız bir state oluşur. Şüphesiz, Kotlin daha iyi bir çözüm sunar.

Delegated property kullanımıyla code çok daha basit hale gelir; bu, değeri saklamak için kullanılan backing property’i
ve değerin yalnızca bir kez initialize edilmesini sağlayan logic’i encapsulate edebilir. Burada kullanabileceğiniz
delegate, lazy standard library function tarafından return edilir.

```kotlin
data class Email(val subject: String, val body: String)

data class Person(val name: String) {
    val emails by lazy { loadEmails(this) }
}

fun loadEmails(person: Person): List<Email> {
    println("Load emails for ${person.name}")
    return listOf(
        Email("Hey", "How are u?"),
        Email("Meeting", "At 18.00 a clock")
    )
}

fun main() {
    val p = Person("Alice")
    val emails = p.emails
    println(emails)
    // Load emails for Alice
    // [Email(subject=Hey, body=How are u?), Email(subject=Meeting, body=At 18.00 a clock)]
    println(emails)
    // [Email(subject=Hey, body=How are u?), Email(subject=Meeting, body=At 18.00 a clock)]
}
```

Lazy function, proper signature’a sahip getValue method’u olan bir object return eder, böylece bunu by keyword ile
birlikte kullanarak bir delegated property oluşturabilirsiniz. Lazy’in argument’i, değeri initialize etmek için
çağırdığı bir lambda’dır. Lazy function varsayılan olarak thread safe’dir; gerekirse, hangi lock’un kullanılacağını
belirtmek veya class asla multithreaded ortamda kullanılmayacaksa synchronization’ı tamamen atlamak için ek seçenekler
de belirtebilirsiniz.

Bir sonraki bölümde, delegated property mekanizmasının nasıl çalıştığını detaylı olarak inceleyeceğiz ve burada geçerli
olan convention’ları tartışacağız.

### Kotlin documentation

```kotlin
class Delegate {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): String {
        return "$thisRef, thank you for delegating '${property.name}' to me!"
    }

    operator fun setValue(thisRef: Any?, property: KProperty<*>, value: String) {
        println("$value has been assigned to '${property.name}' in $thisRef.")
    }
}

class Example {
    var p: String by Delegate()
}
```

p’den okuma yaptığınızda, ki bu Delegate’in bir instance’ına delegate edilmiştir, Delegate’ten getValue() function’ı
çağrılır. İlk parametresi, p’yi okuduğunuz object’dir ve ikinci parametre p’nin kendisinin bir açıklamasını içerir (
örneğin, ismini alabilirsiniz).

```kotlin
fun main() {
    val e = Example()
    println(e.p) // Example@34c45dca, thank you for delegating 'p' to me!
}
```

Benzer şekilde, p’ye assign yaptığınızda setValue() function’ı çağrılır. İlk iki parametre aynıdır ve üçüncü parametre
assign edilen value’yu içerir:

```kotlin
fun main() {
    val e = Example()
    e.p = "NEW" // NEW has been assigned to 'p' in Example@34c45dca.
}
```

lazy(), bir lambda alan ve lazy property implement etmek için delegate olarak kullanılabilecek bir Lazy<T> instance’ı
return eden bir function’dır. get()’in ilk çağrısı, lazy()’ye geçirilen lambda’yı çalıştırır ve sonucu hatırlar. Sonraki
get() çağrıları, sadece hatırlanan sonucu return eder.

```kotlin
val lazyValue : String by lazy {
    println("computed")
    "Hello"
}

fun main() {
    println(lazyValue)
    // computed
    // Hello

    println(lazyValue)
    // Hello
}
```

Examples;

```kotlin
class UserProfile(val scores: List<Int>) {
    val averageScore: Double by lazy {
        println("Calculated")
        scores.average()
    }
}

fun main() {
    val user = UserProfile(listOf(80, 90, 100, 70, 85))

    println(user.averageScore)
    // Calculated
    // 85.0

    println(user.averageScore)
    // 85.0
}
```

```kotlin
class DatabaseManager{
    val databaseQuery : String by lazy{
        println("Database connection...")
        "CONNECTION_ESTABLISHED"
    }
}

fun main() {
    val dbManager = DatabaseManager()

    println(dbManager.databaseQuery)
    // Database connection...
    // CONNECTION_ESTABLISHED

    println(dbManager.databaseQuery)
    // CONNECTION_ESTABLISHED
}
```