# Implementing your own delegated properties

Delegated property’lerin nasıl implement edildiğini görmek için başka bir örnek alalım: bir object’in property’si
değiştiğinde listener’ları bilgilendirme task’ı. Bu, birçok farklı durumda faydalıdır—örneğin, object’ler bir UI’de
gösterildiğinde ve object değiştiğinde UI’nin otomatik olarak güncellenmesini istediğinizde.

Bu genellikle observable olarak adlandırılır. Kotlin’de nasıl implement edilebileceğine bakalım. Önce, delegated
property kullanmayan bir varyanta bakalım. Ardından, code’u delegated property kullanacak şekilde refactor edelim.

Observable class, bir Observer listesi yönetir. notifyObservers çağrıldığında, kayıtlı her Observer için onChange
function’ını eski ve yeni property value’ları ile çağırır. Bir Observer yalnızca bu onChange method’u için bir
implementasyon sağlamalıdır, bu nedenle chapter 5’te gördüğünüz gibi bir functional interface kullanmak uygun olur:

```kotlin
fun interface Observer {
    fun onChange(name: String, oldValue: Any?, newValue: Any?)
}

open class Observable {
    val observers = mutableListOf<Observer>()
    fun notifyObservers(propName: String, oldValue: Any?, newValue: Any?) {
        for (obs in observers) {
            obs.onChange(propName, oldValue, newValue)
        }
    }
}
```

Şimdi bir Person class yazalım. Bir read-only property (kişinin adı, genellikle değişmez) ve iki writable property
tanımlayacaksınız: age ve salary. Class, kişinin age veya salary’si değiştirildiğinde observer’larını
bilgilendirecektir.

```kotlin
fun interface Observer {
    fun onChange(propName: String, oldValue: Any?, newValue: Any?)
}

open class Observable {
    val observersList = mutableListOf<Observer>()

    fun addObserver(observer: Observer) {
        observersList.add(observer)
    }

    fun removeObserver(observer: Observer) {
        observersList.remove(observer)
    }

    fun notifyObservers(propName: String, oldValue: Any?, newValue: Any?) {
        for (observer in observersList) {
            observer.onChange(propName, oldValue, newValue)
        }
    }
}

class Person(val name: String, age: Int, salary: Int) : Observable() {
    var age: Int = age
        set(newValue) {
            val oldValue = field
            field = newValue
            notifyObservers("Age", oldValue, newValue)
        }

    var salary: Int = salary
        set(newValue) {
            val oldValue = field
            field = newValue
            notifyObservers("Salary", oldValue, newValue)
        }
}

fun main() {
    val p = Person("Alice", 29, 2000)

    val observer = Observer { propName, oldValue, newValue ->
        println(
            """
            Property $propName changed from $oldValue to $newValue!
            """.trimIndent()
        )
    }

    p.addObserver(observer)

    p.age = 31 // Property Age changed from 29 to 31!
    p.salary = 2500 // Property Salary changed from 2000 to 2500!
    p.removeObserver(observer)
    p.age = 34
}
```

Bu code’un, chapter 4’te tartıştığımız gibi, age ve salary property’lerinin backing field’ına erişmek için field
identifier’ı kullandığına dikkat edin. Setter’larda oldukça fazla tekrarlanan code var. Property’nin değerini saklayacak
ve gerekli notification’ı tetikleyecek bir class çıkarmayı deneyelim.

```kotlin
fun interface Observer {
    fun onChange(propName: String, oldValue: Any?, newValue: Any?)
}

open class Observable {
    val observersList = mutableListOf<Observer>()

    fun addObserver(observer: Observer) {
        observersList.add(observer)
    }

    fun removeObserver(observer: Observer) {
        observersList.remove(observer)
    }

    fun notifyObservers(propName: String, oldValue: Any?, newValue: Any?) {
        for (observer in observersList) {
            observer.onChange(propName, oldValue, newValue)
        }
    }
}

class ObservableProperty(
    val propName: String,
    var propValue: Int,
    val observable: Observable
) {
    fun getValue(): Int = propValue
    fun setValue(newValue: Int) {
        val oldValue = propValue
        propValue = newValue
        observable.notifyObservers(propName, oldValue, newValue)
    }
}

class Person(val name: String, age: Int, salary: Int) : Observable() {
    val _age = ObservableProperty(name, age, this)
    var age: Int
        get() = _age.getValue()
        set(newValue) = _age.setValue(newValue)

    val _salary = ObservableProperty(name, salary, this)
    var salary: Int
        get() = _salary.getValue()
        set(newValue) = _salary.setValue(newValue)
}

fun main() {
    val p = Person("Alice", 29, 2000)

    val observer = Observer { propName, oldValue, newValue ->
        println(
            """
            Property $propName changed from $oldValue to $newValue!
            """.trimIndent()
        )
    }

    p.addObserver(observer)

    p.age = 31 // Property Age changed from 29 to 31!
    p.salary = 2500 // Property Salary changed from 2000 to 2500!
    p.removeObserver(observer)
    p.age = 34
}
```

Artık Kotlin’de delegated property’lerin nasıl çalıştığını anlamaya yaklaştınız. Property’nin değerini saklayan ve
değiştirildiğinde otomatik olarak observer’ları bilgilendiren bir class oluşturdunuz. Logic’teki duplication’ı
kaldırdınız, ancak her property için ObservableProperty instance’ını oluşturmak ve getter ile setter’ı buna delegate
etmek için oldukça fazla boilerplate gerekirdi. Kotlin’in delegated property özelliği, bu boilerplate’ten kurtulmanızı
sağlar. Ancak bunu yapmadan önce, ObservableProperty method’larının signature’larını Kotlin convention’larının
gerektirdiği şekilde değiştirmeniz gerekir.

```kotlin
class ObservableProperty(var propValue: Int, val observable: Observable) {
    operator fun getValue(thisRef: Any?, prop: KProperty<*>): Int = propValue

    operator fun setValue(thisRef: Any?, prop: KProperty<*>, newValue: Int) {
        val oldValue = propValue
        propValue = newValue
        observable.notifyObservers(prop.name, oldValue, newValue)
    }
}
```

Önceki versiyonla karşılaştırıldığında, bu code’da şu değişiklikler vardır:

* getValue ve setValue function’ları artık operator olarak işaretlenmiştir; bu, convention aracılığıyla kullanılan tüm
  function’lar için gereklidir.

* Bu function’lara iki parametre eklediniz: biri property’nin get veya set edildiği instance’ı almak için (thisRef),
  diğeri ise property’nin kendisini temsil etmek için (prop). Property, KProperty type’ında bir object olarak temsil
  edilir. Bunu chapter 12’de daha detaylı inceleyeceğiz; şimdilik bilmeniz gereken, property’nin ismine KProperty.name
  ile erişebileceğinizdir.

* Primary constructor’dan name property’sini kaldırıyorsunuz çünkü artık property ismine KProperty aracılığıyla
  erişebilirsiniz.

Artık Kotlin’in delegated property’lerinin sihrini kullanabilirsiniz. Code’un ne kadar kısaldığına bakın.

```kotlin
fun interface Observer {
    fun onChange(propName: String, oldValue: Any?, newValue: Any?)
}

open class Observable {
    val observersList = mutableListOf<Observer>()

    fun addObserver(observer: Observer) {
        observersList.add(observer)
    }

    fun removeObserver(observer: Observer) {
        observersList.remove(observer)
    }

    fun notifyObservers(propName: String, oldValue: Any?, newValue: Any?) {
        for (observer in observersList) {
            observer.onChange(propName, oldValue, newValue)
        }
    }
}

class ObservableProperty(var propValue: Int, val observable: Observable) {
    operator fun getValue(thisRef: Any?, prop: KProperty<*>): Int = propValue
    operator fun setValue(thisRef: Any?, prop: KProperty<*>, newValue: Int) {
        val oldValue = propValue
        propValue = newValue
        observable.notifyObservers(prop.name, oldValue, newValue)
    }
}

class Person(val name: String, age: Int, salary: Int) : Observable() {
    var age by ObservableProperty(age, this)
    var salary by ObservableProperty(salary, this)
}

fun main() {
    val p = Person("Alice", 29, 2000)

    val observer = Observer { propName, oldValue, newValue ->
        println(
            """
            Property $propName changed from $oldValue to $newValue!
            """.trimIndent()
        )
    }

    p.addObserver(observer)

    p.age = 31 // Property Age changed from 29 to 31!
    p.salary = 2500 // Property Salary changed from 2000 to 2500!
    p.removeObserver(observer)
    p.age = 34
}
```

By keyword ile, Kotlin compiler, önceki code versiyonunda manuel olarak yaptığınızı otomatik olarak yapar. Bu code’u
Person class’ın önceki versiyonu ile karşılaştırın: delegated property kullandığınızda generate edilen code çok
benzerdir. By’in sağındaki object’e delegate denir. Kotlin, delegate’i gizli bir property’de otomatik olarak saklar ve
main property’ye eriştiğiniz veya onu değiştirdiğinizde delegate üzerinde getValue ve setValue çağırır.

Observable property logic’ini elle implement etmek yerine, Kotlin standard library’yi kullanabilirsiniz. Görünüşe göre
standard library zaten kendi ObservableProperty class’ını içeriyor. Ancak, standard library class’ı daha önce
tanımladığınız Observable interface hakkında hiçbir şey bilmiyor, bu yüzden property value’daki değişiklikleri nasıl
bildireceğini belirten bir lambda geçmeniz gerekiyor. Aşağıdaki code bunu nasıl yapabileceğinizi gösterir.

```kotlin
fun interface Observer {
    fun onChange(propName: String, oldValue: Any?, newValue: Any?)
}

open class Observable {
    val observersList = mutableListOf<Observer>()

    fun addObserver(observer: Observer) {
        observersList.add(observer)
    }

    fun removeObserver(observer: Observer) {
        observersList.remove(observer)
    }

    fun notifyObservers(propName: String, oldValue: Any?, newValue: Any?) {
        for (observer in observersList) {
            observer.onChange(propName, oldValue, newValue)
        }
    }
}

class Person(val name: String, age: Int, salary: Int) : Observable() {
    private val onChange = { property: KProperty<*>, oldValue: Any?, newValue: Any? ->
        notifyObservers(property.name, oldValue, newValue)
    }
    var age by Delegates.observable(age, onChange)
    var salary by Delegates.observable(salary, onChange)
}

fun main() {
    val p = Person("Alice", 29, 2000)

    val observer = Observer { propName, oldValue, newValue ->
        println(
            """
            Property $propName changed from $oldValue to $newValue!
            """.trimIndent()
        )
    }

    p.addObserver(observer)

    p.age = 31 // Property Age changed from 29 to 31!
    p.salary = 2500 // Property Salary changed from 2000 to 2500!
    p.removeObserver(observer)
    p.age = 34
}
```

By’in sağındaki expression, mutlaka yeni bir instance creation olmak zorunda değildir. Bu, bir function call, başka bir
property veya başka herhangi bir expression da olabilir; yeter ki bu expression’ın değeri, compiler’ın doğru parameter
type’ları ile getValue ve setValue çağırabileceği bir object olsun. Diğer convention’larda olduğu gibi, getValue ve
setValue, ya object’in kendisinde declare edilmiş method’lar ya da extension function’lar olabilir.

Örnekleri basit tutmak için, yalnızca Int type’ındaki delegated property’lerle nasıl çalışılacağını gösterdik. Delegated
property mekanizması tamamen generic’tir ve diğer tüm type’larla da çalışır.

Examples;

```kotlin
class MySelf {
    var name: String by Delegates.observable("Default") { property, oldValue, newValue ->
        println("${property.name} $oldValue -> $newValue")
    }

}

fun main() {
    val ms = MySelf()
    println(ms.name) // Default
    ms.name = "Alice" // name Default -> Alice
}
```

property parametresi, Kotlin'in reflection özelliğini temsil eden bir KProperty<*> object'idir. Kısacası; o an hangi
değişkenin (property) değeri değişiyorsa, o değişken hakkındaki metadata bilgilerini (adı, tipi vb.) tutan bir "kimlik
kartı" gibidir. Bu nesne sayesinde sadece ismi değil, başka teknik bilgilere de ulaşabilirsin (ancak çoğu zaman sadece
name yeterli olur):

* prop.name: Değişkenin adı (örn: "name", "salary").

* prop.returnType: Değişkenin tipi (örn: kotlin.String).

* prop.visibility: Değişkenin erişim seviyesi (public, private vb.).

### Vetoable

Kullanıcı(lar) tarafından girilen argument belirtilen condition’ı karşıladığında value’ların modify edilmesine izin
verir; kullanıcı assignment’ı intercept etmek istiyorsa observable properties yerine kullanılabilir. Vetoable, condition
karşılandığında value’ların modify edilmesine ve notify edilmesine izin veren ek özelliklerle Observable Properties
gibidir.

```kotlin
var max: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
    newValue > oldValue
}

fun main() {
    println(max) // 0
    max = 5
    println(max) // 5
    max = 10
    println(max) // 10
    max = 9
    println(max) // 10
}
```