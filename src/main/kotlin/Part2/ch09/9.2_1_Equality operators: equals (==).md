# Equality operators: equals (==)

Eşitlik konusuna 4. bölümde değinmiştik. Kotlin’de == operator’ünü kullanmanın, equals method’unu call etmeye translate
edildiğini gördünüz. Bu, tartıştığımız conventions ilkesinin bir başka uygulamasıdır.

!= operator’ünün kullanımı da equals çağrısına translate edilir; fark, sonucun terslenmiş olmasıdır. Diğer tüm
operator’lerin aksine, == ve != nullable operand’larla kullanılabilir; çünkü bu operator’ler arka planda null ile
eşitliği kontrol eder. a == b karşılaştırması, a’nın null olup olmadığını kontrol eder; null değilse a.equals(b) call
edilir:

== equality check, equals call ve bir null check’e dönüştürülür:

![img_6.png](assets/img_6.png)

Aksi takdirde, sonuç yalnızca her iki argument de null referans ise true olur.

Point class’ı için equals implementasyonu, class’ı data class olarak işaretlediğiniz için compiler tarafından otomatik
olarak generate edilir. Ancak bunu manuel olarak implement etseydiniz, code aşağıdaki gibi olabilirdi (tam bir
implementasyon ayrıca hashCode implementasyonu da sağlamalıdır; burada kısalık için bunu çıkardık).

```kotlin
class Point(val x: Int, val y: Int) {
    override fun equals(other: Any?): Boolean {
        if (other === this) return true
        if (other !is Point) return false
        return other.x == x && other.y == y
    }
}

fun main() {
    println(Point(10, 20) == Point(10, 20)) // true
    println(Point(10, 20) != Point(5, 5)) // true
    println(null == Point(1, 2)) // false
}
```

equals operator’ünün parametresinin, equals’ün çağrıldığı object ile aynı object olup olmadığını kontrol etmek için
identity equals operator’ü (===) kullanılır. Identity equals operator, Java’daki == operator’ü ile tamamen aynı şeyi
yapar: her iki argument’in aynı object’i refer edip etmediğini (ya da primitive type’ları varsa aynı değere sahip olup
olmadığını) kontrol eder. Bu operator’ü kullanmak, equals implementasyonu sırasında yaygın bir optimizasyondur.
=== operator’ü overload edilemez.

equals function’ı override olarak işaretlenir çünkü diğer convention’ların aksine, bunu implement eden method Any
class’ında tanımlıdır (eşitlik karşılaştırması Kotlin’de tüm object’ler için desteklenir). Bu aynı zamanda, onu operator
olarak işaretlemenize gerek olmamasını da açıklar: Any’deki base method zaten operator olarak işaretlidir ve bir method
üzerindeki operator modifier, onu implement eden veya override eden tüm method’lar için de geçerlidir. Ayrıca, equals
extension olarak implement edilemez; çünkü Any class’ından miras alınan implementasyon her zaman extension’ın önüne
geçer.

Yukarıda ki kod, != operator’ünün de equals method’unun çağrısına translate edildiğini gösterir. Compiler dönüş değerini
otomatik olarak tersler, bu nedenle bunun doğru çalışması için herhangi bir şey yapmanız gerekmez. Peki ya diğer
karşılaştırma operator’leri?