# How a real-life framework might use delegated properties

Bir object’in property’lerinin nasıl saklandığını ve nasıl modify edildiğini değiştirmek, framework developer’ları için
son derece faydalıdır. Bu bölüm, delegated property’lerin framework development ve kullanımını nasıl iyileştirdiğine
dair bir example case gösterir ve nasıl çalıştıklarının detaylarına iner.

Database'in Users adlı, string type’ında name ve integer type’ında age olmak üzere iki column içeren bir table
barındırdığını varsayalım. Kotlin’de Users ve User class’larını tanımlayabilirsin. Ardından, veritabanında saklanan tüm
user entity’leri, User class’ının instance’ları aracılığıyla Kotlin code’u içinde load edilebilir ve değiştirilebilir.

```kotlin
// object, veritabanındaki bir table’a karşılık gelir.
object Users : IdTable() {
    // Properties, bu table’daki column’lara karşılık gelir.
    val name = varchar("name", lenght = 50).index()
    val age = integer("age")
}

// User’ın her instance’ı, table’daki belirli bir entity’ye karşılık gelir.
class User(id: EntityID) : Entity(id) {
    // name’in value’su, o user için veritabanında saklanan value’dur.
    var name: String by Users.name
    var age: Int by Users.age
}
```

Users object’i bir veritabanı table’ını tanımlar; table’ı bir bütün olarak tanımladığı için object olarak declared
edilmiştir, bu nedenle yalnızca bir instance’ına ihtiyaç vardır. object’in Properties’leri, table’ın column’larını
represent eder.

User’ın superclass’ı olan Entity class’ı, entity için veritabanı column’larının value’larına mapping’ini içerir. Belirli
bir User için Properties’ler, bu user için veritabanında belirtilmiş name ve age value’larına sahiptir.

Framework’ü kullanmak özellikle kullanışlıdır; çünkü property’e erişmek, Entity class’ındaki mapping’den ilgili value’yu
automatically retrieve eder ve onu modify etmek object’i dirty olarak işaretler; böylece gerektiğinde veritabanına save
edilebilir. Kotlin code’u içinde user.age += 1 yazabilirsin ve veritabanındaki ilgili entity otomatik olarak updated
edilir.

Artık, bu tür bir API’ye sahip bir framework’ün nasıl implemented edilebileceğini anlayacak kadar bilgiye sahipsin.
Entity attribute’larının her biri (name, age), delegate olarak column object’ini (Users.name, Users.age) kullanarak
delegated property olarak implemented edilir:

```kotlin
class User(id: EntityID) : Entity(id) {
    // Users.name, name property’si için bir delegate’tir.
    var name: String by Users.name
    var age: Int by Users.age
}
```

Column’ların explicitly specified type’larına bakalım:

```kotlin
object Users : IdTable() {
    val name: Column<String> = varchar("name", 50).index()
    val age: Column<Int> = integer("age")
}
```

Column class’ı için framework, delegate’ler için Kotlin convention’ını karşılayan getValue ve setValue method’larını
define eder:

```kotlin
operator fun <T> Column<T>.getValue(o: Entity, desc: KProperty<*>): T {
    // retrieve the value from the database
}
operator fun <T> Column<T>.setValue(o: Entity, desc: KProperty<*>, value: T) {
    // update the value in the database
}
```

Column property’sini (Users.name), delegated property (name) için bir delegate olarak kullanabilirsin. Code’unda
`user.age += 1` yazdığında, code `user.ageDelegate.setValue(user.ageDelegate.getValue() + 1)` benzeri bir işlem
gerçekleştirir (property ve object instance’ları için olan parameter’lar atlanarak). getValue ve setValue method’ları,
veritabanındaki bilginin retrieve edilmesini ve update edilmesini üstlenir.