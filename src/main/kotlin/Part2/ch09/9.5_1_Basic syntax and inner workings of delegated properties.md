# Basic syntax and inner workings of delegated properties

Bir delegated property’nin genel syntax’ı şu şekildedir:

```kotlin
var p: Type by Delegate()
```

Property p, accessor’larının logic’ini başka bir object’e delegate eder: bu durumda, Delegate class’ının yeni bir
instance’ına. Object, by keyword’ünden sonra gelen expression’ı evaluate ederek elde edilir; bu expression, property
delegate’ler için convention kurallarını karşılayan herhangi bir şey olabilir. Delegated property declare eden bir class
için alt yapıda neler olduğuna bakalım, örneğin:

```kotlin
class Foo {
    var p: Type by Delegate
}
```

Compiler, initial property p’nin delegate ettiği delegate object’in instance’ı ile initialize edilen gizli bir helper
property oluşturur. Basitlik olması açısından buna delegate diyelim:

```kotlin
class Foo {
    // Bu helper property, compiler tarafından generate edilir.
    private val delegate = Delegate()

    // p property’sinin generate edilmiş accessor’ları, delegate üzerinde getValue ve setValue method’larını çağırır.
    var p: Type
        set(value: Type) = delegate.setValue(/* ... */, value)
        get() = delegate.getValue(/* ... */)
}
```

Convention’a göre, Delegate class’ı getValue ve setValue operator function’larına sahip olmalıdır; ancak setValue
yalnızca mutable property’ler için gereklidir (yani var delegate = … declare ederken). Ayrıca, provideDelegate
function’ı için de bir implementasyon sağlayabilirler (zorunlu değil), bu function’da validation logic
gerçekleştirebilir veya delegate ilk oluşturulduğunda instantiate edilme şeklini değiştirebilirsiniz. Her zamanki gibi,
bunlar member veya extension olarak implement edilebilir. Açıklamayı basitleştirmek için, parametrelerini atlıyoruz;
exact signature’lar bu chapter’da daha sonra ele alınacaktır. Basit bir formda, Delegate class şu şekilde görünebilir:

```kotlin
class Delegate {
    // getValue method’u, bir getter implement etmek için gerekli logic’i içerir.
    operator fun getValue(/* ... */) { /* ... */
    }

    // setValue method’u, bir setter implement etmek için gerekli logic’i içerir.
    operator fun setValue(/* ... , value: Type */) { /* ... */
    }

    // provideDelegate method’u, bir delegate sağlamak veya construct etmek için gerekli logic’i içerir.
    operator fun provideDelegate(/* ... */): Delegate { /* ... */
    }
}

class Foo {
    /* by keyword, bir property’yi bir delegate object ile ilişkilendirir (bu örnekte, Delegate class’ının yeni bir 
    instance’ı). */
    var p: Type by Delegate()
}

fun main() {
    // Delegated property’ye sahip bir type oluşturulduğunda, mevcutsa delegate.provideDelegate() çağrılır.
    val foo = Foo()
    // foo.p property’sine erişmek, alt yapıda delegate.getValue(…) çağrısını tetikler.
    val oldValue = foo.p
    // Bir property’nin value’sunu değiştirmek, delegate.setValue(…, newValue) çağrısını tetikler.
    foo.p = newValue
}
```

foo.p’yi normal bir property gibi kullanırsınız, ancak alt yapıda Delegate type’ın helper property’si üzerindeki
method’lar çağrılır. Bu mekanizmanın pratikte nasıl kullanıldığını incelemek için, önce delegated property’lerin gücüne
dair bir örneğe bakacağız: lazy initialization için library desteği. Ardından, kendi delegated property’lerinizi nasıl
define edebileceğinizi ve bunun ne zaman faydalı olduğunu keşfedeceğiz.