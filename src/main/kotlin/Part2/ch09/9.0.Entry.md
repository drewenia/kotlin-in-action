# Entry

Kotlin’de, belirli language construct’larının kendi code’unuzda define ettiğiniz function’ları call ederek implement
edildiği bir dizi özellik vardır. Java’dan bu tür construct’lara zaten aşina olabilirsiniz; java.lang.Iterable
interface’ini implement eden object’ler for loop’larda kullanılabilir ve java.lang.AutoCloseable interface’ini implement
eden object’ler try-with-resources statement’larında kullanılabilir.

Kotlin’de bu tür özellikler, belirli isimlere sahip function’lara bağlıdır (Java’daki gibi standart kütüphanedeki özel
interface’lere bound değildir). Örneğin, class’ınız plus adlı özel bir method define ediyorsa, convention gereği bu
class’ın instance’ları üzerinde + operator’ünü kullanabilirsiniz. Bu nedenle Kotlin’de bu tekniğe conventions olarak
atıfta bulunuruz. Bu bölümde, Kotlin tarafından desteklenen farklı conventions’lara ve bunların nasıl
kullanılabileceğine bakacağız.

Kotlin, Java’nın yaptığı gibi type’lara dayanmak yerine conventions ilkesini kullanır; çünkü bu, developer’ların mevcut
Java class’larını Kotlin language özelliklerinin gereksinimlerine uyarlamasına olanak tanır. Kotlin code’u third-party
class’ları değiştirerek onların ek interface’ler implement etmesini sağlayamaz. Öte yandan, extension function
mekanizması aracılığıyla bir class için yeni method’lar define etmek mümkündür. Herhangi bir convention method’unu
extension olarak define edebilir ve böylece herhangi bir mevcut Java class’ını code’unu değiştirmeden
uyarlayabilirsiniz.

Bu bölüm boyunca süregelen bir örnek olarak, ekranda bir noktayı represent eden basit bir Point class’ını kullanacağız.
Bu tür class’lar çoğu UI framework’te mevcuttur ve burada gösterilen tanımları kendi environment’ınıza kolayca
uyarlayabilirsiniz:

```kotlin
data class Point(val x: Int, val y: Int)
```

Point class’ı üzerinde bazı aritmetik operator’leri define ederek başlayalım.