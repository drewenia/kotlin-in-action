# Destructuring declarations and loops

Destructuring declarations, sadece function’larda top-level statement olarak değil, variable declare edebileceğiniz
diğer yerlerde de çalışır—örneğin, loop’larda. Bunun için iyi bir kullanım, bir map’in entry’lerini enumerate etmektir.
İşte bu syntax’ı kullanarak verilen bir map’in tüm entry’lerini yazdıran küçük bir örnek.

```kotlin
fun printEntries(map: Map<String, String>) {
    // Loop içinde destructuring declaration
    for ((key, value) in map) {
        println("$key -> $value")
    }
}

fun main() {
    val map = mapOf("Oracle" to "Java", "Jetbrains" to "Kotlin")
    printEntries(map)
    // Oracle -> Java
    // Jetbrains -> Kotlin
}
```

Bu basit örnek, iki Kotlin convention kullanır: biri bir object üzerinde iterate etmek için, diğeri ise destructure
declarations için. Kotlin standard library, Map üzerinde map entry’leri üzerinde bir iterator return eden iterator adlı
bir extension function içerir. Böylece, Java’nın aksine, bir map üzerinde doğrudan iterate edebilirsiniz. Ayrıca
Map.Entry üzerinde sırasıyla key ve value’yu return eden component1 ve component2 extension function’ları içerir.
Aslında, önceki loop, aşağıdaki code ile eşdeğer şekilde translate edilir:

```kotlin
for (entry in map.entries) {
    val key = entry.component1()
    val value = entry.component2()
    // ...
}
```

Bir lambda, bir data class veya bir map gibi composite value aldığında da destructuring declarations kullanabilirsiniz.
Bu örnekte, bir kez daha verilen bir map’in tüm entry’lerini yazdırıyorsunuz, ancak bu sefer Chapter 5’te tanıştığınız
.forEach function’ını kullanıyorsunuz:

```kotlin
fun main() {
    val map = mapOf("Oracle" to "Java", "Jetbrains" to "Kotlin")

    map.forEach { (key, value) ->
        println("Key -> $key, Value -> $value")
        // Key -> Oracle, Value -> Java
        // Key -> Jetbrains, Value -> Kotlin
    }
}
```

Bu örnekler, Kotlin’in conventions’ını desteklemek için extension function’ların önemini bir kez daha gösterir.