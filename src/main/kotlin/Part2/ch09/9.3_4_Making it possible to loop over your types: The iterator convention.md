# Making it possible to loop over your types: The iterator convention

2.4 bölümünde tartıştığımız gibi, Kotlin’deki for loop’lar, range kontrollerinde kullanılan aynı `in` operator’ünü
kullanır. Ancak bu context'de anlamı farklıdır: iteration yapmak için kullanılır. Bu, `for (x in list) { … }` gibi bir
statement’ın list.iterator() çağrısına translate edileceği ve ardından hasNext ve next method’larının Java’daki gibi
tekrar tekrar çağrılacağı anlamına gelir.

Kotlin’de bunun da bir convention olduğunu unutmayın; bu, iterator method’unun extension olarak define edilebileceği
anlamına gelir. Bu, normal bir string üzerinde iterate etmenin mümkün olmasını açıklar: Kotlin standart kütüphanesi,
String’in üst class’ı olan CharSequence üzerinde bir extension function olarak iterator define etmiştir:

```kotlin
// Bu kütüphane function’ü, bir string üzerinde iterate etmeyi mümkün kılar.
operator fun CharSequence.iterator(): CharIterator
```

```kotlin
fun main() {
    for (letter in "abc") {
        //...
    }
}
```

Kendi class’larınızda iterator function’ını bir method olarak veya kullandığınız üçüncü taraf class’lar için bir
extension function olarak define edebilirsiniz. Aşağıdaki örnekte olduğu gibi, LocalDate object’leri üzerinde iterate
etmeyi mümkün kılan bir extension function define edebilirsiniz. iterator function’ı, Iterator<LocalDate> interface’ini
implement eden bir object döndürmelidir; bu nedenle interface’in beklediği hasNext ve next function’larının
implementasyonlarını belirtmek için bir object declaration kullanırsınız.

```kotlin
operator fun ClosedRange<LocalDate>.iterator(): Iterator<LocalDate> =
    // Bu object, LocalDate element’leri üzerinde bir Iterator implement eder.
    object : Iterator<LocalDate> {
        var current = start

        override fun next(): LocalDate {
            val thisDate = current
            // Mevcut tarihi bir gün artırır.
            current = current.plusDays(1)
            // Pre increment edilmiş tarihi döndürür.
            return thisDate
        }

        // Tarihler için kullanılan compareTo convention’ına dikkat edin (current <= endInclusive)
        override fun hasNext(): Boolean = current <= endInclusive
    }

fun main() {
    val newYear = LocalDate.ofYearDay(2042, 1)
    val daysOff = newYear.minusDays(1)..newYear

    // İlgili iterator function mevcut olduğunda daysOff üzerinde iterate eder.
    for (dayOff in daysOff) {
        println(dayOff)
        // 2041-12-31
        // 2042-01-01
    }
}
```

Başka bir implementation;

```kotlin
operator fun ClosedRange<LocalDate>.iterator(): Iterator<LocalDate> =
    // Bu object, LocalDate element’leri üzerinde bir Iterator implement eder.
    object : Iterator<LocalDate> {
        // start -> The minimum value in the range.
        var current = start
        override fun next(): LocalDate {
            val thisDate = current

            // Mevcut tarihi bir yıl artırır.
            current = current.plusYears(1)

            // Pre increment edilmiş tarihi döndürür.
            return thisDate
        }

        // Tarihler için kullanılan compareTo convention’ına dikkat edin (current <= endInclusive)
        // endInclusive -> The maximum value in the range (inclusive)
        override fun hasNext(): Boolean = current <= endInclusive

    }

fun main() {
    val birthDay = LocalDate.of(1976, 11, 29)
    val today = LocalDate.now()

    // birthDay'den 1 gün çıkart -> range today'e kadar
    val monthsOff = birthDay.minusDays(1)..today

    for (month in monthsOff){
        println(month)
        // 1976-11-28
        // 1977-11-28
        // 1978-11-28
        // 1979-11-28
        // 1980-11-28
        // ...
    }
}
```

Custom bir range type üzerinde iterator method’unu nasıl define ettiğinize dikkat edin: LocalDate’i type argument olarak
kullanıyorsunuz. Önceki bölümde gösterilen rangeTo library function, ClosedRange’in bir instance’ını döndürür ve
ClosedRange<LocalDate> üzerindeki iterator extension, range’in bir instance’ını for loop içinde kullanmanıza izin verir.