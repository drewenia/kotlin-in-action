# Ignoring destructured values using the _ character

Bir object’i birçok component ile destructure ederken, aslında hepsine ihtiyaç duymama olasılığınız vardır. Bu örnekte,
bir Person class’ını destructure ediyorsunuz, ancak gerçekten sadece firstName ve age field’larını kullanıyorsunuz.

```kotlin
data class Person(
    val firstName: String,
    val lastName: String,
    val age: Int,
    val city: String
)

fun introducePerson(p: Person) {
    val (firstName, lastName, age, city) = p
    println("This is $firstName, aged $age.")
}
```

Bu case'de, local lastName ve city variable’larını declare etmek kodumuz için herhangi bir değer sağlamaz. Bunun yerine,
function body’sini kullanılmayan variable’larla karıştırır — bu genellikle kaçınılması gereken bir durumdur. Tüm
object’i destructure etmeye zorlanmadığımız için, trailing destructuring declarations’ı (bu durumda city) destructuring
declaration’dan çıkarabiliriz. Bunun yerine, yalnızca ilk üç element’i destructure edersiniz:

```kotlin
data class Person(
    val firstName: String,
    val lastName: String,
    val age: Int,
    val city: String
)

fun introducePerson(p: Person) {
    val (firstName, lastName, age) = p
    println("This is $firstName, aged $age.")
}
```

lastName declaration’dan kurtulmak için, biraz farklı bir yol izlemeniz gerekir. Sadece bunu kaldırırsak (elimizde
sadece (firstName, age) kalırsa), Person.lastName’in içeriğini yanlışlıkla age variable’ına assign etmiş oluruz (
unutmayın ki alt yapıda, bu destructuring declaration yalnızca component1 ve component2 function’larını çağırır, onlara
verdiğiniz isim ne olursa olsun).

Bu case ile başa çıkmak için, Kotlin destructuring sırasında kullanılmayan declaration’ları reserved karakter olan `_`
assign etmenize izin verir. Bu bilgiyle donanmış olarak, introduce - Person implementation’ını daha concise hale
getirebilirsiniz — lastName’i `_` olarak yeniden adlandırarak ve destructuring sırasında city’i tamamen çıkararak:

```kotlin
data class Person(
    val firstName: String,
    val lastName: String,
    val age: Int,
    val city: String
)

fun introducePerson(p: Person) {
    // Destructuring sırasında bir component’i yok saymak için, onu `_`’ye assign edin.
    val (firstName, _, age) = p
    println("This is $firstName, aged $age.")
}
```

### Limitations and drawbacks of destructuring in Kotlin (Kotlin’de destructuring’in sınırlamaları ve dezavantajları)

Kotlin’in destructuring declarations implementasyonu positional’dir, yani bir destructuring operation’ın sonucu tamamen
argument’lerin konumlarına bağlıdır. Yukarıda ki Person data class için bu, destructuring sırasında variable’ların
her zaman constructor’da göründükleri sırayla değerlerle assign edileceği anlamına gelir:

```kotlin
val (firstName, lastName, age, city) = p
```

Destructuring’in sonucunun assign edildiği variable’ların isimleri önemli değildir—çünkü destructuring declarations,
componentN function’ları birer birer iterate eder, bu nedenle bu code da aynı şekilde çalışır:

```kotlin
val (f, l, a, c) = p
```

Bu, bir data class’ta property’lerin sırasını refactoring sırasında değiştirirseniz, ince sorunlara yol açabilir:

```kotlin
data class Person(
    val lastName: String,
    val firstName: String,
    val age: Int,
    val city: String,
)
```

Artık önceki code snippet hâlâ çalışır, ancak lastName’in değerini yanlışlıkla firstName’e, firstName’in değerini ise
lastName’e assign eder:

```kotlin
val (firstName, lastName, age, city) = p
```

Bu behavior, destructuring declarations’ın en iyi şekilde yalnızca küçük container class’ları (örneğin key–value
pair’ler veya index–value pair’ler) veya gelecekte değişmesi çok olası olmayan class’lar için kullanılabileceği anlamına
gelir. Daha karmaşık entity’ler için kaçınılmalıdır.