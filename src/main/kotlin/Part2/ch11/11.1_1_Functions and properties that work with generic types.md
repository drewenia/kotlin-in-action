# Functions and properties that work with generic types

Herhangi bir list ile (generic olanla) çalışmasını istediğin, belirli bir type’taki element’lerden oluşan bir list’e
özel olmayan bir fonksiyon yazacaksan, generic bir fonksiyon yazman gerekir. Generic bir fonksiyon, kendine ait type
parameter’lara sahiptir. Bu type parameter’lar, her function invocation’ında belirli type argument’larla
değiştirilmelidir.

Collection’larla çalışan library fonksiyonlarının çoğu generic’tir. Örneğin, aşağıda gösterilen slice fonksiyon
declaration’ına bakalım. Bu fonksiyon, belirtilen range içindeki indices’lerde bulunan element’leri içeren bir list
return eder:

Generic slice fonksiyonu, arbitrary element’lerden oluşan list’lerle çalışmasına olanak tanıyan T type parameter’ına
sahiptir. Bu type parameter, hem extension fonksiyonun receiver type’ında hem de fonksiyonun return type’ında
kullanılır.

![img_1.png](img_1.png)

Fonksiyonun T type parameter’ı receiver type’ta ve return type’ta kullanılır; her ikisi de List<T>’dir. Böyle bir
fonksiyonu belirli bir list üzerinde call ettiğinde, type argument’ı explicitly belirtebilirsin. Ancak neredeyse tüm
case’lerde buna gerek yoktur; çünkü Compiler bunu infer eder, aşağıda gösterildiği gibi.

```kotlin
fun main() {
    val letters = ('a'..'z').toList()

    val sliced = letters.slice<Char>(0..2)
    println(sliced) // [a, b, c]

    val sliced2 = letters.slice(10..13)
    println(sliced2) // [k, l, m, n]
}
```

Bu call’ların her ikisinin de result type’ı List<Char>’dir. Compiler, fonksiyonun return type’ı olan List<T> içinde
inferred edilen Char type’ını T yerine substitute eder.

Section 10.1.1’de, (T) -> Boolean function type’ında bir parameter alan filter fonksiyonunun declaration’ını gördün. Şu
signature’a sahipti:

```kotlin
fun <T> List<T>.filter(predicate: (T) -> Boolean): List<T>
```

Önceki example’lardaki readers ve authors variable’larına bunu nasıl uygulayabileceğine bakalım.

```kotlin
fun main() {
    val authors = listOf("Sveta", "Seb", "Roman", "Dima")
    val readers = mutableListOf<String>("Seb", "Hadi")
    val filtered = readers.filter { it !in authors }
    println(filtered) // [Hadi]
}
```

Bu case'de autogenerated lambda parameter’ın type’ı String’dir. Compiler bunu infer etmek zorundadır (ve edebilir):
sonuçta fonksiyonun declaration’ında lambda parameter generic bir type olan T’ye sahiptir ((T) -> Boolean içindeki
function parameter type’ı). Compiler, fonksiyonun List<T> üzerinde call edilmesi gerektiğini bildiği ve receiver’ın
actual type’ı olan readers’ın List<String> olduğunu gördüğü için T’nin String olduğunu anlar.

Class veya interfaces metodlarında, top-level fonksiyonlarda ve extension fonksiyonlarda type parameter’lar declare
edebilirsin. Son durumda, type parameter receiver ve parameter type’larında kullanılabilir; yukarıdaki code'lar da
olduğu gibi: `T type` parameter’ı receiver type olan `List<T>`’nin bir parçasıdır ve ayrıca parameter function type
olan `(T) -> Boolean` içinde de kullanılır.

Aynı syntax'ı kullanarak generic extension property’ler de declare edebilirsin. Örneğin, burada bir list içindeki sondan
bir önceki element’i—yani son element’ten önceki element’i—return eden bir extension property yer alır:

```kotlin
// Bu generic extension property, herhangi bir türdeki bir list üzerinde call edilebilir.
val <T> List<T>.penultimate: T
get() = this[size - 2]

fun main() {
    // Bu invocation’da T type parameter’ı Int olarak infer edilir.
    println(listOf(1, 2, 3, 4).penultimate) // 3
}
```

### Generic olan non-extension bir property declare edemezsin.

Regular (non-extension) property’ler type parameter’a sahip olamaz. Bir class’ın bir property’sinde farklı type’larda
birden fazla value saklamak mümkün değildir; bu nedenle generic bir non-extension property declare etmek anlamlı
değildir. Bunu yapmaya çalışırsan, Compiler bir error bildirir:

```kotlin
val <T> x: T = TODO()
// Error: type parameter of a property must be used in its receiver type
```