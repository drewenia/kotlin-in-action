# Variance determines whether it is safe to pass an argument to a function

Diyelim ki bir function argüman olarak List<Any> alıyor. List<String> tipinde bir variable’ı bu function’a geçirmek
güvenli midir? Bir function Any beklediğinde bir string geçirmek kesinlikle güvenlidir çünkü String class’ı Any’i extend
eder. Ancak Any ve String, List interface’inin type argument’ları haline geldiğinde durum artık o kadar açık değildir.

Örneğin, listenin içeriğini yazdıran bir function’ı ele alalım:

```kotlin
fun printContents(list: List<Any>) {
    println(list.joinToString())
}

fun main() {
    printContents(listOf("abc", "bac")) // abc, bac
}
```

Burada bir list of strings’in sorunsuz çalışıyor gibi göründüğünü söyleyebiliriz. Function her element’i Any olarak ele
alıyor ve her string’in Any olması nedeniyle bu tamamen güvenlidir.

Şimdi, listeyi değiştiren başka bir function’a bakalım (ve dolayısıyla MutableList’i parametre olarak alıyor):

```kotlin
fun addAnswer(list: MutableList<Any>) {
    list.add(42)
}

// Bu function’a bir list of strings geçirirseniz, kötü bir durum olabilir mi?

fun main() {
    val strings = mutableListOf("abc", "bac")
    addAnswer(strings) // Eğer bu satır compile olsaydı…
    println(strings.maxBy { it.length }) // … runtime sırasında bir exception alırdınız.
    // ClassCastException: Integer cannot be cast to String
}
```

MutableList<String> type’ında strings adlı bir variable declare ediyorsun. Ardından bunu function’a geçirmeye
çalışıyorsun. Compiler bunu kabul etseydi (ki etmez), bir list of strings’e bir integer ekleyebilirdin; bu da listenin
içeriğine string’ler olarak erişmeye çalıştığında runtime’da bir exception’a yol açardı. Bu nedenle bu çağrı compile
olmaz. Bu örnek, MutableList<Any> beklendiğinde MutableList<String>’i argument olarak geçirmenin güvenli olmadığını
gösterir; Kotlin compiler’ı bunu doğru şekilde yasaklar.

Artık, Any object’lerinden oluşan bir list bekleyen bir function’a bir list of strings geçirmenin güvenli olup olmadığı
sorusunu cevaplayabilirsin. Function, list’e element ekliyor veya element’leri değiştiriyorsa bu güvenli değildir; çünkü
bu durum type tutarsızlıkları olasılığı yaratır. Aksi halde güvenlidir (nedenini bu bölümün ilerleyen kısımlarında daha
detaylı tartışacağız). Kotlin’de bu durum, listenin mutable olup olmamasına bağlı olarak doğru interface’i seçerek
kolayca kontrol edilebilir. Bir function read-only bir list kabul ediyorsa, daha spesifik bir element type’ına sahip bir
List geçirebilirsin. List mutable ise bunu yapamazsın.

Bu bölümün ilerleyen kısımlarında, aynı soruyu yalnızca List için değil, herhangi bir generic class için
genelleştireceğiz. Ayrıca, List ve MutableList interface’lerinin type argument açısından neden farklı olduğunu da
göreceksin. Ancak buna geçmeden önce, type ve subtype kavramlarını tartışmamız gerekiyor.