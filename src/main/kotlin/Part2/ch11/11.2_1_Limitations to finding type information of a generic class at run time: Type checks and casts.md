# Limitations to finding type information of a generic class at run time: Type checks and casts

Kotlin’deki generics, runtime’da erased edilir. Bu, generic bir class’ın bir instance’ının, o instance’ı oluşturmak için
kullanılan type argument’lar hakkında bilgi taşımadığı anlamına gelir. Örneğin, bir List<String> oluşturup içine bir
sürü string koyarsan, runtime’da yalnızca bunun bir List olduğunu görebilirsin (bu etkiyi Java’da da görebilirsin).
Listenin hangi type’daki element’leri içermesi gerektiğini belirlemek mümkün değildir. (Elbette bir element alıp
type’ını kontrol edebilirsin, ama bu sana herhangi bir garanti vermez; çünkü diğer element’ler farklı type’larda
olabilir.)

Bu iki list ile kodu çalıştırdığında ne olduğunu düşün:

```kotlin
val list1: List<String> = listOf("a", "b")
val list2: List<Int> = listOf(1, 2, 3)
```

Compiler list’ler için iki farklı type görmesine rağmen, execution time’da bunlar tamamen aynı görünür:

Runtime’da, list1 ve list2’nin string veya integer list olarak declare edilip edilmediğini bilemezsin. Her biri sadece
List’tir. Bu durum, type argument’larla çalışırken ek kısıtlamalar getirir.

![img_3.png](assets/img_3.png)

Buna rağmen, normalde List<String> yalnızca string’ler ve List<Int> yalnızca integer’lar içerir, çünkü compiler
type argument’ları bilir ve her list’e yalnızca doğru type’daki element’lerin saklanmasını garanti eder. (Type cast’ler
veya Java raw type’ları kullanarak compiler’ı aldatabilirsin, ama bunu yapmak için özel bir çaba göstermen gerekir.)

Şimdi, type bilgisinin erase edilmesiyle birlikte gelen kısıtlamalardan bahsedelim. Type argument’lar saklanmadığı için
onları kontrol edemezsin—örneğin, bir listenin string list olup olmadığını diğer object’lerden ayıramazsın. Genel bir
kural olarak, type argument’lı type’ları is check’lerinde kullanmak mümkün değildir. Bu, parametresinin type
argument’ına göre farklı behavior sergilemesi gereken bir fonksiyon oluşturmak istediğinde bir engel olabilir.

Örneğin, kullanıcı girişine bağlı olarak ya bir List<String> ya da List<Int> return eden readNumbersOrWords adında bir
fonksiyonun olabilir. printList fonksiyonu içinde is check’leriyle number list ile word list’i ayırt etmeye çalışmak
compile olmaz:

```kotlin
fun readNumbersorWords(): List<Any> {
    val input = readln()
    val words: List<String> = input.split(",")
    val numbers: List<Int> = words.mapNotNull { it.toIntOrNull() }
    return numbers.ifEmpty { words }
}

fun printList(l: List<Any>) {
    when (l) {
        // ERROR: Erased type için instance kontrolü yapılamaz.
        is List<String> -> println("Strings: $l")
        // ERROR: Erased type için instance kontrolü yapılamaz.
        is List<Int> -> println("Integers: $l")
    }
}
```

Runtime’da value’nun bir List olduğunu bulmak tamamen mümkün olsa da, bunun string, person veya başka bir türde bir list
olup olmadığını söyleyemezsin: bu bilgi erased edilmiştir. Generic type bilgisinin erase edilmesinin bazı avantajları
vardır: uygulaman tarafından kullanılan toplam bellek miktarı daha azdır, çünkü daha az type bilgisi memory’de saklanmak
zorundadır.

Daha önce belirttiğimiz gibi, Kotlin type argument belirtmeden generic bir type kullanmana izin vermez. Bu nedenle, bir
value’nun list mi yoksa set ya da başka bir object mi olduğunu nasıl kontrol edeceğini merak edebilirsin. Bunu, özel
star-projection sözdizimini kullanarak yapabilirsin:

```kotlin
if (value is List<*>) { /* ... */
}
```

Aslında, type’ın sahip olduğu her type parameter için bir * koyman gerekir. Star projection’ı detaylı olarak (neden
projection olarak adlandırıldığı dahil) section 11.3.6’da ele alacağız; şimdilik, bunu unknown argument’lara sahip bir
type (veya Java’daki List<?>’nin bir karşılığı) olarak düşünebilirsin. Önceki example’da, bir value’nun List olup
olmadığını kontrol edersin ve element type’ı hakkında herhangi bir bilgi almazsın.

Normal generic type’ları as ve as? cast’lerinde hâlâ kullanabileceğini unutma. Ancak, cast yapılırken class doğru base
type’a sahip ve type argument yanlış olsa bile cast başarısız olmaz; çünkü type argument runtime’da bilinmez. Bu
nedenle, compiler bu tür bir cast için “unchecked cast” uyarısı verir. Bu sadece bir uyarıdır, dolayısıyla daha sonra
value’yu gerekli type’a sahipmiş gibi kullanabilirsin, aşağıda gösterildiği gibi.

```kotlin
fun printSum(c: Collection<*>) {
    // Buradaki uyarı: Unchecked cast: List<*> to List<Int>
    val intList = c as? List<Int>
        ?: throw IllegalArgumentException("List is expected")
    println(intList.sum())
}

fun main() {
    printSum(listOf(1, 2, 3, 4)) // 10

    // Set bir list olmadığı için, bir exception fırlatılır.
    printSum(setOf(1, 2, 3)) // IllegalArgumentException: List is expected
}
```

Her şey sorunsuz bir şekilde compile olur: compiler sadece bir uyarı verir, bu da kodun geçerli olduğu anlamına gelir.
printSum fonksiyonunu bir integer list veya set üzerinde çağırırsan, beklediğin şekilde çalışır—ilk durumda toplamı
yazdırır, ikinci durumda ise IllegalArgumentException fırlatır.

Ama yanlış type’da bir value geçirirsen, runtime’da ClassCastException alırsın:

```kotlin
fun printSum(c: Collection<*>) {
    // Buradaki uyarı: Unchecked cast: List<*> to List<Int>
    val intList = c as? List<Int>
        ?: throw IllegalArgumentException("List is expected")
    println(intList.sum())
}

fun main() {
    // Cast başarılı olur, ancak string’ler toplanamayacağı için daha sonra başka bir exception fırlatılır.
    printSum(listOf("a", "b", "c"))
    // ClassCastException: String cannot be cast to Number
}
```

printSum fonksiyonunu string’lerden oluşan bir list üzerinde call ettiğinde fırlatılan exception’ı ele alalım. Bir
IllegalArgumentException almazsın; çünkü argument’ın List<Int> olup olmadığını kontrol edemezsin. Bu nedenle cast
başarılı olur ve sum fonksiyonu yine de böyle bir list üzerinde call edilir. Execution sırasında bir exception
fırlatılır. Bunun nedeni, fonksiyonun list’ten Number value’ları almaya ve onları toplamaya çalışmasıdır. Bir String’i
Number olarak kullanma girişimi, runtime’da bir ClassCastException ile sonuçlanır.

Kotlin Compiler’ın, ilgili type bilgisinin compile time’da zaten bilindiği durumlarda `is` check’lerine izin verecek
kadar akıllı olduğunu unutma.

```kotlin
// Element type olan Int, compile time’da bilindiği için …
fun printSum(c: Collection<Int>) {
    when (c) {
        // bu check’ler geçerlidir.
        is List<Int> -> println("List sum : ${c.sum()}")
        is Set<Int> -> println("Set sum : ${c.sum()}")
    }
}
```

Yukarıda ki code da, c’nin List<Int> type’ında olup olmadığını kontrol etmek mümkündür; çünkü compile time’da bu
collection’ın (ister list ister başka bir collection türü olsun) integer number’lar içerdiğini bilirsin— `Collection<*>`
örneğinin aksine, orada type hakkında hiçbir bilgi mevcut değildi.

Genel olarak, Kotlin Compiler hangi check’lerin tehlikeli olduğunu (is check’lerini yasaklayarak ve as cast’leri için
warning vererek) ve hangilerinin mümkün olduğunu sana bildirir. Senin yapman gereken, bu warning’lerin anlamını bilmek
ve hangi operation’ların safe olduğunu anlamaktır.

Daha önce de belirttiğimiz gibi, Kotlin bir fonksiyonun body’si içinde belirli type argument’ları kullanmana olanak
tanıyan özel bir construct’a sahiptir; ancak bu yalnızca inline fonksiyonlar için mümkündür. Şimdi bu özelliğe bakalım.