# Avoiding java.lang.Class parameters by replacing class references with reified type parameters

reified type parameter’lar için yaygın bir use case, type’ı java.lang.Class olan parameter’lar alan API’ler için
adapter’lar oluşturmaktır. Böyle bir API’ye örnek olarak JDK’daki ServiceLoader verilebilir. Bu API, bir interface’i
veya abstract bir class’ı temsil eden bir java.lang.Class alır ve önceden sağlanmış bir configuration’a dayanarak, bu
interface’i implement eden bir service class’ın instance’ını döndürür. Bu tür API’leri call etmeyi nasıl daha basit hâle
getirebileceğini görmek için reified type parameter’ları nasıl kullanabileceğine bakalım.

Standard Java API’sini kullanarak ServiceLoader ile bir service load etmek için aşağıdaki call’u kullanırsın:

```kotlin
val serviceImpl = ServiceLoader.load(Service::class.java)
```

`::class.java` syntax’ı, bir Kotlin class’ına karşılık gelen bir java.lang.Class’ı nasıl elde edebileceğini gösterir.
Bu, Java’daki `Service.class` ile tamamen eşdeğerdir. Bunu, reflection tartışmamızda 12.2 bölümünde çok daha ayrıntılı
olarak ele alacağız.

Şimdi, bu örneği reified bir type parameter’a sahip bir function kullanarak yeniden yazalım; loadService function’ının
type argument’ı olarak load edilecek service’ın class’ını belirtelim:

```kotlin
val serviceImpl = loadService<Service>()
```

Daha kısa, değil mi? Bir class’ı type argument olarak belirtmek, aksi hâlde kullanman gereken `::class.java`
syntax’ından daha kısa olduğu için okumayı daha kolay hâle getirir. Şimdi, bu loadService function’ının nasıl define
edilebileceğine bakalım:

```kotlin
inline fun <reified T> loadService(): ServiceLoader<T> {
    // type parameter’ın class’ına T::class olarak erişir
    return ServiceLoader.load(T::class.java)
}
```

reified type parameter’lar üzerinde, regular class’larda kullanabildiğin aynı `::class.java` syntax’ını kullanabilirsin.
Bu syntax’ı kullanmak, type parameter olarak belirtilen class’a karşılık gelen java.lang.Class’ı elde etmeni sağlar ve
bunu daha sonra normal şekilde kullanabilirsin.

### Simplifying the startActivity function on Android

Eğer bir Android developer isen, başka bir örneği daha tanıdık bulabilirsin: activity’leri göstermek. Activity’nin
class’ını bir java.lang.Class olarak geçirmek yerine, reified bir type parameter da kullanabilirsin:

```kotlin
inline fun <reified T : Activity>
        Context.startActivity() {
    //type parameter’ın class’ına T::class olarak erişir
    val intent = Intent(this, T::class.java)
    startActivity(intent)
}

startActivity<DetailActivity>() // Activity’yi göstermek için method’u invoke eder
```

### Extra description

Bilgisayar, runtime'da generic tiplerin (<T>) ne olduğunu unutur. Buna "Type Erasure" denir. Diyelim ki bir fonksiyonun
var: `fun <T> checkType()`. Sen bu fonksiyonu `checkType<String>()` diye çağırdığında, Java/Kotlin arka planda o String
bilgisini siler. Bu yüzden fonksiyonun içinde "Ben şu an bir String ile çalışıyorum" diyemezsin. Bu yüzden Java'daki
ServiceLoader gibi araçlar, neyi yükleyeceklerini anlamak için senden "sınıfın kimlik kartını" (yani java.lang.Class
nesnesini) isterler.

```
// Burada hem <Service> yazıyoruz hem de parantez içine Service::class.java.
val serviceImpl = ServiceLoader.load(Service::class.java)
```

Kotlin diyor ki: "Eğer bir fonksiyonu inline yaparsan ve tipin başına reified yazarsan, ben o tipin ne olduğunu çalışma
anında bile hatırlarım."

Böylece `T::class.java` yazarak o sınıfın kimlik kartına ulaşabilirsin. Gel bu çirkin Java kodunu bir fonksiyonun içine
saklayalım ve kullanımı çok kolay hale getirelim:

```kotlin
// 1. 'inline' olmak zorunda
// 2. 'reified' sayesinde T artık bir "hayalet" değil, gerçek bir tip.
inline fun <reified T> loadService(): ServiceLoader<T> {
    // T::class.java artık hata vermez çünkü 'reified' tipi korudu.
    return ServiceLoader.load(T::class.java)
}
```

Artık kullanımı şöyle olur;

```kotlin
// Sadece <Service> yazman yeterli. 
// Arka plandaki o Service::class.java işini Kotlin senin için hallediyor.
val serviceImpl = loadService<Service>()
```

Normalde Java'da bir sınıfa ait bilgilere ulaşmak için her yere ClassName.class (Kotlin'de ClassName::class.java) yazmak
zorundasın. Bu kodun okunmasını zorlaştırır. Kotlin'deki reified özelliği, bu "kimlik kartı" verme işini
otomatikleştirir ve kodunun loadService<Service>() gibi tertemiz görünmesini sağlar.

Java'da ServiceLoader, SPI (Service Provider Interface) denilen bir mekanizmanın kalbidir. En basit tabiriyle: "Benim
bir işim var (interface), ama bu işi kimin yapacağını kodun içine yazmak istemiyorum; dışarıdan birileri bu işi
üstlensin ve ben onları otomatik bulayım" demektir.

```java
// Bu sizin "kontratınızdır". Uygulamanız sadece bunu bilir.
public interface FileCompressor {
    void compress(String fileName);

    String getExtension(); // .zip, .rar vb.
}
```

Bu sınıflar farklı JAR dosyalarının içinde bile olabilir. Uygulamanız bunları doğrudan tanımaz.
Birileri Bu İşi Üstlensin (Implementation);

```java
public class ZipCompressor implements FileCompressor {
    @Override
    public void compress(String fileName) {
        System.out.println(fileName + " ZIP compressed");
    }

    @Override
    public String getExtension() {
        return "zip";
    }
}

public class RarCompressor implements FileCompressor {
    @Override
    public void compress(String fileName) {
        System.out.println(fileName + " RAR compressed");
    }

    @Override
    public String getExtension() {
        return "rar";
    }
}
```

Java'nın bu sınıfı bulabilmesi için sihirli bir klasöre ihtiyacı vardır. Projenin resources klasöründe şu yolu
izlemelisiniz:

* Klasör oluştur: src/main/resources/META-INF/services/

* Dosya oluştur: Dosyanın adı, interface'in tam yolu olmalıdır: `com.example.api.FileCompressor`

* İçine yaz: Bu işi yapan sınıfın tam yolunu içine satır olarak ekle: `com.example.plugins.ZipCompressor`
  `com.example.plugins.RarCompressor`

İşte ana uygulamanızda (main) tüm bu eklentileri nasıl topladığınız:

```java
public class Main {
    public static void main(String[] args) {
        // "Bana FileCompressor'ı uygulayan herkesi bul!"
        ServiceLoader<FileCompressor> loader = ServiceLoader.load(FileCompressor.class);

        for (FileCompressor compressor : loader) {
            // Hangi sınıf olduğunu (Zip mi, Rar mı) bilmemize gerek yok!
            compressor.compress("dokuman.pdf");
        }
    }

    // document.pdf ZIP compressed
    // document.pdf RAR compressed
}
```

Gevşek Bağlılık (Decoupling): Ana kodunuz (Main), ZipCompressor sınıfına bağımlı değildir. Onu import bile etmez. Yarın
bir gün RarCompressor eklemek isterseniz, ana kodu değiştirmeden sadece yeni bir JAR dosyasını projeye dahil etmeniz
yeterlidir.

Kotlin'de öğrendiğin o reified fonksiyonu sayesinde:

```kotlin
// Java'daki 'FileCompressor.class' kısmını elmas içine taşıyoruz
val loader = loadService<FileCompressor>()
```

Kotlinde durumu örneklendirelim;

```kotlin
fun main() {
    val loader = ServiceLoader.load(FileCompressor::class.java)
    println("--- Available Compressors Found ---")

    // Loader bir Iterable olduğu için Kotlin'in tüm nimetlerinden (forEach vb.) faydalanabiliriz
    loader.forEach { compressor ->
        println("Found extension: ${compressor.getExtension()}")
        compressor.compress("holiday_photos.jpg")
    }

    // --- Available Compressors Found ---
    // Found extension: zip
    // holiday_photos.jpg ZIP compressed
    // Found extension: rar
    // holiday_photos.jpg RAR compressed
}
```

Dikkat ettiysen, Kotlin'deki main fonksiyonun içinde ne ZipCompressor ne de RarCompressor kelimesini kullandık. Kotlin
kodun sadece FileCompressor (interface) olduğunu biliyor. Sen yarın bir gün 7zCompressor diye bir Java sınıfı daha
eklesen, Kotlin koduna dokunmana, onu yeniden derlemene (recompile) gerek kalmadan o yeni sınıf da otomatik olarak
çalışacaktır.

Eğer bu kullanımı daha da "Kotlinvari" yapmak istersen, daha önce konuştuğumuz reified fonksiyonunu buraya
ekleyebilirsin:

```kotlin
inline fun <reified T> loadServices(): ServiceLoader<T> = ServiceLoader.load(T::class.java)

fun main() {
    val loader = loadServices<FileCompressor>()
    loader.forEach { it.compress("Document.pdf") }
    // Document.pdf ZIP compressed
    // Document.pdf RAR compressed
}
```

ServiceLoader bir liste (Map) gibi çalışmaz, bir Iterable (tek tek gezilebilen yapı) gibi çalışır. Bu yüzden belirli bir
servisi seçmek için ya bir Döngü/Filtre kullanmalıyız ya da bir Seçici (Selector) mantığı kurmalıyız.

Java'da en modern yöntem, ServiceLoader'ı bir Stream'e dönüştürüp (veya üzerinden iterasyon yapıp) istediğimiz kriteri
kontrol etmektir.

```java
public static void main(String[] args) {
    ServiceLoader<FileCompressor> loader = ServiceLoader.load(FileCompressor.class);

    String desiredExtension = "rar";

    FileCompressor selectedProcessor = null;
    for (FileCompressor cp : loader) {
        if (cp.getExtension().equalsIgnoreCase(desiredExtension)) {
            selectedProcessor = cp;
            break;
        }
    }
    if (selectedProcessor != null) {
        selectedProcessor.compress("document.pdf");
    } else {
        System.out.println("Hata: " + desiredExtension + " için bir compressor bulunamadı!");
    }
}
```

Kotlin tarafı daha şıktır;

```kotlin
inline fun <reified T> loadServices(): ServiceLoader<T> = ServiceLoader.load(T::class.java)

fun main() {
    val loader = loadServices<FileCompressor>()

    val targetType = "zip"
    val zipProcessor = loader.find { it.extension == targetType }
    if (zipProcessor != null) {
        zipProcessor.compress("report.pdf")
    } else {
        println("Sorry, $targetType support is not installed.")
    }
}
```

Eğer projenin birçok yerinde "bana RAR lazım", "bana ZIP lazım" diyecekseniz, bunu bir reified fonksiyon ile birleştirip
bir Factory (Fabrika) gibi kullanabilirsiniz:

```kotlin
inline fun <reified T : Any> getService(filter: (T) -> Boolean): T? {
    return ServiceLoader.load(T::class.java).find(filter)
}

fun main() {
    getService<FileCompressor> { it.extension == "rar" }?.compress("Document.pdf")
}
```

1 - "reified T : Any" (Kısıtlama Kısmı)

Buradaki Any ifadesi fonksiyonun dönüş tipi değildir. Bu bir "Üst Sınır" (Upper Bound) kısıtlamasıdır. Ne anlama
gelir? "Bu fonksiyona göndereceğin T tipi (örneğin FileCompressor), Kotlin'deki en tepedeki non-null sınıf olan Any'den
türemiş olmalı" diyoruz. Neyi engeller? Birinin yanlışlıkla getService<FileCompressor?> (yani nullable bir tip)
göndermesini engeller. Tipin başlangıçta "temiz ve dolu" olmasını garanti ederiz.

2 - "getService(filter: (T) -> Boolean)" (Girdi Kısmı)

"Parantez içinde sana bir süzgeç (filtre) gelecek" diyoruz. Bu filtre, T tipindeki her bir nesneye (Zip, Rar vb.)
bakacak ve senin istediğin şartı sağlayıp sağlamadığına göre true veya false diyecek.

3 - ": T?" (Dönüş Tipi Kısmı)

İşte en önemli fark burada. Fonksiyonun gerçek dönüş tipi T?'dir. Neden T değil de T?? Çünkü yazdığın filtreye uygun bir
servis sistemde hiç bulunamayabilir. Eğer "Sadece 7zip olanı getir" dersen ve sistemde 7zip yoksa, uygulama çökmesin
diye sana "boş" yani null döner.

"Bana öyle bir T tipi ver ki; bu tip boş olamasın (: Any) ve ben onun ne olduğunu çalışma anında görebileyim (reified).
Sana bu tipteki servisleri bulup getireceğim ama önce onları senin parantez içinde gönderdiğin kriterle (filter) tek tek
kontrol edeceğim. Eğer kriterine uyan birini bulursam onu sana vereceğim, bulamazsam null döneceğim (: T?)."