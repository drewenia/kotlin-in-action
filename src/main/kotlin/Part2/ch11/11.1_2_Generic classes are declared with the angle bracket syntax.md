# Generic classes are declared with the angle bracket syntax

Java’da olduğu gibi, Kotlin’de de generic bir class veya interface’i, class adından sonra angle bracket’lar koyup type
parameter’ları bu angle bracket’ların içine yazarak declare edersin. Bunu yaptıktan sonra, class’ın body’si içinde type
parameter’ları diğer type’lar gibi kullanabilirsin. Standard library’den bildiğin basic bir interface olan List’in
Kotlin’de nasıl declare edilebileceğine bakalım. Basitleştirmek için metodların çoğunu çıkardık:

```kotlin
// List interface’i, T type parameter’ını define eder.
interface List<T> {
    // T, bir interface veya class içinde regular bir type gibi kullanılabilir.
    operator fun get(index: Int): T
// ...
}
```

Daha sonra, section 11.3’te variance konusuna geldiğimizde, bu example’ı geliştirecek ve List’in Kotlin standard
library’de nasıl declared edildiğini göreceksin.

Eğer class’ın generic bir class’ı extend ediyorsa (veya generic bir interface’i implement ediyorsa), base type’ın
generic parameter’ı için bir type argument sağlaman gerekir. Bu, belirli bir type ya da başka bir type parameter
olabilir:

```kotlin
// Bu class, List’i implement eder ve belirli bir type argument sağlar: String.
class StringList : List<String> {
    // String’in T yerine nasıl kullanıldığına dikkat et.
    override fun get(index: Int): String {
        TODO("Not yet implemented")
    }
}

// Artık ArrayList’in generic type parameter’ı olan T, List için bir type argument’tır.
class ArrayList<T> : List<T> {
    override fun get(index: Int): T {
        TODO("Not yet implemented")
    }
}
```

StringList class’ı yalnızca String element’ler içerecek şekilde declared edilmiştir; bu nedenle base type’ın type
argument’ı olarak String kullanır. Subclass’taki herhangi bir fonksiyon, T yerine bu uygun type’ı substitute eder. Bu da
`fun get(Int): T` yerine, `fun get(Int): String` signature’ına sahip olduğun anlamına gelir.

ArrayList class’ı kendi type parameter’ı olan T’yi define eder ve bunu superclass’ın type argument’ı olarak belirtir.
ArrayList<T> içindeki T’nin, List<T> içindeki T ile aynı olmadığını unutma—bu yeni bir type parameter’dır ve aynı ada
sahip olması gerekmez.

Bir class, type argument olarak kendisine bile refer edebilir. Comparable interface’ini implement eden class’lar bu
pattern’in klasik örneğidir. Her comparable element, aynı type’a sahip object’lerle nasıl karşılaştırılacağını
tanımlamalıdır:

```kotlin
interface Comparable<T> {
    fun compareTo(other: T): Int
}

class String : Comparable<String> {
    override fun compareTo(other: String): Int = TODO()
}
```

String class’ı, generic Comparable interface’ini implement eder ve type parameter T için String type’ını sağlar.

Şu ana kadar generics, Java’dakilere benzer görünmektedir. Farklardan chapter’ın ilerleyen bölümlerinde, section 11.2 ve
11.3’te bahsedeceğiz. Şimdi, Java’da benzer şekilde çalışan başka bir kavramı ele alalım: comparable item’larla çalışmak
için kullanışlı fonksiyonlar yazmanı sağlayan kavram.