# Type aliases

Birden fazla generic’i birleştiren type’larla çalışırken, bir type signature’ın arkasındaki anlamı takip etmek bazen
zahmetli olabilir. `List<(String, Int) -> String>` type’ına sahip bir collection’ın amacının ne olduğu hemen açık
olmayabilir ve ona her referans vermek istediğinizde aynı karmaşık generic ve functional type kombinasyonunu tekrar
etmekten kaçınmak isteyebilirsiniz.

Bunun gibi durumlar için Kotlin, mevcut type’lar için alternatif adlar olan type alias’ları tanımlamanıza izin verir.
Bir type alias’ı, typealias keyword’ünü ve ardından alias’ı kullanarak tanımlarsınız. Daha sonra = işaretinden sonra,
asıl, underlying type’ı belirtirsiniz.

Uzun generic type’ları kısaltmak istediğinizde type alias’ları özellikle faydalı bulabilirsiniz. Bu örnekte, bu kitabın
dört yazarının adlarını birleştirmek için combineAuthors adlı bir function declare edersiniz. Yazarların nasıl
birleştirileceğine dair behavior, dört string alan ve yeni, birleştirilmiş bir string döndüren functional type’ta bir
parameter kullanılarak geçirilebilir. Bu genellikle kullanışlıdır, çünkü type signature’ı olan (String, String, String,
String) -> String, her kullanımda tekrar etmek için biraz zahmetli olabilir. Bir type alias kullanarak, bu functional
type’a yeni bir ad verebilirsiniz: NameCombiner. Bu alias, daha önce underlying type’ı kullandığınız her yerde
kullanılabilir.

```kotlin
// Bir type alias, typealias keyword’ü, alias ve underlying type kullanılarak tanımlanır.
typealias NameCombiner = (String, String, String, String) -> String

// Type alias’lar, underlying type’ı kullandığınız her yerde kullanılabilir; örneğin variable declaration’larda …
val authorsCombiner: NameCombiner = { a, b, c, d -> "$a et al." }
val bandCombiner: NameCombiner = { a, b, c, d -> "$a, $b & The Gang" }

// … ya da function parameter declaration’ları.
fun combineAuthors(combiner: NameCombiner) {
    println(combiner("Sveta", "Seb", "Dima", "Roman"))
}

fun main() {
    // Type alias, underlying type’a resolve olur. Bu yüzden bir NameCombiner geçirmek tamamen uygundur …
    combineAuthors(bandCombiner) // Sveta, Seb & The Gang
    combineAuthors(authorsCombiner) // Sveta et al.

    // … ya da dört string alan ve tek bir string döndüren bir lambda.
    combineAuthors { a, b, c, d -> "$d, $c & Co." } // Roman, Dima & Co.
}
```

Bir type alias tanıtarak, functional type’a kodu okurken yardımcı olabilecek ek bir context kazandırmış olursunuz.
Ancak, codebase’inize aşina olmayan developer’ların, kodu okurken ya da değişiklik yaparken NameCombiner alias’ını
zihinsel olarak tekrar underlying type’ına resolve etmek için ek zaman harcaması gerekebileceğini de akılda tutmak
gerekir. Codebase’inizde type alias’ları ne zaman tanıtacağınıza karar vermek, nihayetinde sizin vereceğiniz bir
tradeoff’tur.

Compiler açısından bakıldığında, type alias’lar herhangi bir yeni kısıtlama ya da değişiklik getirmez—compile sırasında
alias’lar tamamen underlying type’larına expand edilir. Bu nedenle, yararlı bir kısaltma sağlasalar da, type alias’lar
ek bir type safety sağlamaz.

### Inline classes and type aliases: When to use each

Type alias’lar yararlı bir kısaltma sağlar, ancak ek bir type safety sağlamaz. Bu, iki type’ın yanlışlıkla birbirinin
yerine kullanılmasını engelleyen ek korumalar getirmek için kullanılamayacakları anlamına gelir; aşağıdaki örnek bunu
gösterir. String için ValidatedInput adlı bir typealias tanıtmak, save function’ının signature’ını, validated bir input
beklendiğini işaret ederek daha net hâle getirir; ancak compiler, herhangi bir String’i hiçbir şikâyet olmadan kabul
eder.

```kotlin
typealias ValidatedInput = String

fun save(v: ValidatedInput): Unit = TODO()

fun main() {
    val rawInput = "needs validating"
    // Type alias’lar, compile-time aşamasında herhangi bir ek garanti sağlamaz.
    save(rawInput)
}
```

Eğer minimize edilmiş run-time overhead ile ek type safety hedefiniz varsa, inline class’ları kullandığınızdan emin
olun (4.5 bölümünde tartışıldığı gibi). Inline class’ların type’ları diğer tüm type’lar gibi kontrol edildiğinden,
önceki örnek ValidatedInput ile String arasındaki bir type mismatch nedeniyle compile olmaz; bu da save function’ının
kullanıcısını String’den ValidatedInput’a dönüşümü explicit olarak yapmaya zorlar ve böylece potansiyel bug’ların erken
yakalanmasını sağlar.

```kotlin
@JvmInline
value class ValidateInput(val s : String)

fun save (v: ValidateInput) : Unit = TODO()

fun main() {
    val rawInput = "needs validating"
    // save(rawInput) // ValidatedInput ile String arasındaki type mismatch nedeniyle compile olmaz.
}
```