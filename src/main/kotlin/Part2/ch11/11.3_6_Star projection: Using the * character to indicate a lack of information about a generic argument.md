# Star projection: Using the * character to indicate a lack of information about a generic argument

Bu bölümün önceki kısımlarında type check’ler ve cast’ler hakkında konuşurken, generic argument hakkında hiçbir bilgin
olmadığını belirtmek için kullanabileceğin özel star-projection syntax’ından bahsetmiştik. Örneğin, unknown bir type’a
ait element’lerden oluşan bir list, bu syntax kullanılarak `List<*>` şeklinde ifade edilir. Şimdi star projection’ların
semantiklerini ayrıntılı olarak inceleyelim.

Öncelikle, `MutableList<*>`’in `MutableList<Any?>` ile aynı olmadığını unutmayın (burada önemli olan,
`MutableList<T>`’nin T üzerinde invariant (değişmez) olmasıdır). `MutableList<Any?>`, içinde herhangi bir type’a ait
element’ler bulunabileceğini bildiğiniz bir listedir. Öte yandan, `MutableList<*>` belirli bir type’a ait element’ler
içeren ancak bu type’ı bilmediğiniz bir listedir. Liste, String gibi belirli bir type’a ait element’lerden oluşan bir
liste olarak oluşturulmuştur (yeni bir `ArrayList<*>` oluşturamazsınız) ve listeyi oluşturan kod, içinde yalnızca o
type’a ait element’ler olmasını bekler. Type’ı bilmediğiniz için listeye hiçbir şey ekleyemezsiniz; çünkü eklediğiniz
herhangi bir değer, calling code’un beklentilerini ihlal edebilir. Ancak listedeki element’leri almak mümkündür; çünkü
orada saklanan tüm değerlerin kesin olarak Any? type’ına uygun olacağını bilirsiniz; Any?, tüm Kotlin type’larının
supertype’ıdır.

```kotlin
fun main() {
    val list: MutableList<Any?> = mutableListOf('a', 1, "qwe")
    val chars = mutableListOf('a', 'b', 'c')

    /* MutableList<*> MutableList<Any?> ile aynı değildir.*/
    val unknownElements: MutableList<*> =
        if (Random.nextBoolean()) list else chars

    /* Element’leri almak güvenlidir: first() Any? type’ında bir element döndürür. */
    println(unknownElements.first()) // a

    // Compiler, bu method’u çağırmanı yasaklar.
    // unknownElements.add(42)
    // Error: Out-projected type 'MutableList<*>' prohibits
    // the use of 'fun add(element: E): Boolean'
}
```

Compiler, neden `MutableList<*>`’i out-projected type olarak adlandırıyor? Bu context'de, `MutableList<*>`
`MutableList<out Any?>` olarak projeksiyon alır (davranır): element’in type’ı hakkında hiçbir şey bilmediğinizde, Any?
type’ında element almak güvenlidir, ancak listeye element eklemek güvenli değildir. Java wildcard’ları ile ilgili
olarak, Kotlin’deki `MyType<*>` Java’daki `MyType<?>` ile karşılık gelir.

Contravariant type parameter’lar için, örneğin `Consumer<in T>`, bir star projection `<in Nothing>` ile eşdeğerdir.
Aslında, böyle bir star projection üzerinde imzasında T bulunan herhangi bir method’u çağırmanız mümkün değildir. Eğer
type parameter contravariant ise, yalnızca bir consumer olarak davranır ve daha önce tartıştığımız gibi, tam olarak neyi
consume edeceğini bilmezsiniz. Bu nedenle, ona consume etmesi için herhangi bir şey veremezsiniz.

Type argument’lar hakkında bilgi önemli olmadığında star-projection syntax’ını kullanabilirsiniz: imzada type
parameter’a atıfta bulunan herhangi bir method kullanmazsınız ya da yalnızca veriyi okursunuz ve onun spesifik type’ı
önemli değildir. Örneğin, `List<*>` parametresi alan printFirst function’ını implemente edebilirsiniz:

```kotlin
// Her liste olası bir argument’tır.
fun printFirst(list: List<*>) {
    // isNotEmpty() generic type parameter’ı kullanmaz.
    if (list.isNotEmpty()) println(list.first()) // first() artık Any? döndürür, ancak bu case de bu yeterlidir.
}

fun main() {
    printFirst(listOf("Sveta", "Seb", "Dima")) // Sveta
}
```

Use-site variance case'inde olduğu gibi, bir alternatifiniz vardır — generic type parameter tanıtmak.

```kotlin
// Yine, her liste olası bir argument’tır.
fun <T> printFirst(list: List<T>) {
    if (list.isNotEmpty()) println(list.first()) // first() artık T type’ında bir değer döndürür.
}
```

Star projection syntax’ı daha kısa bir ifadedir, ancak yalnızca generic type parameter’ın tam değeriyle
ilgilenmiyorsanız çalışır: yalnızca değer produce eden method’ları kullanırsınız ve bu değerlerin type’ları önemli
değildir.

Şimdi, star projection ile bir type kullanmanın başka bir örneğine ve bu yaklaşımı kullanırken düşebileceğiniz yaygın
tuzaklara bakalım. Diyelim ki kullanıcı girdisini doğrulamanız gerekiyor ve FieldValidator adlı bir interface declare
ediyorsunuz. Bu interface, type parameter’ını yalnızca `in` pozisyonunda içerir, bu yüzden contravariant olarak declare
edilebilir. Ve gerçekten de, bir string validator’ı beklendiğinde herhangi bir element’i doğrulayabilen validator’ı
kullanmak doğrudur (bunu contravariant olarak declare etmek sağlar). Ayrıca String ve Int input’ları işleyen iki
validator declare edersiniz.

```kotlin
interface FieldValidator<in T> {
    fun validate(input: T): Boolean
}

object DefaultStringValidator : FieldValidator<String> {
    override fun validate(input: String) = input.isNotEmpty()
}

object DefaultIntValidator : FieldValidator<Int> {
    override fun validate(input: Int) = input >= 0
}
```

Şimdi, tüm validator’ları aynı container’da saklamak ve input’un type’ına göre doğru validator’ı almak istediğinizi
hayal edin. İlk denemeniz, onları saklamak için bir map kullanmak olabilir. Her tür için validator saklamanız
gerektiğinden, KClass’tan (Kotlin class’ını temsil eder—chapter 12 KClass’ı ayrıntılı olarak ele alacak)
FieldValidator<*>’a bir map declare edersiniz (bu, herhangi bir type’a ait validator’a atıfta bulunabilir):

```kotlin
interface FieldValidator<in T> {
    fun validate(input: T): Boolean
}

object DefaultStringValidator : FieldValidator<String> {
    override fun validate(input: String) = input.isNotEmpty()
}

object DefaultIntValidator : FieldValidator<Int> {
    override fun validate(input: Int) = input >= 0
}

fun main() {
    val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()
    validators[String::class] = DefaultStringValidator
    validators[Int::class] = DefaultIntValidator
}
```

Bunu yaptıktan sonra, validator’ları kullanmaya çalışırken zorluk yaşayabilirsiniz. FieldValidator<*> type’ındaki bir
validator ile bir string’i validate edemezsiniz. Bu güvenli değildir çünkü compiler, validator’ın ne tür olduğunu
bilmez:

```kotlin
fun main() {
    val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()
    validators[String::class] = DefaultStringValidator
    validators[Int::class] = DefaultIntValidator

    // Map’te saklanan değer, FieldValidator<*> type’ındadır.
    // validators[String::class]!!.validate("")
    // Error: Out-projected type 'FieldValidator<*>' prohibits
    // the use of 'fun validate(input: T): Boolean'
}
```

Daha önce `MutableList<*>`’e bir element koymayı denediğinizde bu hatayı görmüştünüz. Bu durumda, bu hata, unknown type
için bir validator’a belirli bir type’a ait bir değer vermenin güvenli olmadığını gösterir. Bunu düzeltmenin yollarından
biri, validator’ı ihtiyacınız olan type’a explicit olarak cast etmektir. Bu güvenli değildir ve önerilmez, ancak
kodunuzun compile olmasını sağlamak için hızlı bir hile olarak burada gösteriyoruz; ardından kodu refactor
edebilirsiniz.

```kotlin
fun main() {
    val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()
    validators[String::class] = DefaultStringValidator
    validators[Int::class] = DefaultIntValidator

    // Warning: “unchecked cast”
    val stringValidator = validators[String::class] as FieldValidator<String>
    // Warning: “unchecked cast”
    val intValidator = validators[Int::class] as FieldValidator<Int>

    println(stringValidator.validate("")) // false
    println(intValidator.validate(-5)) // false
}
```

Compiler, unchecked cast hakkında bir uyarı verir. Ancak unutmayın, bu kod yalnızca validation sırasında başarısız olur;
cast işlemi sırasında değil, çünkü runtime’da tüm generic type bilgisi silinir.

```kotlin
fun main() {
    val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()
    validators[String::class] = DefaultStringValidator
    validators[Int::class] = DefaultIntValidator

    // Yanlış bir validator alırsınız (muhtemelen yanlışlıkla), ancak bu kod compile olur.
    val stringValidator = validators[Int::class] as FieldValidator<String>
    stringValidator.validate("") // Gerçek hata, validator’ı kullanana kadar gizlidir.
    // java.lang.ClassCastException:
    // java.lang.String cannot be cast to java.lang.Number
    // at DefaultIntValidator.validate
}
```

Bu hatalı kod ile bir üstünde ki örnek kod benzerdir; her iki durumda da yalnızca bir uyarı üretilir. Yalnızca doğru
type’taki değerleri cast etmek sizin sorumluluğunuz hâline gelir.

Bu çözüm type safe değildir ve hataya açıktır. Bu yüzden, farklı type’lar için validator’ları tek bir yerde saklamak
istiyorsanız başka hangi seçeneklere sahip olduğunuzu inceleyelim.

Aşağıdaki code'da ki çözüm, aynı validators map’ini kullanır ancak ona yapılan tüm erişimi, yalnızca doğru
validator’ların registered edilmesinden ve returned edilmesinden sorumlu iki generic method içine encapsulate eder. Bu
kod da unchecked cast hakkında bir uyarı üretir (aynı uyarı), ancak burada Validators object’i map’e yapılan tüm erişimi
kontrol eder ve bu da kimsenin map’i yanlış şekilde değiştirmemesini garanti eder.

```kotlin
interface FieldValidator<in T> {
    fun validate(input: T): Boolean
}

object DefaultStringValidator : FieldValidator<String> {
    override fun validate(input: String) = input.isNotEmpty()
}

object DefaultIntValidator : FieldValidator<Int> {
    override fun validate(input: Int) = input >= 0
}

object Validators {
    // Öncekiyle aynı map’i kullanır, ancak artık ona dışarıdan access edemezsiniz.
    private val validators = mutableMapOf<KClass<*>, FieldValidator<*>>()

    // Validator’ın bir class ile karşılık geldiği durumda, map’e yalnızca doğru key–value pair’ları koyar.
    fun <T : Any> registerValidator(
        kClass: KClass<T>, fieldValidator: FieldValidator<T>
    ) {
        validators[kClass] = fieldValidator
    }

    // FieldValidator<T>’ye yapılan unchecked cast hakkındaki uyarıyı bastırır.
    @Suppress("UNCHECKED_CAST")
    operator fun <T : Any> get(kClass: KClass<T>): FieldValidator<T> =
        validators[kClass] as? FieldValidator<T>
            ?: throw IllegalArgumentException("No validator for ${kClass.simpleName}")
}


fun main() {
    Validators.registerValidator(String::class, DefaultStringValidator)
    Validators.registerValidator(Int::class, DefaultIntValidator)

    println(Validators[String::class].validate("Kotlin")) // true
    println(Validators[Int::class].validate(42)) // true
}
```

`operator fun <T : Any> get(kClass: KClass<T>): FieldValidator<T>` methodu hiçbir yerde call edilmediği halde nasıl
çalışıyor? Aslında get metodu sandığından çok daha akıllıca bir şekilde kullanılıyor!

```kotlin
println(Validators[String::class].validate("Kotlin"))
println(Validators[Int::class].validate(42))
```

Buradaki `Validators[String::class]` kullanımı, Kotlin'in operator overloading özelliğini kullanır. Kotlin'de bir
fonksiyonun başına operator keyword'unu koyup adını da `get` yaparsan, o object'e köşeli parantez [] ile erişebilirsin.
Compiler arka planda senin için şu dönüşümü yapar:

* Senin yazdığın: `Validators[String::class]`

* Compiler'ın anladığı: `Validators.get(String::class)`

Yani get metodu fiziksel olarak "get" kelimesiyle çağrılmıyor, ama o köşeli parantezler doğrudan o metodu tetikliyor.
`FieldValidator<in T>` içindeki `in` kelimesi sayesinde şunu yapabilirsin: Diyelim ki elinde tüm objeleri kontrol eden
bir `FieldValidator<Any>` var. Bu validator, `Validators.registerValidator(String::class, AnyValidator)` şeklinde
kaydedilebilir. Çünkü "Her şeyi kontrol edebilen bir şey, String'i de kontrol edebilir." Bu, Contravariance'ın gücüdür.

Artık type-safe bir API’niz vardır. Tüm unsafe logic class’ın body’si içinde gizlenmiştir ve bunu locale'leştirerek
yanlış kullanılmayacağını garanti edersiniz. Compiler, yanlış bir validator kullanmanızı yasaklar çünkü Validators
object’i size her zaman doğru validator implementasyonunu verir.

```kotlin
// Artık get method’u, FieldValidator<String>’in bir instance’ını döndürür.
println(Validators[String::class].validate(42))
// Error: The integer literal does not conform to the expected type String
```

Bu pattern, herhangi bir custom generic class’ın saklanmasına kolayca extend edilebilir. Unsafe code’u ayrı bir yerde
locale'leştirmek, yanlış kullanımı önler ve bir container’ın kullanımını safe hâle getirir. Burada açıklanan pattern
Kotlin’e özgü değildir; aynı yaklaşımı Java’da da kullanabilirsiniz.

Java generics ve variance genellikle dilin en zorlayıcı kısmı olarak kabul edilir. Kotlin’te, Java ile interoperable
kalırken, anlaşılması ve birlikte çalışması daha kolay bir design ortaya koymak için büyük çaba harcadık.