# Specifying variance for type occurrences via use-site variance

Class declaration’larında variance modifier’larını belirtme yeteneği kullanışlıdır; çünkü bu modifier’lar class’ın
kullanıldığı tüm yerlerde geçerli olur. Buna declaration-site variance denir. Java’daki wildcard type’lara (? extends
ve ? super) aşinaysan, Java’nın variance’ı farklı şekilde ele aldığını fark edersin. Java’da, type parameter’a sahip bir
type’ı her kullandığında, bu type parameter’ın subtype’ları mı yoksa supertype’ları mı ile değiştirilebileceğini de
belirtebilirsin. Buna use-site variance denir.

Java, use-site variance kullanır; yani variance, generic type’ın kullanıldığı yerde belirtilir; başka bir deyişle, bir
variable oluştururken, bir argument geçirirken veya generic kullanan bir return type belirtirken. Java’da bu kullanım
noktalarında istenen variance’ı ifade etmek için wildcard’lar (? extends T ve ? super T) kullanılır.

### ? extends T (Covariance):

`List<? extends Number>`, Number’ı extend eden bir şeylerin list’i anlamına gelir. Number upper bound’dur. İçinden
Number object’lerini güvenle read edebilirsin, ancak (null dışında) hiçbir şey add edemezsin; çünkü compiler list içinde
izin verilen element’lerin exact (tam) type’ını bilmez.

### ? super T (Contravariance):

`List<? super Integer>`, Integer’ı veya onun herhangi bir supertype’ını kabul edebilen bir list anlamına gelir. Integer
lower bound’dur. İçine Integer object’leri (ve Integer’ın herhangi bir supertype’ı) güvenle add edebilirsin, ancak
element’lerin spesifik type’ı compile time’da bilinmediği için onları yalnızca Object olarak read edebilirsin.

### T (Invariance):

List<Number>, yalnızca Number object’lerini kabul eden ve produce eden bir list anlamına gelir.

Bunun ima ettiği şey şudur:

Generic type’ın declaration’ının kendisinin inherent (içsel) bir variance’ı yoktur. Aynı generic class, spesifik
context’e bağlı olarak covariant, contravariant ya da invariant bir şekilde kullanılabilir.

Java: Covariance Example `? extends T` ;

```java
static void getNotPut() {
    List<? extends Number> numbers = List.of(1, 2, 3);
    double sum = sum(numbers); // // List’ten value’ları get eder

    // numbers.add(2.718);
    // compile-time error: list’e value koyamazsın
}

static double sum(Collection<? extends Number> numbers) {
    double sum = 0;
    for (Number number : numbers) {
        sum += number.doubleValue();
    }
    return sum;
}
```

Java: Contravariance Example `? super T` ;

Generic type’a write edebilirsin, ancak read işlemi Object ile sınırlıdır

```java
static void putNotGet() {
    List<Object> objs = Arrays.asList(1, "two");
    List<? super Integer> ints = objs;

    // ints.add(3); // ok, list’e value koyabilirsin
    // double dbl = sum(ints);
    // compile-time error. Yalnızca Object’ler get edilebilir
    String str = "";
    for (Object obj : ints) {
        str += obj.toString();
    }
    System.out.println(str); //1two
}
```

### The Get and Put Principle

Bir structure’dan yalnızca value’ları **get** ediyorsan **extends wildcard** kullan; bir structure’ın içine yalnızca
value **put** ediyorsan **super wildcard** kullan; hem get hem put yapıyorsan **wildcard kullanma**.

Bunların birlikte kullanıldığını bir **copy** method’unun signature’ında görebiliriz.

```java
public static <T> void copy(List<? super T> destination, List<? extends T> source);
```

___
___

### Declaration-site variance in Kotlin vs. Java wildcards

Declaration-site variance, variance modifier’larını bir kez belirtmeni sağladığı için daha concise code yazılmasına
olanak tanır; class’ını kullanan client’ların bunları düşünmesine gerek kalmaz. Java’da ise, kullanıcıların
beklentilerine uygun davranan API’ler oluşturmak için library writer’ın wildcard’ları sürekli kullanması gerekir:
`Function<? super T, ? extends R>`. Java 8 standard library’nin source code’unu incelersen, Function interface’inin
neredeyse her kullanımında wildcard’lar olduğunu görürsün. Örneğin, Stream.map method’u şu şekilde declare edilmiştir:

```java
/* Java */
public interface Stream<T> {
    <R> Stream<R> map(Function<? super T, ? extends R> mapper);
}
```

Variance’ı declaration’da bir kez belirtmek, code’u çok daha concise ve elegant hâle getirir.

___
___

Kotlin, use-site variance’ı da destekler; bu da class declaration’ında covariant veya contravariant olarak declare
edilemeyen durumlarda bile, type parameter’ın belirli bir kullanımında variance belirtmene olanak tanır. Bunun nasıl
çalıştığına bakalım.

Birçok interface’in (örneğin MutableList) genel case'de ne covariant ne de contravariant olduğunu gördün; çünkü type
parameter’ları tarafından belirtilen type’lardaki value’ları hem produce edebilir hem de consume edebilirler. Ancak
belirli bir function içinde bu type’taki bir variable’ın çoğu zaman bu rollerden yalnızca birinde—ya producer ya da
consumer olarak — kullanılması yaygındır.

Örneğin, şu basit function’ı ele alalım.

```kotlin
fun <T> copyData(source: MutableList<T>, destination: MutableList<T>) {
    for (item in source) {
        destination.add(item)
    }
}
```

Bu function, element’leri bir collection’dan diğerine kopyalar. Her iki collection da invariant type’a sahip olsa bile,
source collection yalnızca read için, destination collection ise yalnızca write için kullanılır. Bu durumda, belirli bir
type’taki element’ler, bu element’lerin bir supertype’ını saklayan bir collection içine kopyalanabilir.

Örneğin, string’lerden oluşan bir collection’ı generic type’ı Any olan bir collection’a kopyalamak tamamen geçerlidir.
Bu function’ın farklı type’lardaki list’lerle çalışabilmesi için ikinci bir generic parameter introduce edebilirsin.

```kotlin
// Source’un element type’ı, destination’ın element type’ının bir subtype’ı olmalıdır.
// T mutlaka R tipinden türemiş (onun subtype'ı) olmalı" demek. (Örn: Cat : Animal)
fun <T : R, R> copyData(source: MutableList<T>, destination: MutableList<R>) {
    for (item in source) {
        destination.add(item)
    }
}

fun main() {
    val ints = mutableListOf(1, 2, 3)
    val anyItems = mutableListOf<Any>()
    copyData(ints, anyItems) // Bu function’ı call edebilirsin; çünkü Int, Any’nin bir subtype’ıdır.
    println(anyItems) // [1, 2, 3]
}
```

Source ve destination list’lerin element type’larını temsil eden iki generic parameter declare edersin. Bir list’ten
diğerine element kopyalayabilmek için, source element type’ının destination list’teki element’lerin bir subtype’ı olması
gerekir; tıpkı aşağıda ki fonksiyon’da Int’in Any’nin bir subtype’ı olması gibi. Ancak Kotlin bunu ifade etmek için daha
elegant bir yol sunar. Bir function’ın implementation’ı, type parameter’ı yalnızca out (ya da yalnızca in) position’da
kullanan method’ları call ediyorsa, bundan yararlanabilir ve function definition’ındaki type parameter’ın ilgili
kullanımlarına variance modifier’ları ekleyebilirsin.

```kotlin
// Type usage’a out keyword’ünü ekleyebilirsin; T’yi in position’da kullanan hiçbir method kullanılmaz.
fun <T> copyData(source: MutableList<out T>, destination: MutableList<T>) {
    for (item in source) {
        destination.add(item)
    }
}

fun main() {
    val ints = mutableListOf(1, 2, 3)
    val anyItems = mutableListOf<Any>()
    copyData(ints, anyItems)
    println(anyItems) // [1, 2, 3]
}
```

Bir type declaration içindeki type parameter’ın herhangi bir kullanımında variance modifier belirtebilirsin: bir
parameter type’ında (yukarıdaki kodda ki gibi), local variable type’ında, function return type’ında vb. Burada olan şeye
**type projection** denir: source, artık normal bir MutableList değil, projected (kısıtlanmış) bir MutableList’tir.
Yalnızca generic type parameter’ı döndüren method’ları call edebilirsin ya da daha kesin ifadeyle, onu yalnızca out
position’da kullanabilirsin. Compiler, bu type parameter’ın argument olarak kullanıldığı (in position) method’ların call
edilmesini yasaklar.

```kotlin
fun main() {
    val list: MutableList<out Number> = mutableListOf()
    // list.add(42)
    // Error: Out-projected type 'MutableList<out Number>',
    // 'fun add(element: E): Boolean' kullanımını yasaklar
}
```

Projected bir type kullanırken bazı method’ları call edememene şaşırma. Eğer bu method’ları call etmen gerekiyorsa,
projection yerine regular bir type kullanmalısın. Bu da;

```fun <T: R, R> copyData(source: MutableList<T>, destination: MutableList<R>)``` örneğinde olduğu gibi, başlangıçta
projection olan type’a bağlı ikinci bir type parameter declare etmeni gerektirebilir.

Elbette, copyData function’ını implement etmenin doğru yolu, source argument’ının type’ı olarak `List<T>` kullanmaktır;
çünkü yalnızca `List`’te declare edilmiş method’ları kullanıyoruz, `MutableList`’tekileri değil ve `List` type
parameter’ının variance’ı declaration’ında zaten belirtilmiştir. Ancak bu örnek yine de concept’i göstermek açısından
önemlidir; özellikle de çoğu class’ın, `List` ve `MutableList`’te olduğu gibi, ayrı bir covariant read interface’i ile
invariant read–write interface’ine sahip olmadığını göz önünde bulundurursak.

Zaten out variance’a sahip olan bir type parameter için out projection kullanmanın bir anlamı yoktur; örneğin
`List<out T>`. Bu, `List<T>` ile aynı anlama gelir; çünkü `List`, `class List<out T>` olarak declare edilmiştir. Kotlin
compiler, böyle bir projection’ın redundant olduğu konusunda uyarı verir.

Benzer şekilde, bir type parameter üzerinde **in** modifier’ını kullanarak, bu konumda karşılık gelen value’nun bir *
*consumer** gibi davrandığını ve type parameter’ın herhangi bir **supertype**’ı ile değiştirilebileceğini
belirtebilirsin;

```fun <T> copyData(source: MutableList<out T>, destination: MutableList<T>)```bu imzayı bir **in projection**
kullanarak şu şekilde yeniden yazabilirsin.

```kotlin
fun <T> copyData(
    source: MutableList<T>,
    //Destination element type’ın, source element type’ın bir **supertype**’ı olmasına izin verir.
    destination: MutableList<in T>
) {
    for (item in source) {
        destination.add(item)
    }
}
```

Kotlin’te use-site variance declaration’ları, Java bounded wildcard’lara doğrudan karşılık gelir. Kotlin’te
`MutableList<out T>`, Java’daki `MutableList<? extends T>` ile aynı anlama gelir. in-projected `MutableList<in T>`,
Java’daki `MutableList<? super T>` ile karşılık gelir.

Use-site projection’lar, kabul edilebilir type’ların aralığını genişletmeye yardımcı olabilir. Şimdi, tüm olası type
argument’lara sahip type’ların kabul edilebilir hâle geldiği extreme case’i tartışalım.