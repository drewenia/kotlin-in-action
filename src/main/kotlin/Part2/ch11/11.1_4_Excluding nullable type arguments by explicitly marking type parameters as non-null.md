# Excluding nullable type arguments by explicitly marking type parameters as non-null

Generic bir class veya fonksiyon declare edersen, nullable olanlar da dahil olmak üzere herhangi bir type argument, type
parameter’larının yerine substitute edilebilir. Aslında, upper bound belirtilmemiş bir type parameter, upper bound’u
Any? olarak kabul eder. Aşağıdaki example’a bak:

```kotlin
class Processor<T> {
    fun process(value: T) {
        // value nullable olduğu için, safe call kullanman gerekir.
        value?.hashCode()
    }
}
```

process fonksiyonunda, parameter olan value nullable’dır; T’nin yanına soru işareti konmamış olmasına rağmen. Bunun
nedeni, Processor class’ının belirli instantiation’larının T için nullable bir type kullanabilmesidir—T’nin nullable
olmasını yasaklayan herhangi bir constraint yoktur (örneğin, String?):

```kotlin
class Processor<T> {
    fun process(value: T) {
        // value nullable olduğu için, safe call kullanman gerekir.
        value?.hashCode()
    }
}

fun main() {
    // String?, yani nullable bir type, T’nin yerine substitute edilir.
    val nullableString = Processor<String?>()
    // Artık T type’ındaki value non-null’dır.
    nullableString.process(null)

    val nullableInt = Processor<Int?>()
    nullableInt.process(11)
}
```

Bir type parameter için her zaman non-null bir type substitute edileceğini garanti etmek istiyorsan, bunu bir constraint
belirleyerek sağlayabilirsin. Nullability dışında başka bir kısıtlaman yoksa, default Any? yerine upper bound olarak Any
kullanabilirsin.

```kotlin
// Non-null upper bound belirtme
class Processor<T : Any> {
    fun process(value: T) {
        // Artık T type’ındaki value non-null’dır.
        value.hashCode()
    }
}
```

`<T : Any>` constraint, T type’ının her zaman non-nullable bir type olmasını garanti eder. Compiler, String? type
argument’ı verilen Processor<String?> kodunu kabul etmez; çünkü String?, Any’nin subtype’ı değildir (daha az spesifik
bir type olan Any?’nin subtype’ıdır):

```kotlin
val nullableStringProcessor = Processor<String?>()
// Error: Type argument is not within its bounds: should be subtype of 'Any'
```

Bir type parameter’ı non-null yapmak için sadece Any type’ını değil, herhangi bir non-null type’ı upper bound olarak
belirtebileceğini unutma.

### Java ile interoperating sırasında generic type’ları “definitely non-nullable” olarak işaretleme

Belirtmeye değer özel bir case, nullability annotation’larıyla annotate edilmiş Java’dan gelen generic interface’leri
implement etmektir; bunları section 7.12’de tanıdın. Örneğin, bu generic JBox interface’i, put method’unun yalnızca T
type’ında non-null bir parameter ile call edilmesini sınırlar. Interface’in kendisi genel olarak T type’ı üzerinde böyle
bir constraint koymaz; bu sayede putIfNotNull gibi diğer method’lar nullable value’ları kabul edebilir:

```java
import org.jetbrains.annotations.NotNull;

public interface JBox<T> {
    /**
     * Puts a non-null value into the box.
     */
    void put(@NotNull T t);

    /**
     * Puts a value into the box if it is not null,
     * doesn't do anything for null values.
     */
    void putIfNotNull(T t);
}
```

Şimdiye kadar gördüğün syntax ile, bu constraint’i doğrudan Kotlin koduna çeviremezdin. Eğer bir Kotlin implementasyonu
generic type için non-null constraint’i T : Any ile belirtirse, nullable value’lar artık implementasyon ile hiç
kullanılamaz—bu, Java interface tarafından verilen constraint ile farklı olur:

```kotlin
// Burada generic type T zaten non-nullable olacak şekilde constrained edildiği için…
class KBox<T : Any> : JBox<T> {
    override fun put(t: T) { /* ... */
    }

    // nullable parameter bekleyen bir fonksiyon için artık bu constraint’i gevşetemezsin.
    override fun putIfNotNull(t: T) { /* Problem! */
    }
}
```

Artık T, KBox implementasyonu içinde her yerde non-nullable’dır—sadece put method’unda değil. Bunu çözmek için Kotlin,
bir type’ı use site’ında (generic parameter’ın ilk define edildiği yerde değil) kesinlikle non-nullable olarak
işaretlemenin bir yolunu sağlar. Sözdizimsel olarak, `T & Any` şeklinde ifade edilir (bunu diğer dillerdeki intersection
type notasyonundan tanıyabilirsin):

```kotlin
class KBox<T> : JBox<T> {
    override fun put(t: T & Any) { /* ... */
    }
    override fun putIfNotNull(t: T) { /* ... */
    }
}
```

Definitely non-nullable type’ları kullanarak, artık Java kodunda tanımlanan aynı nullability constraint’larını Kotlin’de
ifade edebilirsin.

___
___

Şu ana kadar generics’in temellerini ele aldık—Java’ya en çok benzeyen konular. Şimdi, eğer bir Java developer isen
biraz tanıdık olabilecek başka bir konuyu ele alalım: generics’in runtime’da nasıl davrandığı.