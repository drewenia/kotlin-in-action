# Functions with reified type parameters can refer to actual type arguments at run time

Daha önce tartıştığımız gibi, Kotlin generics runtime’da erased edilir; bu da generic bir class’ın bir instance’ına
sahipsen, o instance oluşturulurken kullanılan type argument’ları bulamayacağın anlamına gelir. Aynı durum bir
fonksiyonun type argument’ları için de geçerlidir. Generic bir fonksiyonu call ettiğinde, onun body’si içinde hangi type
argument’larla invocation yapıldığını belirleyemezsin.

```kotlin
fun <T> isA(value: Any) = value is T
// Error: Cannot check for instance of erased type: T
```

Bu genel olarak doğrudur, ancak bu sınırlamanın aşılabildiği bir durum vardır: inline functions. Inline functions’ın
type parameter’ları reified olabilir; bu da runtime’da gerçek type argument’lara referans verebileceğin anlamına gelir.

Bölüm 10.2’de inline functions’ı ayrıntılı olarak tartışmıştık. Bir hatırlatma olarak, bir function’ı inline keyword’ü
ile işaretlersen, compiler function’a yapılan her call’u, function’ı gerçekleştiren gerçek code ile değiştirir.
Function’ı inline yapmak, bu function lambda’ları argument olarak kullanıyorsa performansı artırabilir: lambda code’u da
inline edilebilir, böylece anonymous class oluşturulmaz. Bu bölüm, inline functions’ın faydalı olduğu başka bir durumu
gösteriyor: type argument’larının reified olabilmesi. Önceki `isA` function’ını inline olarak declare eder ve type
parameter’ı reified olarak işaretlersen, value’nun T’nin bir instance’ı olup olmadığını kontrol edebilirsin.

```kotlin
inline fun <reified T> isA(value: Any) = value is T

fun main() {
    val isA = isA<String>("Hello, World!")
    println(isA) // true

    val isAString = isA<String>(123)
    println(isAString) // false
}
```

Reified type parameter’ların kullanımına dair daha az trivial (önemsiz) bazı örneklere bakalım. Reified type
parameter’ların devreye girdiği en basit örneklerden biri, standard library’deki **filterIsInstance** function’ıdır. Bu
function bir collection alır, belirtilen class’ın instance’larını seçer ve yalnızca bu instance’ları döndürür. Aşağıda
nasıl kullanılabileceğini görebilirsiniz.

```kotlin
fun main() {
    // List<Comparable<*> & Serializable> tipindedir
    val items = listOf("One", 2, "three")
    val stringFilter = items.filterIsInstance<String>()
    println(stringFilter) // [One, three]
}
```

Fonksiyon için bir type argument olarak <String> belirterek yalnızca string’lerle ilgilendiğini söylersin. Bu nedenle
fonksiyonun dönüş type’ı List<String> olur. Bu case’te type argument runtime’da bilinir ve filterIsInstance bunu, list
içindeki hangi value’ların type argument olarak belirtilen class’ın instance’ları olduğunu kontrol etmek için kullanır.
Burada, Kotlin standard library’den filterIsInstance declaration’ının basitleştirilmiş bir sürümü yer alır.

```kotlin
// reified, bu type parameter’ın runtime’da erased edilmeyeceğini declare eder.
inline fun <reified T>
        Iterable<*>.filterIsInstance(): List<T> {
    val destination = mutableListOf<T>()
    for (element in this) {
        // element’in, type argument olarak belirtilen class’ın instance’ı olup olmadığını kontrol edebilirsin.
        if (element is T) {
            destination.add(element)
        }
    }
    return destination
}
```

### Why reification works for inline functions only

Bu nasıl çalışır? Neden inline bir function içinde `element is T` yazmana izin verilirken, regular bir class veya
function içinde buna izin verilmez?

10.2 bölümünde tartıştığımız gibi, compiler inline function’ı gerçekleştiren bytecode’u, function’ın call edildiği her
yere ekler. reified bir type parameter ile function’ı her call ettiğinde, compiler o özel call’da type argument olarak
kullanılan exact type’ı bilir. Bu nedenle compiler, type argument olarak kullanılan specific class’a referans veren
bytecode’u üretebilir. Etkili olarak, yukarıda gösterilen `filterIsInstance<String>` call’u için üretilen code
aşağıdakine eşdeğer olacaktır:

```kotlin
for (element in this) {
    // Belirli bir class’a referans verir
    if (element is String) {
        destination.add(element)
    }
}
```

Üretilen bytecode belirli bir class’a referans verdiği için, bir type parameter’a değil, runtime’da gerçekleşen type
argument erasure’dan etkilenmez.

reified type parameter’lara sahip inline function’ların Java code’dan call edilemeyeceğini unutma. Normal inline
function’lar Java tarafından regular function’lar olarak erişilebilirdir — call edilebilirler ancak inline edilmezler.
reified type parameter’lara sahip function’lar, type argument value’larının bytecode içine yerleştirilmesi için ek
processing gerektirir; bu nedenle her zaman inline edilmek zorundadırlar. Bu da, Java code’unun yaptığı gibi onları
regular bir şekilde call etmeyi imkânsız kılar.

___
___

Bir inline function birden fazla reified type parameter’a sahip olabilir ve reified olanlara ek olarak non-reified type
parameter’lar da içerebilir. filterIsInstance function’ının, argument olarak herhangi bir lambda beklemediği hâlde
inline olarak işaretlendiğine dikkat et. 10.2.4 bölümünde, bir function’ı inline olarak işaretlemenin yalnızca function
type parameter’ları olduğunda ve karşılık gelen argument’ler — lambda’lar — function ile birlikte inline edildiğinde
performance faydası sağladığını tartışmıştık. Ancak bu case’te function’ı performance nedenleriyle inline olarak
işaretlemiyorsun; bunun yerine reified type parameter’ların kullanımını mümkün kılmak için bunu yapıyorsun.

İyi performance sağlamak için, inline olarak işaretlenen function’ın size’ını hâlâ takip etmen gerekir. Function büyük
hâle gelirse, reified type parameter’lara bağlı olmayan code’u ayrı non-inline function’lara çıkarmak daha iyidir.