# Restricting the type a generic class or function can use: Type parameter constraints

Type parameter constraint’ler, bir class veya fonksiyon için type argument olarak kullanılabilecek type’ları kısıtlamana
olanak tanır. Örneğin, bir list’in element’lerinin toplamını hesaplayan bir fonksiyonu düşün. Bu, List<Int> veya
List<Double> üzerinde kullanılabilir, ancak örneğin List<String> üzerinde kullanılamaz. Bunu ifade etmek için, sum
fonksiyonunun type parameter’ının bir number olmasını belirten bir type parameter constraint tanımlayabilirsin.

Bir generic type’ın type parameter’ı için bir upper bound constraint olarak bir type belirttiğinde, generic type’ın
belirli instantiation’larındaki ilgili type argument’lar, ya belirtilen type olmalı ya da onun subtype’ı olmalıdır. (
Şimdilik, subtype’ı subclass eşanlamlısı olarak düşünebilirsin. Section 11.3.2 farkı vurgulayacak.)

Bir constraint belirtmek için, type parameter adından sonra iki nokta koyar ve ardından type parameter için upper bound
olan type’ı yazarsın (aşağıdaki resme bak). Java’da aynı kavramı ifade etmek için extends keyword’ü kullanırsın:
`<T extends Number> T sum(List<T> list)`.

![img_2.png](assets/img_2.png)

Bu fonksiyon invocation’ı, actual type argument’in (aşağıdaki example’da Int) abstract class Number’ı extend etmesi
nedeniyle izin verilir; Number, Kotlin standard library’de sayısal değerleri temsil eden tüm class’ların
superclass’ıdır:

```kotlin
fun main() {
    println(listOf(1, 2, 3, 4).sum()) // 10
}
```

Bir type parameter T için bir bound belirledikten sonra, T type’ındaki value’ları upper bound’un type’ı olarak
kullanabilirsin. Örneğin, bound olarak kullanılan class’ta tanımlı method’ları invoke edebilirsin:

```kotlin
// Type parameter upper bound olarak Number’ı belirtir.
fun <T : Number> oneHalf(value: T): Double {
    // Number class’ında tanımlı bir method’u invoke eder.
    return value.toDouble() / 2.0
}

fun main() {
    val oneHalf = oneHalf(3)
    println(oneHalf) // 1.5
}
```

Şimdi, iki item’ın maksimumunu bulan generic bir fonksiyon yazalım. Sadece birbirleriyle karşılaştırılabilen item’ların
maksimumu bulunabileceği için, bunu fonksiyonun signature’ında belirtmen gerekir. Bunu şöyle yaparsın: max fonksiyonunu,
first ve second parameter’ları T type’ında alacak şekilde constrain edersin ve T’yi Comparable<T>’yi implement edecek
şekilde constrain edersin; bu, sadece T ile karşılaştırılabilir object’ların kullanılabileceğini garanti eder.

```kotlin
// Bu fonksiyonun argument’ları comparable element’ler olmalıdır.
fun <T : Comparable<T>> max(first: T, second: T): T {
    return if (first > second) first else second
}

fun main() {
    println(max("kotlin", "java")) // kotlin
}
```

max’i incomparable item’lar üzerinde call etmeye çalıştığında, code compile olmaz:

```kotlin
println(max("kotlin", 42))
// ERROR: Type parameter bound for T is not satisfied:
// inferred type Any is not a subtype of Comparable<Any>
```

T için upper bound, generic type Comparable<T>’dir. Daha önce gördüğün gibi, String class’ı Comparable<String>’i extend
eder; bu da String’i max fonksiyonu için geçerli bir type argument yapar.

Unutma, kısa biçim olan first > second, Kotlin operator convention’larına göre first.compareTo(second) > 0 olarak
compile edilir; bunu section 9.2.2’de gördün. Bu karşılaştırma mümkündür çünkü first’in type’ı olan T, Comparable<T>’yi
extend eder ve böylece first’i başka bir T type’ındaki element ile karşılaştırabilirsin.

Nadir bir durumda bir type parameter üzerinde birden fazla constraint belirtmen gerektiğinde, biraz farklı bir sözdizimi
kullanırsın. Örneğin, aşağıdaki code, verilen CharSequence’in sonunda bir period olup olmadığını garanti etmek için
generic bir yoldur. Bu durumda, type argument olarak kullanılan type’ın hem CharSequence hem de Appendable
interface’lerini implement etmesi gerektiğini belirtirsin. Bu, hem veriye erişen operation’ı (endsWith) hem de onu
değiştiren operation’ı (append) o type’daki value’larla kullanabileceğin anlamına gelir. Hem CharSequence hem de
Appendable’ı implement eden bir class, karakterlerin mutable sequence’ini temsil eden StringBuilder class’ıdır (
StringBuilder ile kısa bir şekilde section 3.2’de karşılaşmıştın).

```kotlin
fun <T> ensureTrailingPeriod(seq: T)
// Type parameter constraint’larının listesi
        where T : CharSequence, T : Appendable {
    // CharSequence interface’i için defined edilmiş bir extension function’ı call eder.
    if (!seq.endsWith('.')) {
        // Appendable interface’inden method’u call eder.
        seq.append('.')
    }
}

fun main() {
    val helloWorld = StringBuilder("Hello World")
    ensureTrailingPeriod(helloWorld)
    println(helloWorld) // Hello World.
}
```

Bu fonksiyon, Kotlin'deki Generic Constraints (Generic Kısıtlamalar) konusunun en ileri seviye örneklerinden biridir.
Buradaki anahtar kelime where bloğudur. Normalde bir generic tipi tek bir sınıfa kısıtlamak için `<T : CharSequence>`
yazarız. Ancak bir tipin aynı anda iki farklı interface'i desteklemesini istiyorsak `where` kullanmak zorundayız.

where T : CharSequence, T : Appendable ifadesi şu anlama gelir:

* "Bu fonksiyona göndereceğin seq nesnesi hem okunabilir bir metin (CharSequence) olmalı, hem de içeriği
  değiştirilebilir/ekleme yapılabilir (Appendable) olmalı."

* CharSequence: Bize endsWith, length, get gibi "okuma" özelliklerini sağlar.

* Appendable: Bize .append() gibi "yazma/ekleme" özelliklerini sağlar.

Şimdi, type parameter constraint’ların yaygın olduğu başka bir durumu ele alacağız: non-null type parameter declare
etmek istediğinde.