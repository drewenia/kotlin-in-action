# Reified type parameters come with restrictions

reified type parameters kullanışlı bir araç olsa da, belirli kısıtlamalara sahiptir. Bazıları concept’in doğasından
kaynaklanır, diğerleri ise mevcut implementation tarafından belirlenmiştir ve Kotlin’in future versions’larında
gevşetilebilir.

Daha spesifik olarak, bir reified type parameter’ı şu şekilde kullanabilirsin:

* Type check ve cast işlemlerinde (is, !is, as, as?)

* Kotlin reflection API’lerini kullanmak için, ki bunu 12. bölümde (::class) tartışacağız

* İlgili java.lang.Class’ı almak için (::class.java)

* Diğer functions’ları çağırmak için bir type argument olarak

Aşağıdakinleri yapamazsın:

* Type parameter olarak belirtilen class’ın yeni instance’larını oluşturmak

* Type parameter class’ının companion object’i üzerindeki method’ları çağırmak

* reified type parameter kullanan bir function’ı çağırırken, reified olmayan bir type parameter’ı type argument olarak
  kullanmak

* class’ların veya non-inline functions’ların type parameter’larını reified olarak işaretlemek

Son kısıtlama ilginç bir sonuca yol açar: reified type parameter’lar yalnızca inline functions içinde kullanılabildiği
için, bir reified type parameter kullanmak, function’ın ve ona geçirilen tüm lambdaların inline edilmesi anlamına gelir.
Eğer lambdalar, inline function’ın onları kullanma şekli nedeniyle inline edilemiyorsa ya da performans sebepleriyle
inline edilmelerini istemiyorsan, 10.2.2 bölümünde tanıtılan noinline modifier’ını kullanarak onları non-inlineable
olarak işaretleyebilirsin.

Artık generics’in bir language feature olarak nasıl çalıştığını tartıştığımıza göre, subtyping ve variance kavramlarını
inceleyelim. Bunu, her Kotlin programında karşımıza çıkan en yaygın generic type’lara, yani collections ve onların
subclass’larına daha detaylı bir bakış atarak yapacağız.