# Applying a predicate to a collection: all, any, none, count, and find

Bir collection’daki tüm element’lerin, bazılarının ya da hiçbirinin belirli bir koşulla eşleşip eşleşmediğini kontrol
etmek de yaygın bir görevdir. Kotlin’de bu, all, any ve none function’ları kullanılarak ifade edilir. count function,
predicate’i sağlayan element’lerin sayısını kontrol eder ve find function, eşleşen ilk element’i döndürür.
Bu function’ları göstermek için, bir kişinin 27 ya da daha genç olup olmadığını kontrol eden canBeInClub27 predicate’ini
tanımlayalım:

Eğer tüm element’lerin bu predicate’i sağlayıp sağlamadığını merak ediyorsanız, ```all``` function’ı kullanırsınız:

```kotlin
fun main() {
    val people = listOf(
        Person("Alex", 24),
        Person("Dimitri", 39),
        Person("Ocean", 19),
        Person("Ari", 24),
    )

    val canBeInClub27 = { p: Person -> p.age <= 27 }
    println(people.all(canBeInClub27)) // false
}

data class Person(val name: String, val age: Int)
```

En az bir tane eşleşen element olup olmadığını kontrol etmeniz gerekiyorsa, ```any``` kullanın:

```kotlin
fun main() {
    val people = listOf(
        Person("Alex", 24),
        Person("Dimitri", 39),
        Person("Ocean", 19),
        Person("Ari", 24),
    )

    val canBeInClub27 = { p: Person -> p.age <= 27 }
    println(people.any(canBeInClub27)) // true
}

data class Person(val name: String, val age: Int)
```

Dikkat edin, bir koşulla birlikte kullanılan !all (“not all”), o koşulun olumsuzlamasıyla birlikte any kullanılarak
değiştirilebilir ve bunun tersi de geçerlidir. Kodunuzu daha kolay anlaşılır kılmak için, önüne bir negation işareti
koymanızı gerektirmeyen bir function seçmelisiniz.

```kotlin
fun main() {
    val list = listOf(1, 2, 3)

    // Negation işareti ! fark edilmesi zor olduğu için, bu durumda any kullanmak daha iyidir.
    println(!list.all { it == 3 }) // true

    // Argument içindeki condition, kendi karşıtına değiştirilmiştir.
    println(list.any { it != 3 }) // true
}
```

İlk kontrol, tüm element’lerin 3’e eşit olmadığından emin olur. Bu, en az bir tane 3 olmayan element olmasıyla aynıdır;
ikinci satırda any kullanarak kontrol edilen de budur.

Benzer şekilde, !any ifadesini none ile değiştirebilirsiniz:

```kotlin
fun main() {
    val list = listOf(1, 2, 3)

    // any çağrısını kullanıp sonucunu olumsuzlamak yerine …
    println(!list.any { it == 4 }) // true

    // aynı condition ile none kullanabiliriz.
    println(list.none { it == 4 }) // true
}
```

İlk invocation, collection’daki herhangi bir element’in 4’e eşit olup olmadığını kontrol eder ve bu sonucu olumsuzlar.
Bunu hem kodda hem de sözle ifade etmenin daha doğal yolu, element’lerin hiçbirinin 4’e eşit olup olmadığını kontrol
etmektir.

### Predicates and empty collections

any, none ve all gibi farklı predicate türlerinin açıklamasını okurken, bu function’ların empty collection’lar üzerinde
çağrıldığında ne döndürdüğünü merak etmeye başlamış olabilirsiniz. Bu gizemi ele alalım.

any durumunda, collection sağlanan predicate’i sağlayabilecek hiçbir element içermez. Bu da false döndürdigi anlamına
gelir:

```kotlin
fun main() {
    println(emptyList<Int>().any { it > 42 }) // false
}
```

Ayrıca bu snippet’in, Kotlin’de empty list oluşturmanın daha ifade gücü yüksek bir yolunu gösterdiğini de unutmayın:
emptyList function aracılığıyla.

Gördüğünüz gibi, none function any function’ın tersidir. Bu durum empty collection case’inde de geçerlidir: predicate’i
ihlal edebilecek hiçbir element yoktur, bu yüzden function true döndürür:

```kotlin
fun main() {
    println(emptyList<Int>().none { it > 42 }) // true
}
```

Belki de zihni en çok zorlayıcı potansiyele sahip olan function all’dır. Predicate’ten bağımsız olarak, empty collection
üzerinde çağrıldığında true döndürür:

```kotlin
fun main() {
    println(emptyList<Int>().all { it > 42 }) // true
}
```

Bu ilk başta sizi şaşırtabilir, ancak biraz daha incelediğinizde bunun oldukça makul bir return value olduğunu
göreceksiniz. Predicate’i ihlal eden bir element adlandıramazsınız, dolayısıyla predicate açıkça collection’daki tüm
element’ler için true olmak zorundadır — hiç element olmasa bile! Bu kavram vacuous truth olarak bilinir ve çoğu durumda
empty collection’larla da çalışması gereken conditionals için gerçekten iyi bir uyum sağlar.

___
___

Bir predicate’i kaç element’in sağladığını bilmek istiyorsanız, count kullanın:

```kotlin
fun main() {
    val people = listOf(
        Person("Derek", 31),
        Person("Jim", 24),
        Person("Ari", 21),
        Person("David", 43),
    )

    val canBeInClub27 = { p: Person -> p.age <= 27 }
    val count = people.count(canBeInClub27)
    println(count) // 2
}

data class Person(val name: String, val age: Int)
```

### Using the right function for the job: count vs. size

count’u unutmak ve bunu collection’ı filtreleyip size’ını alarak implement etmek kolaydır:

```kotlin
fun main() {
    val people = listOf(
        Person("Derek", 31),
        Person("Jim", 24),
        Person("Ari", 21),
        Person("David", 43),
    )

    val canBeInClub27 = { p: Person -> p.age <= 27 }
    val size = people.filter(canBeInClub27).size
    println(size) // 2
}
```

Ancak bu durumda, predicate’i sağlayan tüm element’leri saklamak için bir intermediate collection oluşturulur. Öte
yandan, count method’u yalnızca eşleşen element’lerin sayısını takip eder, element’lerin kendisini değil; bu nedenle
daha etkilidir. Genel bir kural olarak, ihtiyaçlarınıza en uygun operation’ı bulmaya çalışın.

___
___

Predicate’i sağlayan bir element bulmak için find function’ı kullanın:

```kotlin
fun main() {
    val people = listOf(
        Person("Derek", 31),
        Person("Jim", 24),
        Person("Ari", 21),
        Person("David", 43),
    )

    val canBeInClub27 = { p: Person -> p.age <= 27 }
    val find = people.find(canBeInClub27)
    println(find) // Person(name=Jim, age=24)
}
```

Bu, birden fazla eşleşme varsa ilk eşleşen element’i, hiçbir şey predicate’i sağlamıyorsa null döndürür. find’ın bir
eşanlamlısı firstOrNull’dur; eğer fikri sizin için daha net ifade ediyorsa onu kullanabilirsiniz. Listede predicate'i
sağlayan iki kişi olduğu halde sadece ilk bulduğunu döndürür.