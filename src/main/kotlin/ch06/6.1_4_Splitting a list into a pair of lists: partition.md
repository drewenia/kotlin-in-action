# Splitting a list into a pair of lists: partition

Bazı durumlarda, bir collection’ı verilen bir predicate’e göre iki gruba ayırmanız gerekir: Boolean predicate’i sağlayan
element’ler ve sağlamayanlar. Her iki gruba da ihtiyacınız varsa, bu iki list’i oluşturmak için filter ve onun kardeş
function’ı olan filterNot’u (predicate’i tersine çevirir) kullanabilirsiniz. Bu örnekte, kulübe kimlerin girmesine izin
verildiğini — ve kimlerin verilmediğini — buluyorsunuz:

```kotlin
fun main() {
    val people = listOf(
        Person("Derek", 26),
        Person("Jim", 29),
        Person("Ari", 21),
        Person("David", 43),
    )

    val canBeInClub27 = { p: Person -> p.age <= 27 }
    val comeIn = people.filter(canBeInClub27)
    val comeOut = people.filterNot(canBeInClub27)

    println(comeIn) // [Person(name=Derek, age=26), Person(name=Ari, age=21)]
    println(comeOut) // [Person(name=Jim, age=29), Person(name=David, age=43)]
}

data class Person(val name: String, val age: Int)
```

Ancak bunu yapmanın daha öz bir yolu da vardır: partition function’ı kullanmak. Bu function, predicate’i tekrar etmek
zorunda kalmadan ve input collection üzerinde iki kez iteration yapmadan bu list pair’ini döndürür. Bu da, önceki kod
snippet’ındaki aynı mantığı aşağıdaki gibi ifade edebileceğiniz anlamına gelir:

![img_6.png](img_6.png)

partition function, verilen Boolean predicate’i sağlayanlar ve sağlamayanlardan oluşan iki list’ten meydana gelen bir
pair döndürür.

```kotlin
fun main() {
    val people = listOf(
        Person("Derek", 26),
        Person("Jim", 29),
        Person("Ari", 21),
        Person("David", 43),
    )

    val canBeInClub27 = { p: Person -> p.age <= 27 }

    /* destructuring declaration, döndürülen list pair’ini Boolean predicate’e göre iki variable’a ayırma işini 
    üstlenir.*/
    val (comeIn, stayOut) = people.partition(canBeInClub27)
    println(comeIn) // [Person(name=Derek, age=26), Person(name=Ari, age=21)]
    println(stayOut) // [Person(name=Jim, age=29), Person(name=David, age=43)]
}
```