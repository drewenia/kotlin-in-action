# Safely casting values without throwing exceptions: as?

Chapter 2'de, type cast’ler için kullanılan normal Kotlin operator’ünü görmüştün: as operator’ü. Normal bir Java type
cast’i gibi, as, value cast etmeye çalıştığın type’a sahip değilse bir ClassCastException fırlatır. Elbette, uygun
type’a sahip olduğundan emin olmak için bunu bir is check’i ile birleştirebilirsin. Ancak safe ve concise bir dil olarak
Kotlin daha iyi bir çözüm sunmuyor mu? Elbette sunuyor.

as? operator’ü, bir value’yu belirtilen type’a cast etmeye çalışır ve value uygun type’a sahip değilse null döndürür:

Safe-cast operator as?, bir cast işleminin başarılı olmayabileceği olasılığıyla safe bir şekilde çalışman için gerekli
araçları sağlar. Bir value’yu verilen type’a cast etmeye çalışır ve type farklıysa null döndürür:

![img_3.png](assets/img_3.png)

Safe-cast kullanımının yaygın bir pattern’i, aşağıdaki code'da gösterildiği gibi, onu Elvis operator ile
birleştirmektir. Örneğin, bu pattern equals method’unu implement etmek için kullanışlıdır.

```kotlin
class Person(val firstName: String, val lastName: String) {
    override fun equals(other: Any?): Boolean {
        // Type’ı check eder ve eşleşme yoksa false return eder.
        val otherPerson = other as? Person ?: return false

        // Safe-cast’ten sonra, otherPerson variable’ı Person type’ına smart cast edilir.
        return otherPerson.firstName == firstName &&
                otherPerson.lastName == lastName
    }

    override fun hashCode(): Int = firstName.hashCode() * 31 + lastName.hashCode()
}

fun main() {
    val p1 = Person("Dimitri", "Jemerov")
    val p2 = Person("Dimitri", "Jemerov")

    println(p1 == null) // false
    println(p1 == p2) // true
    println(p1.equals(42)) // false
}
```

Bu pattern ile, parameter’ın uygun bir type’a sahip olup olmadığını kolayca check edebilir, onu cast edebilir ve type
doğru değilse false return edebilirsin — hepsi aynı expression içinde. Elbette, smart cast’ler bu context’te de
geçerlidir: type’ı check edip null value’ları reddettikten sonra, compiler otherPerson variable’ının value’sunun Person
type’ında olduğunu bilir ve buna göre kullanmana izin verir.

Safe-call, safe-cast ve Elvis operator’leri kullanışlıdır ve Kotlin code’unda sıkça görülür. Ancak bazen, null
value’ları ele almak için Kotlin’in desteğine ihtiyacın olmaz; yalnızca compiler’a value’nun aslında null olmadığını
söylemen gerekir. Bunun nasıl yapılabileceğine bakalım.

Examples;

```kotlin
fun main() {
    val obj: Any = 42 // bu bir int
    
    // 'as?' kullandığımız için type uyuşmadığında 'result' null olur.
    val result : String? = obj as? String
    println(result) // null
}
```

```kotlin
fun main() {
    printLength(123) // null
    printLength("John Doe") // 8
}

fun printLength(input: Any) {
    val length = (input as? String)?.length
    println(length)
}
```

```kotlin
fun main() {
    val animal = Animal()

    // Hiçbir şey olmaz (Crash olmaz çünkü as? null döndürür)
    makeItBark(animal)

    val animal2 = Dog()
    makeItBark(animal2) // Woof
}

open class Animal

class Dog : Animal() {
    fun bark() = println("Woof")
}

fun makeItBark(animal: Animal) {
    (animal as? Dog)?.bark()
}
```