# Introduction to lambdas: Blocks of code as values

Code’unda behavior parçalarını geçirmek ve saklamak sık yapılan bir iştir. Örneğin, sıklıkla şu tür ifadeleri belirtmen
gerekir: “Bir event gerçekleştiğinde, bu handler’ı çalıştır” veya “Bu operation’ı bir data structure içindeki tüm
element’lere uygula.” Java’nın eski sürümlerinde bunu anonymous inner class’lar aracılığıyla yapabilirdin. Anonymous
inner class’lar işi görse de, verbose bir syntax gerektirir. Bu problemi çözmenin bir başka yaklaşımı: functions'ları
values olarak ele alma yeteneğidir. Bir class declare etmek ve o class'ın bir instance'ını bir function'a geçirmek
yerine, function'ı doğrudan geçirebilirsiniz. Lambda expressions ile kod daha da kısa olur. Bir function declare
etmenize gerek yok; bunun yerine, etkili bir şekilde bir kod bloğunu doğrudan function parameter olarak
geçirebilirsiniz. Functions'ları value olarak ele alma ve functions'ları birleştirerek behavior ifade etme yaklaşımı,
functional programming'in temel dayanaklarından biridir.

Functional programming hakkında hızlı bir hatırlatma, Kotlin’in çok paradigmalı bir language olarak doğasını ve
functional programming’in projelerinize sağlayabileceği faydaları ele almıştık: kısa ve öz olma, immutability’ye
odaklanma ve daha güçlü bir abstraction gücü. Hafızanızı tazelemek için, functional programming’in bazı ayırt edici
özellikleri tekrar şunlardır:

* First-class functions — Functions (behavior parçaları) value olarak ele alınır. Onları variable’larda saklayabilir,
  parameter olarak geçirebilir veya diğer functions’lardan return edebilirsiniz. Lambdas, bu bölümde keşfedeceğiniz
  gibi, Kotlin’in functions’ları first-class citizens olarak rahatça ele almayı sağlayan language özelliklerinden
  biridir.

* Immutability — Objects’lerinizi, yaratıldıktan sonra internal state’lerinin değişemeyeceğini garanti edecek şekilde
  tasarlarsınız: mutate olamazlar.

* No side effects — Functions’larınızı, aynı input verildiğinde aynı sonucu return edecek ve diğer objects veya dış
  dünya üzerindeki state’i değiştirmeyecek şekilde yapılandırırsınız. Bu tür functions’lara pure denir.

Lambda expressions kullanımının gerçekten öne çıktığı bir örneğe bakalım. Bir butona tıklama behavior’ını tanımlamanız
gerektiğini düşünün. Bunu yapmak için, bir Button object, tıklamayı handle etmek üzere ilgili OnClickListener
interface’inin bir instance’ını geçirmenizi isteyebilir. Bu interface tek bir method, onClick, belirtir. Kotlin’de bunu,
bir object declaration kullanarak implement edebilirsiniz.

```kotlin
button.setOnClickListener(object: OnClickListener {
    override fun onClick(v: View) {
        println("I was clicked!")
    }
})
```

Böyle bir object declare etmenin gerektirdiği uzunluk, birçok kez tekrarlandığında rahatsız edici hale gelir. Sadece
behavior’ı — tıklama sırasında ne yapılması gerektiğini—ifade eden bir gösterim, gereksiz kodu ortadan kaldırmanıza
yardımcı olur: önceki snippet’i bir lambda kullanarak yeniden yazabilirsiniz.

```kotlin
button.setOnClickListener {println("I was clicked!")}
```

Bu Kotlin code, anonymous object kullanmakla aynı şeyi yapar, ancak daha kısa ve okunabilir bir şekilde. Bu örneğin
detaylarını (ve neden OnClickListener gibi bir interface’i implement etmek için kullanılabileceğini) bu bölümün
ilerleyen kısımlarında tartışacağız. Bir lambda’nın sadece bir method’a sahip anonymous object yerine nasıl
kullanılabileceğini gördünüz. Şimdi devam edelim ve lambda expressions’ın klasik bir başka kullanımını kısaca
keşfedelim: collections ile çalışma.