# Kotlin makes number conversions explicit

Kotlin ile Java arasındaki önemli farklardan biri, numeric conversion’ları ele alış biçimleridir. Kotlin, bir number’ı
bir type’tan diğerine otomatik olarak dönüştürmez; hatta value’yu assign ettiğin type daha büyük olsa ve assign etmeye
çalıştığın value’yu rahatlıkla tutabilecek durumda olsa bile. Örneğin, aşağıdaki kod Kotlin’de compile edilmez:

```kotlin
fun main() {
    val i = 1
    val l: Long = i // Error: type mismatch
}
```

Bunun yerine, conversion’ı explicitly uygulaman gerekir:

```kotlin
fun main() {
    val i = 1
    val l: Long = i.toLong()
}
```

Her primitive type için (Boolean hariç) conversion function’ları tanımlanmıştır: toByte(), toShort(), toChar() vb. Bu
function’lar her iki yönde de conversion’ı destekler: Int.toLong() gibi daha küçük bir type’ı daha büyük bir type’a
genişletme ve Long.toInt() gibi daha büyük bir type’ı daha küçük bir type’a kırpma. Kotlin, özellikle boxed value’lar
compared edilirken sürprizleri önlemek için conversion’ı explicit yapar. İki boxed value için equals method’u, yalnızca
içinde saklanan value’yu değil, box type’ını da kontrol eder. Bu nedenle Java’da

```
Integer.valueOf(42).equals(Long.valueOf(42))
```

false döner. Kotlin implicit conversion’ları destekleseydi, buna benzer bir şey yazabilirdin:

```kotlin
fun main() {
    val x = 1 // Int variable
    val list = listOf(1L, 2L, 3L) // List of Long value
    x in list // False if Kotlin supported implicit conversions
}
```

Bu, beklentilerin aksine false olarak evaluate edilirdi. Bu nedenle bu örnekteki x in list satırı compile etmez. Kotlin,
yalnızca aynı type’a sahip value’ların compared edilmesi için type’ları explicit olarak convert etmeni zorunlu kılar.

```kotlin
fun main() {
    val x = 1 // Int variable
    val list = listOf(1L, 2L, 3L) // List of Long value
    println(x.toLong() in list) // true
}
```

Kodunda aynı anda farklı number type’lar kullanıyorsan, beklenmeyen behavior’lardan kaçınmak için variable’ları explicit
olarak convert etmen gerekir.

### Primitive type literals

Kotlin, basit decimal number’lara ek olarak source code içinde number literal’larını yazmak için aşağıdaki yolları
destekler:

* Long type’ına ait literal’lar L suffix’i kullanır: 123L.

* Double type’ına ait literal’lar floating-point number’ların standart gösterimini kullanır: 0.12, 2.0, 1.2e10 ve
  1.2e-10.

* Float type’ına ait literal’lar f veya F suffix’ini kullanır: 123.4f, .456F ve 1e3f.

* Hexadecimal literal’lar 0x veya 0X prefix’ini kullanır (örneğin, 0xCAFEBABE veya 0xbcdL).

* Binary literal’lar 0b veya 0B prefix’ini kullanır (örneğin, 0b000000101).

* Unsigned number literal’lar U suffix’ini kullanır: 123U, 123UL ve 0x10cU.

* Character literal’lar için çoğunlukla Java’dakiyle aynı syntax’ı kullanırsın. Character’ı tek tırnak içinde yazarsın
  ve gerekirse escape sequence’leri de kullanabilirsin. Aşağıdakiler geçerli Kotlin character literal’larına örnektir: '
  1', '\t' (tab character’ı) ve '\u0009' (Unicode escape sequence kullanılarak temsil edilen tab character’ı).

___
___

Bir number literal yazarken genellikle conversion function’larını kullanman gerekmez. Bir seçenek, 42L veya 42.0f gibi
constant’ın type’ını explicit olarak işaretlemek için özel syntax’ı kullanmaktır. Bunu kullanmasan bile, bilinen bir
type’a sahip bir variable’ı initialize etmek için bir number literal kullandığında veya bunu bir function’a argument
olarak verdiğinde gerekli conversion otomatik olarak uygulanır. Ayrıca, arithmetic operator’lar uygun olan tüm numeric
type’ları kabul edecek şekilde overloaded edilmiştir. Örneğin, aşağıdaki kod herhangi bir explicit conversion olmadan
doğru şekilde çalışır:

```kotlin
fun printALong(l: Long) = println(l)

fun main() {
    // Constant value doğru type’ı alır.
    val b: Byte = 1

    // + Byte ve Long argument’ları ile çalışır.
    val l = b + 1L

    printALong(l) // 2

    // Compiler, 42’yi bir Long value olarak yorumlar.
    printALong(42) // 42
}
```

Kotlin arithmetic operator’larının number-range overflow ve underflow ile ilgili behavior’ı Java’dakiyle tamamen
aynıdır; Kotlin herhangi bir ek overflow kontrolü getirmez.

```kotlin
fun main() {
    val intMaxValue = Int.MAX_VALUE
    val overMaxValue = Int.MAX_VALUE + 1

    println(intMaxValue) // 2147483647
    println(overMaxValue) // -2147483648

    val intMinValue = Int.MIN_VALUE
    val overMinValue = Int.MIN_VALUE - 1

    println(intMinValue) // -2147483648
    println(overMinValue) // 2147483647
}
```

### Conversion from String

Kotlin standard library, bir string’i primitive type’a dönüştürmek için bir dizi extension function sağlar: toInt,
toByte, toBoolean vb. Bu function’ların her biri string’in içeriğini karşılık gelen type olarak parse etmeye çalışır ve
parse işlemi başarısız olursa bir NumberFormatException fırlatır:

```kotlin
fun main() {
    println("42".toInt()) // 42
}
```

Ancak string’den primitive type’a conversion’ın sık sık başarısız olmasını bekliyorsan, NumberFormatException’ı her
seferinde explicit olarak handle etmek zahmetli olabilir. Bu case için, bu extension function’ların her birinin
conversion başarısız olduğunda null dönen bir karşılığı da vardır: toIntOrNull, toByteOrNull vb.

```kotlin
fun main() {
    println("seven".toIntOrNull()) // null
}
```

Özel bir case, string’lerin Boolean value’lara conversion’ıdır. Bu conversion function’ları, 7. bölümde tanıtıldığı gibi
nullable receiver üzerinde tanımlanmıştır. toBoolean function’ı, üzerinde call yapıldığı string null değilse ve içeriği
true kelimesine (büyük/küçük harf farkını göz ardı ederek) eşitse true döner. Aksi halde false döner.

```kotlin
fun main() {
    val isTrue = "trUE".toBoolean()
    println(isTrue) // true

    val test = "eurt".toBoolean()
    println(test) // false

    println("1".toBoolean()) // false
}
```

Conversion sırasında string’ler üzerinde "true" ve "false" için exact match istiyorsan, yalnızca bu iki value’yu kabul
eden ve aksi halde exception fırlatan toBooleanStrict function’ını kullan.

```kotlin
fun main() {
    println("true".toBooleanStrict()) // true
    println("TRUE".toBooleanStrict()) // java.lang.IllegalArgumentException
    println("trUE".toBooleanStrict()) // java.lang.IllegalArgumentException
    println("false".toBooleanStrict()) // false
}
```

___
___

Diğer type’lara geçmeden önce, değinmemiz gereken üç özel type daha vardır: Any, Unit ve Nothing.