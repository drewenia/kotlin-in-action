# Collections declared in Java are seen as platform types in Kotlin

Bu bölümdeki nullability tartışmasını hatırlarsan, Java kodunda tanımlanmış type’ların Kotlin’de platform type olarak
görüldüğünü hatırlarsın. Platform type’lar için Kotlin nullability bilgisinden yoksundur, bu nedenle compiler, Kotlin
kodunun onları nullable veya non-null olarak ele almasına izin verir. Benzer şekilde, Java’da declare edilmiş collection
type’larına sahip variable’lar da platform type olarak görülür. Platform type’a sahip bir collection, özünde unknown
mutability’ye sahip bir collection’dır—Kotlin kodu onu read-only veya mutable olarak ele alabilir. Genellikle bu önemli
değildir, çünkü yapmak isteyebileceğin tüm operation’lar etkili bir şekilde çalışır.

Fark, imzasında collection type’ı olan bir Java method’unu override veya implement ederken önem kazanır. Burada,
nullability için platform type’larda olduğu gibi, override veya implement ettiğin method’tan gelen Java type’ını temsil
etmek için hangi Kotlin type’ını kullanacağına karar vermen gerekir. Bu durumda birden fazla seçim yapman gerekir ve
bunların tümü Kotlin’de oluşacak parameter type’ına yansır:

* Collection nullable mı?

* Collection içindeki element’ler nullable mı?

* Method’un collection’ı değiştirecek mi?

Farkı görmek için, aşağıdaki durumları ele alalım. İlk örnekte, bir Java interface, bir dosyadaki text’i işleyen bir
object’i represent eder.

```java
/* Java */
interface FileContentProcessor {
    void processContents(
            File path,
            byte[] binaryContents,
            List<String> textContents
    );
}
```

Bu interface’in bir Kotlin implementasyonu, aşağıdaki seçimleri yapmalıdır:

* Liste nullable olacak, çünkü bazı dosyalar binary ve içerikleri text olarak represent edilemez.

* Listedeki element’ler non-nullable olacak, çünkü bir dosyadaki satırlar hiçbir zaman null değildir.

* Liste read-only olacak, çünkü dosyanın içeriğini represent ediyor ve bu içerik değiştirilmeyecek.

Bu implementasyon şöyle görünür:

```kotlin
class FileIndexer : FileContentProcessor {
    override fun processContents(
        path: File,
        binaryContents: ByteArray?,
        textContents: List<String>?
    ) {
        // ...
    }
}
```

Bunu başka bir interface ile karşılaştır. Burada, interface’in implementasyonları, data'yı text formundan bir object
listesine parse eder, bu object’leri output listesine ekler ve parsing sırasında tespit edilen hataları ayrı bir listeye
mesaj olarak ekleyerek raporlar.

```java
/* Java */
interface DataParser<T> {
    void parseData(
            String input,
            List<T> output,
            List<String> errors
    );
}
```

Bu durumda yapılan seçimler farklıdır:

* List<String> non-null olacak, çünkü caller’lar her zaman error message’ları almak zorundadır.

* Listedeki element’ler nullable olacak, çünkü output list’teki her item’ın ilişkili bir error message’ı olmayabilir.

* List<String> mutable olacak, çünkü implementing code element eklemek zorundadır.

```kotlin
class PersonParser : DataParser<Person> {
    override fun parseData(
        input: String,
        output: MutableList<Person>,
        errors: MutableList<String?>
    ) {
        TODO("Not yet implemented")
    }
}

data class Person(val name: String, val age: Int)
```

Aynı Java type — List<String> — iki farklı Kotlin type ile temsil ediliyor: bir durumda List<String>? (nullable string
listesi) ve diğer durumda MutableList<String?> (nullable string element’leri olan mutable liste). Bu seçimleri doğru
yapmak için, Java interface veya class’ın takip etmesi gereken kesin contract’ı bilmelisin. Bu genellikle
implementasyonunun ne yapması gerektiğine bakılarak kolayca anlaşılır.

Artık collection’ları tartıştığımıza göre, array’lara bakalım. Daha önce de belirttiğimiz gibi, varsayılan olarak
array’lar yerine collection kullanmayı tercih etmelisin. Ancak birçok Java API hâlâ array kullandığı için, Kotlin’de
onlarla nasıl çalışılacağını ele alacağız.