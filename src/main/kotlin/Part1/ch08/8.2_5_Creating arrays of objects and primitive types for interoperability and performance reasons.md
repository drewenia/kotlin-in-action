# Creating arrays of objects and primitive types for interoperability and performance reasons

Kotlin yolculuğunun başlarında array’larla zaten karşılaşmıştın, çünkü bir array, Kotlin main function’unun imzasının
bir parçası olabilir. İşte nasıl göründüğüne dair bir hatırlatma.

```kotlin
fun main(args: Array<String>) {
    /* Array’in indices extension property’sini kullanarak index aralığında iterate eder. */
    for (i in args.indices) {
        // Element’lere index ile array[index] şeklinde erişir.
        println("Argument $i is: ${args[i]}")
    }
}
```

Kotlin’de bir array, type parameter’a sahip bir class’tır ve element type, karşılık gelen type argument olarak
belirtilir. Kotlin’de array oluşturmak için şu seçeneklere sahipsin:

* arrayOf function’ı, bu function’a argument olarak verilen element’leri içeren bir array oluşturur.

* arrayOfNulls function’ı, belirtilen boyutta null element’ler içeren bir array oluşturur. Tabii ki, yalnızca element
  type’ı nullable olan array’lar için kullanılabilir.

* Array constructor, array’in boyutunu ve bir lambda alır ve her array element’ini lambda’yı çağırarak başlatır. Bu, her
  element’i ayrı ayrı geçmeden non-null element type’lı bir array’i başlatmanın yoludur.

Basit bir örnek olarak, Array function’ını kullanarak "a"dan "z"ye bir string array’i nasıl oluşturabileceğin:

```kotlin
fun main(args: Array<String>) {
    val letters = Array(26) { i -> ('a' + i).toString() }
    println(letters.joinToString(""))
    // abcdefghijklmnopqrstuvwxyz
}
```

Lambda, array element’inin index’ini alır ve o index’e yerleştirilecek value’yu döndürür. Burada, değeri 'a' karakterine
index’i ekleyip sonucu string’e çevirerek hesaplıyorsun. Bu tür bir yapı aslında yalnızca array’lara özgü değildir.
Kotlin, element’lerini size parameter’ı ve bir initialization lambda’sı temel alarak instantiate eden List ve
MutableList function’ları da sağlar.

Bunu söyledikten sonra, Kotlin kodunda array oluşturmanın en yaygın case'lerinden biri, bir Java method’u çağırman
gerektiğinde veya vararg parameter’ı olan bir Kotlin function’ı çağırman gerektiğinde olur, aşağıdaki code’da
gösterildiği gibi. Bu durumlarda, verilerin genellikle zaten bir collection içinde saklandığını görürsün ve sadece onu
array’e dönüştürmen gerekir. Bunu toTypedArray method’u ile yapabilirsin.

```kotlin
fun main(args: Array<String>) {
    val strings = listOf("a", "b", "c")
    /* Vararg parameter’lar beklendiğinde, bir array’i geçirmek için spread operator (*) kullanılır. */
    println("%s|%s|%s".format(*strings.toTypedArray())) // a|b|c
}
```

Diğer türlerde olduğu gibi, array türlerinin type argument’leri her zaman object türlerine dönüşür. Bu nedenle, eğer
`Array<Int>` gibi bir şey declare ederseniz, bu boxed integer’lardan oluşan bir array’e dönüşür (Java türü
`java.lang.Integer[]` olacaktır). Eğer boxing olmadan primitive türdeki değerlerden oluşan bir array oluşturmanız
gerekiyorsa, primitive türler için özel array sınıflarından birini kullanmalısınız.

Primitive türlerin array’lerini represent etmek için, Kotlin her primitive tür için ayrı sınıflar sağlar. Örneğin, Int
türündeki değerlerden oluşan bir array IntArray olarak adlandırılır. Diğer türler için Kotlin ByteArray, CharArray,
BooleanArray ve benzerlerini sağlar. Tüm bu türler normal Java primitive tür array’lerine compile edilir, örneğin int[],
byte[], char[] ve benzeri. Bu nedenle, bu tür bir array’deki değerler boxing olmadan, mümkün olan en verimli şekilde
saklanır.

Boxing’i önleyen diğer number türü array’leri gibi, Kotlin ayrıca UByteArray, UShortArray, UIntArray ve ULongArray gibi
unsigned türlerin array’lerini oluşturmanıza da izin verir. Yazının yazıldığı tarihte, unsigned array’ler ve
üzerlerindeki operation’lar henüz stable değildir.

Primitive türde bir array oluşturmak için aşağıdaki seçeneklere sahipsiniz:

* Type’ın constructor’ı bir `size` parametresi alır ve ilgili primitive tür için varsayılan değerlerle (genellikle
  sıfırlar) initialize edilmiş bir array döner.

* Factory function (IntArray için intArrayOf ve diğer array türleri için benzerleri) değişken sayıda değeri argument
  olarak alır ve bu değerleri tutan bir array oluşturur.

* Başka bir constructor, bir `size` ve her element’i initialize etmek için kullanılan bir lambda alır.

İlk iki seçeneğin, beş adet sıfır içeren bir integer array oluşturmak için nasıl çalıştığı aşağıda gösterilmektedir:

```kotlin
fun main(args: Array<String>) {
    val fiveZeros = IntArray(5)
    val fiveZerosToo = intArrayOf(0, 0, 0, 0, 0)

    println(fiveZeros.joinToString()) // 0, 0, 0, 0, 0
    println(fiveZerosToo.joinToString()) // 0, 0, 0, 0, 0
}
```

Lambda kabul eden constructor’ı nasıl kullanabileceğiniz aşağıda gösterilmektedir:

```kotlin
fun main(args: Array<String>) {
    val squares = IntArray(5) { i -> (i + 1) * (i + 1) }
    println(squares.joinToString()) // 1, 4, 9, 16, 25
}
```

Alternatif olarak, primitive bir türün boxed değerlerini tutan bir array veya collection’a sahipseniz, bunları
toIntArray gibi ilgili conversion function’ı kullanarak o primitive türün bir array’ine dönüştürebilirsiniz.

Sonraki adımda, array’lerle yapabileceğiniz bazı şeylere bakalım. Temel operation’lara (array’in length’ini almak ve
element’leri almak ve ayarlamak) ek olarak, Kotlin standart kütüphanesi array’ler için collection’larda olduğu gibi aynı
extension function kümesini destekler. 6. bölümde gördüğünüz tüm function’lar (filter, map ve benzerleri) primitive tür
array’leri de dahil olmak üzere array’ler için de çalışır. (Bu function’ların dönüş değerlerinin array değil, list
olduğunu unutmayın.)

forEachIndexed function’ı ve bir lambda kullanarak daha önceki kodumuzu nasıl yeniden yazabileceğimize bakalım. Bu
function’a geçirilen lambda, array’in her element’i için çağrılır ve iki argument alır: element’in index’i ve element’in
kendisi.

```kotlin
fun main(args: Array<String>) {
    args.forEachIndexed { index, element ->
        println("Argument $index is: $element")
    }
}
```

Artık code’unuzda array’leri nasıl kullanacağınızı biliyorsunuz. Onlarla çalışmak, Kotlin’de collection’larla çalışmak
kadar basittir.