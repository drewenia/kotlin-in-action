# Representing integers, floating-point numbers, characters, and Booleans with primitive types

Bildiğin gibi Java, primitive type’lar ile reference type’lar arasında bir ayrım yapar. Primitive bir type’a sahip bir
variable (örneğin int), değerini doğrudan tutar. Reference type’a sahip bir variable (örneğin String) ise object’i
içeren bellek konumuna bir referans tutar.

Primitive type’ların value’ları daha verimli şekilde saklanabilir ve taşınabilir, ancak bu value’lar üzerinde method
call yapılamaz veya collection’larda saklanamaz. Java, bir object’e ihtiyaç duyulan durumlarda primitive type’ları
encapsulate eden özel wrapper type’lar (örneğin java.lang.Integer) sağlar. Bu nedenle integer’lardan oluşan bir
collection tanımlamak için Collection<int> yazamazsın; bunun yerine Collection<Integer> kullanman gerekir.

Kotlin, primitive type’lar ile wrapper type’lar arasında ayrım yapmaz. Her zaman aynı type’ı kullanırsın (örneğin Int):

```kotlin
val i: Int = 10
val list: List<Int> = listOf(1, 2, 3)
```

Bu kullanışlıdır. Dahası, bir number type’ın value’ları üzerinde method call yapabilirsin. Örneğin, aşağıdaki parçayı
düşün; bu parça, value’yu belirtilen range ile sınırlamak için standard library’deki `coerceIn` function’ını kullanır:

```kotlin
fun showProgress(progress: Int) {
    val percent = progress.coerceIn(0, 100)
    println("We're $percent % done") // We're 100 % done
}

fun main() {
    showProgress(146)
}
```

Primitive type’lar ile reference type’lar aynıysa, bu Kotlin’in tüm number’ları object olarak temsil ettiği anlamına mı
gelir? Bu son derece verimsiz olmaz mıydı? Gerçekten de öyle olurdu, bu yüzden Kotlin bunu yapmaz.

Runtime sırasında number type’lar mümkün olan en verimli şekilde temsil edilir. Çoğu durumda — variable’lar,
property’ler, parameter’lar ve return type’lar için — Kotlin’in Int type’ı Java primitive type’ı olan int’e compiled
edilir. Bunun mümkün olmadığı tek case, collection’lar gibi generic class’lardır. Bir generic class’ın type argument’ı
olarak kullanılan bir primitive type, karşılık gelen Java wrapper type’a compiled edilir. Örneğin, Int type’ı bir
collection’ın type argument’ı olarak kullanılırsa, collection karşılık gelen wrapper type olan java.lang.Integer
instance’larını saklar.

Java primitive type’lara karşılık gelen type’ların tam listesi aşağıdaki gibidir:

* Integer types — Byte, Short, Int, and Long

* Floating-point number types — Float and Double

* Character type — Char

* Boolean type — Boolean