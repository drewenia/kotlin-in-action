# Kotlin collections and Java collections are deeply related

Her Kotlin collection’ın karşılık gelen Java collection interface’ının bir instance’ı olduğu doğrudur. Kotlin ve Java
arasında geçerken herhangi bir conversion yapılmaz; wrapper veya veri kopyalama gerekmez. Ancak her Java collection
interface’ının Kotlin’de iki temsilcisi vardır: biri read-only, diğeri mutable:

Kotlin collection interface’larının hiyerarşisi. ArrayList ve HashSet gibi Java class’ları, Kotlin mutable
interface’lerini extend eder.

![img_7.png](assets/img_7.png)

Yukarıda resimde gösterilen tüm collection interface’ları Kotlin’de declare edilmiştir. Kotlin read-only ve mutable
interface’larının temel yapısı, java.util package’ındaki Java collection interface’larının yapısına paraleldir. Ayrıca,
her mutable interface karşılık gelen read-only interface’i extend eder. Mutable interface’lar java.util package’ındaki
interface’lara doğrudan karşılık gelirken, read-only versiyonlar tüm mutating method’lardan yoksundur.

Yukarıdaki resim ayrıca Java standard class’ları olan java.util.ArrayList ve java.util.HashSet’i içerir; böylece Java
standard class’larının Kotlin’de nasıl ele alındığı gösterilir. Kotlin, onları sanki sırasıyla Kotlin’in MutableList ve
MutableSet interface’lerinden inherit etmiş gibi görür. Java collection library’den diğer implementation’lar (
LinkedList, SortedSet vb.) burada gösterilmemiştir, ancak Kotlin açısından benzer supertype’lara sahiptirler. Bu
şekilde, hem uyumluluk sağlanır hem de mutable ve read-only interface’ların net ayrımı korunur.

Collection’lara ek olarak, Map class’ı (Collection veya Iterable’ı extend etmez) Kotlin’de iki ayrı versiyon olarak
temsil edilir: Map ve MutableMap. Table 8.2, farklı type’larda collection oluşturmak için kullanabileceğin function’ları
gösterir.

![img_8.png](assets/img_8.png)

setOf() ve mapOf() function’larının, read-only interface’lar olan Set ve Map’in instance’larını döndürdüğünü, ancak
perde arkasında mutable olduklarını unutma. (JVM’de, değişiklikleri imkânsız kılmak için collections,
`Collections.unmodifiable` ile sarılabilir. Ancak bu ek bir indirection overhead getirir; bu nedenle Kotlin,
collection’larını otomatik olarak böyle wrap etmiyor.) Ama buna güvenmemelisin: gelecekteki bir Kotlin sürümü, setOf ve
mapOf’un return value’ları için gerçekten immutable implementation class’lar kullanabilir.

Bir Java method’unu çağırman ve collection’ı argument olarak geçmen gerektiğinde, bunu herhangi bir ekstra adım olmadan
doğrudan yapabilirsin. Örneğin, Java method’u `java.util.Collection` tipinde bir parameter alıyorsa, bu parametreye
herhangi bir Collection veya MutableCollection value geçirebilirsin.

Bu, collection’ların mutability’si açısından önemli sonuçlar doğurur. Java, read-only ve mutable collection’ları ayırt
etmediği için, Java kodu collection’ı değiştirebilir; Kotlin tarafında read-only Collection olarak declare edilmiş olsa
bile. Kotlin compiler, Java kodunda collection’a ne yapıldığını tam olarak analiz edemez ve bu nedenle, read-only
Collection’ı değiştiren Java koduna geçmeyi reddetmenin bir yolu yoktur. Örneğin, aşağıdaki iki kod snippet’i,
derlenebilir bir Kotlin–Java çapraz dil programı oluşturur:

```java
public class CollectionUtils {
    public static List<String> uppercaseAll(List<String> items) {
        for (int i = 0; i < items.size(); i++) {
            items.set(i, items.get(i).toUpperCase());
        }
        return items;
    }
}
```

```kotlin
fun main() {
    val list = listOf("a", "b", "c")
    printInUppercase(list)
    // [A, B, C]
    //  A
}

// Read-only bir parameter declare eder. (list: List<String>)
fun printInUppercase(list: List<String>) {
    //Collection’ı değiştiren bir Java function’ını çağırır.
    println(CollectionUtils.uppercaseAll(list))
    // Collection’ın değiştirildiğini gösterir.
    println(list.first())
}
```

Bu nedenle, eğer bir Kotlin function’ı yazıyor ve collection’ı Java’ya geçiriyorsan, parameter için doğru type’ı
kullanmak senin sorumluluğundur; Java kodunun collection’ı değiştirip değiştirmeyeceğine bağlı olarak. Bu uyarının,
non-null element type’lara sahip collection’lar için de geçerli olduğunu unutma. Böyle bir collection’ı bir Java
method’una geçirirsen, method içine null value koyabilir; Kotlin’in bunu yasaklamasının veya gerçekleştiğini tespit
etmesinin bir yolu yoktur ve bunu yapmak performansı olumsuz etkiler. Bu nedenle, collection’ları değiştirebilecek Java
koduna geçirirken özel önlemler alman gerekir; böylece Kotlin type’ları, collection’daki tüm olası değişiklikleri doğru
şekilde yansıtır. Şimdi, Kotlin’in Java kodunda declare edilmiş collection’larla nasıl çalıştığına daha yakından
bakalım.