# Extra type safety without overhead: Inline classes

Data class’lar ile compiler tarafından generate edilen code’un, code’unu okunabilir ve dağınıklıktan uzak tutmana
nasıl yardımcı olduğunu zaten gördün. Şimdi Kotlin compiler’ın gücünü gösteren başka bir örneğe bakalım: inline
class’lar. Bir an için, harcamalarını takip etmek üzere basit bir sistem inşa ettiğini varsayalım:

```kotlin
fun addExpense(expense: Int) {
    // save the expense as USD cent
}
```

Japonya’ya yapacağın bir sonraki seyahat sırasında, sana ¥200’ye mal olan lezzetli bir Nikuman’ın (buharda pişirilmiş
çörek) faturasını eklemek istiyorsun. Problem oldukça hızlı bir şekilde ortaya çıkar: function’ın signature’ı sade bir
Int kabul ettiği için, function’ı call edenlerin gerçekte farklı semantics’e sahip value’lar geçmesini engelleyen hiçbir
şey yoktur. Bu durumda, actual implementation geçirilen value’nun “USD cent” anlamına gelmesini gerektirirken, caller’ın
parameter’ı “yen” olarak yorumlamasını engelleyen hiçbir şey yoktur. Bunu engellemenin klasik yaklaşımı, sade bir Int
yerine bir class kullanmaktır:

```kotlin
class UsdCent(val amount: Int)

fun addExpense(expense: UsdCent) {
    // save the expense as USD cent
}
```

Bu yaklaşım, function’a yanlış semantics’e sahip bir value’un yanlışlıkla geçirilme olasılığını önemli ölçüde
azaltsa da, bazı performance değerlendirmelerini beraberinde getirir: her addExpense function call’ı için yeni bir
UsdCent object’i oluşturulması gerekir; bu object daha sonra function body’si içinde açılır ve atılır. Eğer bu function
sıkça call edilirse, çok sayıda kısa ömürlü object allocate edilir ve ardından garbage collected edilir. İşte bu noktada
inline class’lar devreye girer. Performance’dan ödün vermeden bir type safety katmanı eklemene olanak tanırlar. UsdCent
class’ını bir inline class’a dönüştürmek için, onu value keyword’ü ile işaretler ve ardından @JvmInline annotation’ı ile
annotate edersin:

```kotlin
@JvmInline
value class UsdCent(val amount: Int)

fun addExpense(expense: UsdCent) {
    // save the expense as USD cent
}
```

Bu küçük değişiklik, UsdCent wrapper type’ının sağladığı type safety’den vazgeçmeden gereksiz object
instantiation’larını önler. Runtime’da, UsdCent instance’ları sarmalanmış property olarak represent edilir. Inline
class’ların isimlerini aldığı yer de burasıdır: class’ın data’sı kullanım noktalarında inline edilir. Tam olarak doğru
olmak gerekirse, Kotlin compiler inline class’ı mümkün olan her yerde onun underlying type’ı olarak represent eder.
Wrapper type’ı korumanın gerekli olduğu durumlar vardır — en belirgin olarak, inline class bir type parameter olarak
kullanıldığında.

“Inline” olarak nitelendirilebilmesi için, class’ının tam olarak bir property’si olmalıdır ve bu property primary
constructor içinde initialize edilmelidir. Inline class’lar ayrıca class hierarchy’lerine katılmazlar: başka class’ları
extend etmezler ve kendileri de extend edilemezler. Ancak yine de interface’leri implement edebilir, method’lar define
edebilir ya da computed property’ler sağlayabilirler.

```kotlin
fun main() {
    val expense = UsdCent(1_99)
    println(expense) // UsdCent(amount=199)
    println(expense.salesTax) // 11.94
    println(expense.prettyPrint()) // 199¢
}

interface PrettyPrintable {
    fun prettyPrint()
}

@JvmInline
value class UsdCent(val amount: Int) : PrettyPrintable {
    val salesTax
        get() = amount * 0.06

    override fun prettyPrint() = println("${amount}¢")
}
```

Inline class’lara çoğunlukla temel value’ların semantics’ini açık hale getirmek için başvurursun; örneğin sade number
type’ları için kullanılan ölçü birimlerini belirtmek ya da farklı string’lerin anlamlarını ayırt etmek gibi. Function
caller’ların, semantics’i farklı olan ancak uyumlu value’ları yanlışlıkla geçmesini engellerler. Inline class için bir
problem ve çözümü:

```kotlin
fun transfer (from : Int, to : Int, amount : Int){}
```

Buradaki problem şu: from, to, amount hepsi Int. Compiler anlam farkını bilmiyor.Yanlış parametre sırası → sessiz
bug. Inline class = “Bu Int ne anlama geliyor?” demek

```kotlin
fun main() {
    transfer(UserId(5), UserId(4), Amount(100))
}

@JvmInline
value class UserId(val value: Int)

@JvmInline
value class Amount(val amount: Int)

fun transfer(from: UserId, to: UserId, amount: Amount) {}
```

val id = UserId(5)

JVM’de bu şuna dönüşür: int 5 Object yok, GC yok, Wrapper maliyeti yok. Bu yüzden adı inline. Kurallar (çok basit)
Sadece 1 property, Runtime’da primitive gibi davranır Yanlış kullanım compile-time error üretir.