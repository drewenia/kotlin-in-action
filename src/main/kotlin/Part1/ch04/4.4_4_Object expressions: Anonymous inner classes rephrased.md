# Object expressions: Anonymous inner classes rephrased

object keyword’ü yalnızca isimlendirilmiş singleton benzeri object’leri declare etmek için değil, aynı zamanda anonymous
object’leri declare etmek için de kullanılabilir. Anonymous object’ler, Java’daki anonymous inner class kullanımının
yerini alır. Örneğin, Kotlin’de tipik bir event listener’ı nasıl sağlayabileceğine bakalım. Diyelim ki, kullanıcının
button ile etkileşime girdiğinde davranışı belirlemek için MouseListener interface’inin bir instance’ını alan bir Button
class’ı ile çalışıyorsun:

```kotlin
interface MouseListener {
    fun onEnter()
    fun onClick()
}

class Button(private val listener: MouseListener)
```

Button sınıfı, "bir tıklama olduğunda ne yapacağını" kendisi bilmez. Sadece "bir tıklama gerçekleştiğini" haber
vermekle görevlidir. Neden private val listener var? Button sınıfı, fareyle etkileşime girildiğinde (örneğin bir click()
metodu çalıştığında) bu listener üzerinden dış dünyaya haber gönderir. Eğer bu değişkeni bir yere kaydetmezse
(val ile tutmazsa), kime haber vereceğini unutur. Kapsülleme (Encapsulation - private olması): Dışarıdaki sınıfların bu
listener nesnesine doğrudan erişip onu değiştirmesini veya bozmasını istemeyiz. Sadece Button sınıfı, uygun gördüğü
zamanda (tıklanma anında) bu listener'ı tetikleyebilmelidir. Gevşek Bağlılık (Loose Coupling): Button sınıfı, kendisine
kimin bağlandığını bilmez. Sadece bağlanan nesnenin MouseListener arayüzüne uyduğunu (yani onClick ve onEnter
fonksiyonlarına sahip olduğunu) bilir.

```kotlin
fun main() {
    /* MouseListener implementing bir anonymous object declare eder */
    Button(object : MouseListener {
        override fun onEnter() = println("On enter")
        override fun onClick() = println("On click")
    })
}

interface MouseListener {
    fun onEnter()
    fun onClick()
}

class Button(private val listener: MouseListener)
```

Syntax, object declaration’lar ile aynıdır; tek fark, object’in name’ini atlamandır. Ancak object declaration’ların
aksine, anonymous object’ler singleton değildir. Bir object expression her execute edildiğinde, object’in yeni bir
instance’ı oluşturulur. Object expression bir class declare eder ve o class’ın bir instance’ını oluşturur, ancak ne
class’a ne de instance’a bir isim atar. Genellikle buna gerek yoktur; çünkü object’i bir function call’unda parameter
olarak kullanırsın. Eğer object’e bir isim ataman gerekiyorsa, onu bir variable içinde saklayabilirsin:

```kotlin
fun main() {
    val listener = object : MouseListener {
        override fun onEnter() {
            TODO("Not yet implemented")
        }

        override fun onClick() {
            TODO("Not yet implemented")
        }
    }
}

interface MouseListener {
    fun onEnter()
    fun onClick()
}

class Button(private val listener: MouseListener)
```

Kotlin’de anonymous object’ler oldukça esnektir: tek bir interface’i, birden fazla interface’i implement edebilirler
ya da hiçbir interface implement etmeyebilirler. Bir object expression içindeki code, oluşturulduğu function’daki
variable’lara erişebilir — tıpkı Java’daki anonymous class’larda olduğu gibi. Ancak Java’nın aksine, bu durum final
variable’larla sınırlı değildir. Kotlin’de, bir object expression içinden variable’ların value’larını da
değiştirebilirsin. Örneğin, bir listener kullanarak bir pencere içindeki click sayısını nasıl sayabileceğine bakalım.

```kotlin
fun main() {
    var clickCount = 0
    Button(object : MouseListener{
        override fun onEnter() {
            TODO("Not yet implemented")
        }

        override fun onClick() {
            clickCount++
        }
    })
}

interface MouseListener {
    fun onEnter()
    fun onClick()
}

class Button(private val listener: MouseListener)
```

Object expression’lar, anonymous object’inde birden fazla method override etmen gerektiğinde çoğunlukla faydalıdır.
Yalnızca tek method’lu bir interface’i (Runnable gibi) implement etmen gerekiyorsa, Kotlin’in SAM conversion desteğine
(tek bir abstract method’a sahip bir interface’in implementation’ına bir function literal dönüştürülmesi) güvenebilir ve
implementation’ını bir function literal (lambda) olarak yazabilirsin.