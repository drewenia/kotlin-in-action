# Visibility modifiers: Public by default

Visibility modifier’ları, code base’inizdeki declaration’lara erişimi kontrol etmeye yardımcı olur. Bir class’ın
implementation detaylarının visibility’sini kısıtlayarak, class’a bağlı olan kodu bozma riski olmadan bu detayları
değiştirebileceğinizi garanti altına alırsınız. Kotlin, Java’daki karşılıklarına benzer olan public, protected ve
private modifier’larını sağlar: public declaration’lar her yerde görünürdür; protected declaration’lar subclass’larda
görünürdür; private declaration’lar ise bir class’ın içinde ya da top-level declaration’lar söz konusu olduğunda bir
file içinde görünürdür. Kotlin’de bir modifier belirtilmemesi, declaration’ın public olduğu anlamına gelir. Varsayılan
olarak public olması, Java’dan bildiğinizden farklıdır; ancak application geliştiricileri için kullanışlı bir
konvansiyondur. Öte yandan, library yazarları genellikle API’lerinin hiçbir parçasının yanlışlıkla expose edilmediğinden
emin olmak ister. Sonradan public olan bir API’yi gizlemek, sonuçta breaking bir change olur. Bu durum için Kotlin,
explicit API mode sağlar. Explicit mode’da, public API olarak expose edilecek declaration’lar için visibility’yi
belirtmeniz ve ayrıca public API’nin parçası olan property ve function’lar için type’ı açıkça belirtmeniz gerekir.
Explicit API mode, -Xexplicit-api={strict|warning} Compiler option’ı kullanılarak ya da build system üzerinden
etkinleştirilebilir. Bir module içinde visibility’yi kısıtlamak için Kotlin, internal visibility modifier’ını sağlar.
Bir module, birlikte compile edilen Kotlin file’larının bir kümesidir. Bu, bir Gradle source set’i, bir Maven project’i
ya da bir IntelliJ IDEA module’ü olabilir. Gradle kullanırken, test source set’i, main source set’inizde internal olarak
işaretlenmiş declaration’lara erişebilir. Kotlin’de, Java’daki varsayılan visibility olan package-private kavramı
yoktur. Kotlin, package’ları yalnızca code’u namespace’ler içinde organize etmenin bir yolu olarak kullanır; visibility
kontrolü için kullanmaz. internal visibility’nin avantajı, module’ünüzün implementation detayları için gerçek
encapsulation sağlamasıdır. Java’da encapsulation kolayca bozulabilir; çünkü external code, kodunuzun kullandığı
package’larla aynı package’larda class’lar tanımlayabilir ve böylece package-private declaration’larınıza erişim
kazanabilir. Kotlin, class’lar, function’lar ve property’ler dâhil olmak üzere top-level declaration’lar için de
private visibility kullanmanıza izin verir. Bu tür declaration’lar yalnızca declare edildikleri file içinde görünürdür.
Bu, bir subsystem’in implementation detaylarını gizlemenin bir başka yararlı yoludur.

![img_1.png](assets/img_1.png)

Yukarıda ki table, tüm visibility modifier’larını özetler. Bir örneğe bakalım. giveSpeech function’ındaki her satır
visibility kurallarını ihlal etmeye çalışır. Bu durum error ile compile edilir.

```kotlin
internal open class TalkativeButton {
    private fun yell() = println("Hey!")
    protected fun whisper() = println("Let's talk!")
}

// Hata: public bir member, internal receiver type TalkativeButton’ı expose ediyor (açığa çıkarıyor)
/*
fun TalkativeButton.giveSpeech(){
    yell() // Hata: yell’e erişilemez; TalkativeButton içinde private’tır
    whisper() // Hata: whisper’a erişilemez; TalkativeButton içinde protected’tır
}
*/
```

Kotlin, public olan giveSpeech function’ından daha az görünür bir type olan TalkativeButton’a (bu durumda internal)
referans vermenizi yasaklar. Bu, daha genel bir kuralın bir örneğidir: bir class’ın base type’ları ve type
parameter’ları listesinde ya da bir method’un signature’ında kullanılan tüm type’lar, class ya da method’un kendisi
kadar görünür olmalıdır. Bu kural, function’ı invoke etmek ya da bir class’ı extend etmek için ihtiyaç duyabileceğiniz
tüm type’lara her zaman erişebilmenizi sağlar. Problemi çözmek için ya giveSpeech extension function’ını internal
yapabilir ya da TalkativeButton class’ını public yapabilirsiniz. Java ve Kotlin’de protected modifier için davranış
farkına dikkat edin. Java’da aynı package içinden protected bir member’a erişebilirsiniz, ancak Kotlin buna izin vermez.
Kotlin’de visibility kuralları basittir ve protected bir member yalnızca class’ın kendisi ve onun subclass’ları içinde
görünürdür. Ayrıca, bir class’ın extension function’ları onun private ya da protected member’larına erişim kazanmaz.
giveSpeech extension function’ından protected olan whisper function’ını çağıramamanızın nedeni de budur.

Kotlin’de public, protected ve private modifier’ları Java bytecode’a compile edilirken korunur. Bu tür Kotlin
declaration’larını Java code’undan, Java’da aynı visibility ile declare edilmişler gibi kullanırsınız. Tek istisna
private bir class’tır: arka planda package-private bir declaration olarak compile edilir (Java’da bir class’ı private
yapamazsınız). Peki internal modifier’a ne olur diye sorabilirsiniz. Java’da bunun doğrudan bir karşılığı yoktur.
Package-private visibility tamamen farklı bir kavramdır: bir module genellikle birden fazla package’ten oluşur ve farklı
module’ler aynı package’ten declaration’lar içerebilir. Bu nedenle, internal modifier bytecode’da public hâline gelir.
Kotlin declaration’ları ile bunların Java karşılıkları (ya da bytecode temsilleri) arasındaki bu eşleşme, bazen Java
code’undan erişebildiğiniz bir şeye Kotlin’den neden erişemediğinizi açıklar. Örneğin, başka bir module’deki Java
code’undan internal bir class’a ya da bir top-level declaration’a veya aynı package içindeki Java code’undan protected
bir member’a erişebilirsiniz. Ancak, bir class’ın internal member’larının adlarının mangled (parçalanmış) edildiğine
dikkat edin.

Teknik olarak internal member’lar Java’dan kullanılabilir, ancak Java code’unda çirkin görünürler. Bu, başka bir
module’den bir class’ı extend ettiğinizde override’larda beklenmedik çakışmaları önlemeye yardımcı olur ve internal
class’ları yanlışlıkla kullanmanızı engeller. Kotlin ile Java arasındaki visibility kurallarındaki bir diğer fark da,
Kotlin’de bir outer class’ın inner (ya da nested) class’ların private member’larını görememesidir. Şimdi Kotlin’de
inner ve nested class’ları ele alalım.