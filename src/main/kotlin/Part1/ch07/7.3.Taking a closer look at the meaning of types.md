# Taking a closer look at the meaning of types

En genel soruları düşünelim: type’lar nedir ve variable’ların neden type’ları vardır? 1976’da David Parnas, type’ları
olası value’ların bir set’i ve bu value’lar üzerinde gerçekleştirilebilecek operation’ların bir set’i olarak
tanımlamıştı.

Bu tanımı, Java type’larından bazılarına uygulamaya çalışalım; double type ile başlayalım. Bildiğin gibi, double 64-bit
floating-point sayıdır. Bu value’lar üzerinde standart matematiksel operation’ları gerçekleştirebilirsin. Tüm bu
fonksiyonlar, double type’ındaki tüm value’lar için eşit şekilde uygulanabilir. Bu nedenle, eğer bir double type’lı
variable’a sahipsen, compiler tarafından izin verilen herhangi bir operation’ın değer üzerinde başarılı bir şekilde
execute edileceğinden emin olabilirsin.

Şimdi bunu, String type’lı bir variable ile karşılaştıralım. Java’da böyle bir variable iki tür value tutabilir: String
class’ının bir instance’ı veya null. Bu value türleri birbirinden tamamen farklıdır: Java’nın kendi instanceof
operator’ü bile null’un bir String olmadığını söyler. Variable’ın value’su üzerinde gerçekleştirilebilecek operation’lar
da tamamen farklıdır: gerçek bir String instance, string üzerinde herhangi bir method call yapmana izin verirken, null
value yalnızca sınırlı bir operation set’ine izin verir.

Bu, Java’nın type system’inin bu durumda iyi bir iş yapmadığı anlamına gelir. Variable’ın declare edilmiş bir type’ı
olsa bile—String—ek kontroller yapmadıkça bu variable’ın value’larıyla ne yapabileceğini bilemezsin. Çoğu zaman,
programındaki genel data akışından bir value’nun belirli bir noktada null olamayacağını bildiğin için bu kontrolleri
atlıyorsun. Bazen yanılıyorsun ve programın NullPointerException ile çöküyor.

### NullPointerException hatalarıyla başa çıkmanın diğer yolları

Java, NullPointerException sorununu çözmeye yardımcı olacak bazı araçlara sahiptir. Örneğin, bazı kişiler value’ların
nullability’sini ifade etmek için annotation’lar (ör. @Nullable ve @NotNull) kullanır. Bu annotation’ları kullanarak
NullPointerException’ın fırlatılabileceği yerleri tespit edebilen araçlar (ör. IntelliJ IDEA’nın yerleşik code
inspections’ı) vardır. Ancak bu tür araçlar standard Java compilation sürecinin bir parçası değildir, bu yüzden bunların
tutarlı bir şekilde uygulanmasını sağlamak zordur. Projede kullanılan kütüphaneler de dahil olmak üzere tüm codebase’i
annotate etmek zor olduğundan, tüm olası hata konumlarının tespit edilmesi de zordur. JetBrains’deki kendi deneyimimiz,
Java’da nullability annotation’larının yaygın olarak kullanılmasının bile NPE sorununu tamamen çözmediğini
göstermektedir.

Bu sorunu çözmenin bir diğer yolu, code’da hiç null value kullanmamak ve tanımlı olup olmayabileceğini represent etmek
için Java 8’de tanıtılan Optional type gibi özel bir wrapper type kullanmaktır. Bu yaklaşımın birkaç dezavantajı vardır:
code daha verbose hale gelir, ek wrapper instance’ları runtime’da performansı etkiler ve tüm ekosistem genelinde tutarlı
bir şekilde kullanılmaz. Kendi code’unda her yerde Optional kullansan bile, JDK, Android framework ve diğer üçüncü taraf
kütüphanelerin method’larından dönen null value’larla hâlâ başa çıkman gerekir.

___
___

Kotlin’de nullable types, bu soruna kapsamlı bir çözüm sunar. Nullable ve non-nullable type’ları ayırmak, value üzerinde
hangi operation’ların allowed olduğunu ve hangi operation’ların runtime’da exception’a yol açabileceğini açık bir
şekilde anlamayı sağlar; bu nedenle bu tür operation’lar forbidden’dır.

Runtime’da nullable veya non-nullable type’lı object’ler aynıdır; nullable type, non-null type için bir wrapper
değildir. Çok az performans etkisi olan bazı otomatik olarak oluşturulmuş intrinsic (içsel) check’ler dışında, Kotlin’de
nullable type’larla çalışmanın runtime’da neredeyse hiçbir overhead’i yoktur.

Şimdi, Kotlin’de nullable type’larla nasıl çalışılacağını ve onlarla başa çıkmanın kesinlikle rahatsız edici olmadığını
görelim. Nullable value’a güvenli bir şekilde erişmek için kullanılan özel operator ile başlayacağız.