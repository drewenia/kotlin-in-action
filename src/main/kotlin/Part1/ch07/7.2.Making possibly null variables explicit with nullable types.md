# Making possibly null variables explicit with nullable types

Kotlin’in ve Java’nın type system’leri arasındaki ilk ve muhtemelen en önemli fark, Kotlin’in nullable types için açık
desteğidir. Bu ne anlama gelir? Programındaki hangi variable’ların veya property’lerin null olmasına izin verildiğini
belirtmenin bir yoludur. Bir variable null olabiliyorsa, üzerinde bir method call yapmak safe değildir; çünkü bir
NullPointerException’a neden olabilir. Kotlin bu tür call’lara izin vermez ve böylece birçok olası exception’ı engeller.

Bunun pratikte nasıl çalıştığını görmek için, bir String kabul eden ve üzerinde length fonksiyonunu call eden aşağıdaki
Java function’a bakalım:

```java
// java
int strLen(String s) {
    return s.length();
}
```

Bu function safe mi? Deneyimli bir developer, function null bir argument ile call edilirse bir NullPointerException
fırlatacağını muhtemelen hızlıca fark eder. Function’a null için bir check eklemen gerekir mi? Bu, function’ın intended
(amaçlanan) use’una bağlıdır.

Bu function’ı Kotlin’de yeniden yazalım. Yanıtlaman gereken ilk soru şudur: function’ın null bir argument ile call
edilmesini bekliyor musun? Burada yalnızca strLen(null) örneğindeki gibi doğrudan null literal’ını değil, runtime’da
null value alabilecek herhangi bir variable ya da başka bir expression’ı da kastediyoruz.

Bunun olmasını beklemiyorsan, bu function’ı Kotlin’de şu şekilde declare edersin:

```kotlin
fun strLen(s: String) = s.length
```

Null olabilecek bir argument ile strLen’i call etmek allowed değildir ve compile time’da bir error olarak işaretlenir:

```kotlin
fun main() {
    // ERROR: Null, non-null type String’in bir value’si olamaz
    strLen(null)
}

fun strLen(s: String) = s.length
```

Parameter type olarak String şeklinde declare edilmiştir ve Kotlin’de bu, her zaman bir String instance içermesi
gerektiği anlamına gelir. Compiler bunu enforce eder; bu nedenle null içeren bir argument pass edemezsin. Bu, strLen
function’ının runtime’da asla bir NullPointerException fırlatmayacağı garantisini sağlar. Bu function’ın, null
olabilecekler de dâhil tüm argument’lerle kullanılmasına izin vermek istiyorsan, bunu type isminin sonuna bir soru
işareti koyarak açıkça belirtmen gerekir:

```
fun strLen(s: String?) = ...
```

Herhangi bir type’ın sonuna bir soru işareti koyarak, bu type’daki variable’ların null reference’lar depolayabileceğini
belirtebilirsin: String?, Int?, MyCustomType?, vb:

![img.png](assets/img.png)

Tekrar etmek gerekirse, soru işareti olmayan bir type, bu type’daki variable’ların null reference depolayamayacağını
gösterir. Bu, tüm regular type’ların varsayılan olarak non-nullable olduğu anlamına gelir; yalnızca açıkça nullable
olarak işaretlenmedikçe. Nullable type’a sahip bir value elde ettiğinde, üzerinde gerçekleştirebileceğin operation’lar
kısıtlanır. Örneğin, artık onun üzerinde method call yapamazsın. Compiler artık function body’sindeki length call’ı ile
ilgili şikâyet edecektir:

```kotlin
fun strLenSafe(s: String?) = s.length()
// ERROR: only safe (?.) or non-null asserted (!!.) calls are allowed
// on a nullable receiver of type kotlin.String?
```

Ayrıca, nullable type’a sahip bir value’yu non-nullable type’lı bir variable’a assign edemezsin:

```kotlin
fun main() {
    val x: String? = null
    var y: String = x
    // ERROR: Type mismatch:
    // inferred type is String? but String was expected
}
```

Nullable type’a sahip bir value’yu, non-nullable parameter’a sahip bir function’a argument olarak pass edemezsin:

```kotlin
fun main() {
    val x: String? = null
    strLen(x)
    // ERROR: Type mismatch:
    // inferred type is String? but String was expected
}
```

Peki, nullable type’a sahip bir value ile ne yapabilirsin? En önemli şey, onu null ile karşılaştırmaktır. Ve
karşılaştırmayı gerçekleştirdiğinde, compiler bunu hatırlar ve kontrolün yapıldığı scope içinde value’yu non-nullable
olarak ele alır. Örneğin, aşağıdaki code tamamen valid’dir.

```kotlin
fun strLenSafe(s: String?): Int =
    // Null kontrolü ekleyerek, code artık compile edilir.
    if (s != null) s.length else 0

fun main() {
    val x: String? = null
    val strLenSafe = strLenSafe(x)

    println(strLenSafe) // 0
    println(strLenSafe("abc")) // 3
}
```

Eğer nullability ile başa çıkmak için tek araç if kontrolleri olsaydı, code’un oldukça hızlı bir şekilde verbose hale
gelirdi. Neyse ki, Kotlin, nullable value’larla daha concise bir şekilde başa çıkmana yardımcı olacak birçok başka araç
sunar. Ancak bu araçlara bakmadan önce, nullability’nin anlamını ve variable type’ların ne olduğunu tartışmaya biraz
zaman ayıralım.