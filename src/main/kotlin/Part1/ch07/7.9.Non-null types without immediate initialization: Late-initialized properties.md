# Non-null types without immediate initialization: Late-initialized properties

Birçok framework, object instance oluşturulduktan sonra çağrılan özel method’larda object’leri initialize eder. Örneğin,
Android’de activity initialization onCreate method’unda gerçekleşir. JUnit’te ise initialization logic’i @BeforeAll veya
@BeforeEach ile annotate edilmiş method’lara koymak adettendir.

Ancak, bir non-nullable property’yi constructor’da initializer olmadan bırakıp sadece özel bir method’ta initialize
edemezsin. Kotlin normalde tüm property’lerin constructor’da initialize edilmesini ister ve bir property non-nullable
type’a sahipse, non-null bir initializer value sağlaman gerekir. Eğer bu value’yu sağlayamıyorsan, bunun yerine nullable
type kullanmak zorunda kalırsın. Bunu yaparsan, property’ye yapılan her erişim ya bir null check ya da !! operator’ü
gerektirir.

```kotlin
class MyService {
    fun performAction(): String = "Action done!"
}

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class MyTest {
    // Property’yi nullable type olarak declare eder ve null ile initialize eder.
    private var myService: MyService? = null

    @BeforeAll
    fun setUp() {
        // Gerçek bir initializer’ı setUp method’unda sağlar.
        myService = MyService()
    }

    @Test
    fun testAction() {
        // Nullability ile ilgilenmek zorundasın: !! veya ?. kullan.
        assertEquals("Action done!", myService!!.performAction())
    }
}
```

Bu özellikle property’ye birçok kez erişiyorsan çirkin görünür. Bunu çözmek için, myService property’sini geç
başlatılmış (late initialized) olarak declare edebilirsin. Bu, lateinit modifier uygulanarak yapılır.

```kotlin
class MyService {
    fun performAction(): String = "Action done!"
}

@TestInstance(TestInstance.Lifecycle.PER_CLASS)
class MyTest {
    // Initializer olmadan non-null type’ında bir property declare eder.
    private lateinit var myService: MyService

    @BeforeAll
    fun setUp() {
        // Property’yi, daha önce olduğu gibi, setUp method’unda initialize eder.
        myService = MyService()
    }

    @Test
    fun testAction() {
        // Property’ye ekstra null check yapmadan erişir.
        assertEquals("Action done!", myService.performAction())
    }
}
```

Late-initialized bir property her zaman `var` olmalıdır çünkü constructor dışında value’sunu değiştirebilmen gerekir;
val property’ler ise constructor’da initialize edilmesi gereken final field’lara compile edilir. Ancak artık, property
non-nullable type olsa bile, onu constructor’da initialize etmen gerekmez. Property’ye initialize edilmeden erişirsen,
aşağıdaki durumu alırsın:

```
kotlin.UninitializedPropertyAccessException:
    lateinit property myService has not been initialized
```

Ne olduğunu açıkça belirtir ve generic bir NullPointerException’dan çok daha anlaşılırdır:

![img_7.png](assets/img_7.png)

lateinit property’ler genellikle Google Guice gibi Java dependency injection framework’leri ile birlikte kullanılır. Bu
senaryoda, lateinit property’lerin value’ları framework tarafından dışarıdan set edilir. Geniş bir Java framework
yelpazesi ile uyumluluğu sağlamak için, Kotlin, lateinit property ile aynı visibility’e sahip bir field üretir. Property
public olarak declare edilmişse, field da public olur.

lateinit modifier, yalnızca class property’leri ile sınırlı değildir. Bir function body veya lambda içindeki local
variable’lar ile top-level property’ler için de late initialized olarak belirtilebilir. Şimdi, Kotlin’in null
value’larla başa çıkmak için sunduğu araç setini nasıl genişletebileceğine bakalım. Bunu, nullable type’lar için
extension function tanımlayarak öğreneceksin.

### Extra description

Kotlin'de lateinit (late initialization), bir değişkenin tanımlandığı anda değil, daha sonra başlatılacağını (initialize
edileceğini) taahhüt ettiğimiz bir anahtar kelimedir.

Normalde Kotlin'de "null güvenliği" (null safety) gereği, bir değişkeni tanımlarken ya ona bir değer atamanız ya da o
değişkeni "nullable" (boş olabilir) olarak işaretlemeniz gerekir. lateinit bu zorunluluğu esneterek size daha temiz bir
kod yazma imkanı sunar. Özellikle Android geliştirme yaparken veya Dependency Injection kullanırken, bir değişkenin
değerini sınıf oluşturulduğu an (constructor'da) veremeyebiliriz.

Eğer lateinit kullanmazsak, değişkeni var name: String? = null şeklinde tanımlayıp her seferinde name?.length veya
name!! şeklinde kullanmamız gerekir. lateinit ile değişkeni "non-null" (boş olamaz) gibi kullanabiliriz. Android'de View
veya Fragment nesneleri onCreate veya onViewCreated metodunda başlatılır. Bu durumlarda lateinit hayat kurtarır.

lateinit kullanırken uymanız gereken bazı katı kurallar vardır:

* Sadece var ile Kullanılır: Değerinin daha sonra değiştirilmesi gerektiği için val (immutable) ile kullanılamaz.

* Int, Double, Boolean, Float gibi tiplerle kullanamazsınız. Bunun sebebi JVM'in bu tipleri saklama biçimidir.

* Nullable Olamaz: lateinit var name: String? şeklinde bir tanımlama yapılamaz.

* Custom Getter/Setter Olmaz: Değişkenin kendi getter veya setter metotları olmamalıdır.

Examples;

Eğer bir lateinit property’ye onu initialize etmeden önce erişirsen, Kotlin, erişilen initialize edilmemiş property’yi
belirten özel bir exception fırlatır:

```kotlin
fun main() {
    val report = ReportGenerator()
    report.printReport()
}

class ReportGenerator {
    lateinit var report: String
    fun printReport() {
        println(report)
        /* Exception in thread "main" kotlin.UninitializedPropertyAccessException: lateinit property report has not
        been initialized*/
    }
}
```

Bir lateinit var’ın zaten initialize edilip edilmediğini kontrol etmek için, o property’nin referansı üzerinde
isInitialized property’sini kullan:

```kotlin
class WeatherStation{
    lateinit var latestReading : String

    fun printReading(){
        if (this::latestReading.isInitialized){
            println("Latest reading : $latestReading")
        } else {
            println("No reading available")
        }
    }
}

fun main() {
    val ws = WeatherStation()

    ws.printReading() // No reading available
    ws.latestReading = "22°C, sunny"
    ws.printReading() // Latest reading : 22°C, sunny
}
```