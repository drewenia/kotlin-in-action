# Utility functions as extensions

Artık joinToString function’ın final version’ını yazabilirsin. Bu, Kotlin standard library’de bulacağın hâliyle
neredeyse tamamen aynıdır. Onu element’lerden oluşan bir collection’a extension yaparsın (yani list’ler, set’ler ve
benzerleri üzerinde çalışır) ve tüm argument’ler için default value’lar sağlarsın. Artık joinToString’ı bir class
member’ı gibi invoke edebilirsin.

```kotlin
fun main() {
    val list = listOf("Kotlin", "Java", "Scala").joinToString()
    println(list) // (Kotlin, Java, Scala)

    val list2 = listOf(1, 4, 18)
    println(list2.joinToString(prefix = "#", postfix = "#")) // #1, 4, 18#
}

fun <T> Collection<T>.joinToString(
    seperator: String = ", ",
    prefix: String = "(",
    postfix: String = ")"
): String {
    val result = StringBuilder(prefix)
    // this burada Collection'dır
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(seperator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}
```

Extension function’lar effectively static method call’lar üzerinde syntactic sugar oldukları için, receiver type olarak
yalnızca bir class değil, daha spesifik bir type da kullanabilirsin. Diyelim ki yalnızca string collection’ları üzerinde
invoke edilebilen bir join function’a sahip olmak istiyorsun:

```kotlin
fun main() {
    // compile olmaz
    // listOf(1,2,3).join()
}

fun <T> Collection<T>.joinToString(
    seperator: String = ", ",
    prefix: String = "(",
    postfix: String = ")"
): String {
    val result = StringBuilder(prefix)
    // this burada Collection'dır
    for ((index, element) in this.withIndex()) {
        if (index > 0) result.append(seperator)
        result.append(element)
    }
    result.append(postfix)
    return result.toString()
}

fun Collection<String>.join(
    seperator: String = "..",
    prefix: String = "-",
    postfix: String = "£"
) = joinToString(seperator,prefix,postfix)
```

Extension’ların static doğası, extension function’ların subclass’larda override edilemeyeceği anlamına da gelir.