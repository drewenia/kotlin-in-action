# Blocks as branches of if and when

Hem if hem de when, branch olarak block’lara sahip olabilir. Bu durumda, block içindeki son expression sonuçtur. Diyelim
ki eval function’ının sonucu nasıl hesapladığını daha derinlemesine anlamak istiyorsun. Bunu yapmanın bir yolu,
function’ın şu anda neyi hesapladığını loglayan println ifadeleri eklemektir. Bunları when expression’ındaki her branch
için block içine ekleyebilirsin. Block içindeki son expression ise return edilecek olandır.

```kotlin
interface Expr
class Num(val value: Int) : Expr
class Sum(val left: Expr, val right: Expr) : Expr
class Sub(val left: Expr, val right: Expr) : Expr

fun eval(e: Expr): Int =
    when (e) {
        is Num -> {
            println("num : ${e.value}")
            e.value
        }
        is Sum -> {
            val left = eval(e.left)
            val right = eval(e.right)
            println("Left : $left, Right : $right")
            left + right
        }
        else -> throw IllegalArgumentException("wrong argument")
    }

fun main() {
    val result = eval(
        Sum(
            Sum(Num(1), Num(2)),
            Num(4)
        )
    )
    println(result)
    // num : 1
    // num : 2
    // Left : 1, Right : 2
    // num : 4
    // Left : 3, Right : 4
    // 7
}
```

Bir block’un son expression’ının sonuç olması kuralı, block’un kullanılabildiği ve bir sonuç beklendiği tüm durumlarda
geçerlidir. Aynı kural try body ve catch clause’ları için de geçerlidir; Bu kuralın lambda expression’lara uygulanmasını
tartışacağız. Ancak bu kural normal function’lar için geçerli değildir. Bir function ya block olamayan bir expression
body’ye ya da içinde explicit return ifadeleri bulunan bir block body’ye sahip olabilir.