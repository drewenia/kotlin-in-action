# Performing multiple operations on the same object: with

Birçok language, aynı object üzerinde birden fazla operation’ı adını tekrar etmeden gerçekleştirmek için
kullanabileceğin özel statement’lara sahiptir. Kotlin’de de bu imkân vardır, ancak özel bir language construct olarak
değil, with adlı bir library function olarak sağlanır. Bunun nasıl faydalı olabileceğini görmek için, aşağıdaki
example’ı ele al ve ardından with kullanarak refactor et.

```kotlin
fun main() {
    print(alphabet()) // ABCDEFGHIJKLMNOPQRSTUVWXYZ
}

fun alphabet(): String {
    val result = StringBuilder()
    for (letter in 'A'..'Z') {
        result.append(letter)
    }
    result.append("\nNow I know the alphabet!")
    return result.toString()
}
```

Bu example’da, result instance’ı üzerinde birkaç farklı method call edersin ve her call’da result adını tekrar
edersin. Bu çok kötü değildir, ancak kullandığın expression daha uzun olsaydı ya da daha sık tekrar edilseydi ne olurdu?
İşte kodu with kullanarak nasıl yeniden yazabileceğin.

```kotlin
fun alphabet(): String {
    val result = StringBuilder()

    // methodları call ettiğin receiver value'yu belirt
    return with(result) {
        for (letter in 'A'..'Z') {
            // result senin this’in olur …
            this.append(letter)
        }
        // … böylece append gibi method’ları onun üzerinde call edebilirsin.
        this.append("\nNow I know the alphabet!")
        this.toString()
    }
}
```

with yapısı özel bir construct gibi görünür, ancak iki argument alan bir function’dır: bu durumda stringBuilder ve
bir lambda. Lambda’yı parantezlerin dışına koyma konvansiyonu burada da geçerlidir ve tüm invocation language’ın
built-in bir özelliği gibi görünür. Alternatif olarak bunu with(stringBuilder, { … }) şeklinde de yazabilirsin, ancak bu
daha az readable’dır. with function, ilk argument’ını ikinci argument olarak pass edilen lambda’nın receiver’ına
dönüştürür. Bu receiver’a explicit bir this reference ile erişebilirsin. Alternatif olarak, bir this reference için her
zamanki gibi, onu omit edebilir ve bu value’nun method’larına veya property’lerine herhangi bir ek qualifier olmadan
erişebilirsin. with lambda’sı içinde this’i explicit olarak belirtmen gerekmez.

```kotlin
fun main() {
    print(alphabet())
    // abcdefghijklmnopqrstuvwxyz
    // Now I know the alphabet!
}

fun alphabet(): String {
    val result = StringBuilder()

    return with(result) {
        for (letter in 'a'..'z') {
            append(letter)
        }
        append("\nNow I know the alphabet!")
        toString()
    }
}
```

Benzer bir kavramı daha önce görmüş olabilirsin; burada this, function receiver’ına referans verir. Bir extension
function’ın body’si içinde, this function’ın extend ettiği type’ın instance’ına referans verir ve receiver’ın
member’larına doğrudan erişim sağlamak için omit edilebilir. Bir extension function’ın, bir anlamda, receiver’lı bir
function olduğunu unutma.

![img_5.png](img_5.png)

Resimde ki analogy uygulanabilir: Bir lambda, normal bir function’a benzer şekilde behavior tanımlamanın bir yoludur.
Receiver’lı bir lambda ise, extension function’a benzer şekilde behavior tanımlamanın bir yoludur. İlk alphabet
function’ı daha da refactor edelim ve ekstra stringBuilder variable’ından kurtulalım.

```kotlin
fun main() {
    print(alphabet())
    // abcdefghijklmnopqrstuvwxyz
}

fun alphabet() : String = with(StringBuilder()){
    for (letter in 'a'..'z'){
        append(letter)
    }
    toString()
}
```

Bu function artık yalnızca bir expression return eder, bu nedenle expression-body syntax’ı kullanılarak yeniden
yazılır. Yeni bir StringBuilder instance’ı oluşturur ve onu doğrudan argument olarak pass edersin; ardından lambda
içinde explicit this olmadan ona reference verirsin. 

Method–name conflict’leri : with’e parameter olarak pass ettiğin object, with’i kullandığın class ile aynı ada sahip
bir method’a sahipse ne olur? Bu durumda, hangi method’u call etmen gerektiğini belirtmek için this reference’a
explicit bir label ekleyebilirsin. Alphabet function’ın OuterClass adlı bir class’ın method’u olduğunu varsayalım.
StringBuilder’daki değil de outer class’ta defined edilmiş toString method’una referans vermen gerekiyorsa, aşağıdaki
syntax’ı kullanabilirsin: ```this@OuterClass.toString()```

with’in return ettiği value, lambda code’unu execute etmenin sonucudur. Bu sonuç, lambda’daki son expression’dır.
Ancak bazen, call’un lambda’yı execute etmenin sonucunu değil, receiver object’i return etmesini istersin. İşte bu
noktada apply library function kullanışlı olur.