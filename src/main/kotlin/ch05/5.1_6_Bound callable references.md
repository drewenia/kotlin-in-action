# Bound callable references

Şimdiye kadar, member reference’larımız her zaman bir class’ın member’ına işaret ediyordu. Bound callable reference’lar
kullanarak, aynı member reference syntax’ını belirli bir object instance üzerindeki bir method’a reference capture etmek
için kullanabiliriz. Bu example’da, variable personsAgeFunction normal bir member reference’dır: Person type’ında bir
object parametre olarak verildiğinde, invoke edildiğinde o kişinin age’ini döndürür. sebastianAgeFunction ise, invoke
edildiğinde belirli bir kişinin age’ini döndürür (ve bu nedenle hiç argument almaz):

```kotlin
fun main() {
    boundCallableReferenceExample()
}

data class Person(val name: String, val age: Int)

fun boundCallableReferenceExample() {
    val sebastian = Person("Sebastian", 26)

    // Verilen bir kişinin age’ini döndüren member reference
    val personAgeFunction = Person::age
    println(personAgeFunction(sebastian)) // 26

    // Belirli bir kişinin age’ini döndüren bound member reference
    val sebastianAgeFunction = sebastian::age
    // Belirli bir object’e bound edilir ve hiç argument almaz.
    println(sebastianAgeFunction()) // 26
}
```

Gördüğün gibi, bu example’da sebastionAgeFunction’ı tanımlama şeklimiz — ```seb::age``` — lambda ```{ seb.age }```’i
açıkça yazmaya eşdeğerdir, fakat daha concise’tır.

![img_3.png](img_3.png)

Normal bir member reference, örneğin Person::age, bir object instance’ını parameter olarak alır ve member’in value’sunu
döndürür. sebastian::age gibi bir bound member reference ise hiç argument almaz ve bağlı olduğu object’e ait member’in
value’sunu döndürür. Sonraki bölümde, lambda expression’larla ve member reference’larla çok iyi çalışan birçok library
function’a bakacağız. Lambda expression’ların sık kullanılan bir uygulamasını kapsamlı bir şekilde ele aldık:
collection’ları manipulate etmeyi basitleştirmek için kullanmak. Şimdi, başka bir önemli konuya devam edelim: mevcut bir
Java API ile lambda’ları kullanmak.

Kotlin’de bound member reference, bir object'e bağlı (bound) member fonksiyon veya property referansıdır. Yani referans,
zaten belirli bir instance’a bağlıdır, ve çağrıldığında o instance üzerinde çalışır.

Normal (unbound) member reference: String::length → herhangi bir String instance’ı alır ve length’ini döndürür. Instance
çağrıda verilir.

Bound member reference: "hello"::length → "hello" instance’ına bağlıdır, parametre verilmeye gerek yoktur.

### Examples :

```kotlin
fun main() {
    val alice = Person("Alice", 14)
    val derek = Person("Derek", 33)

    // UNBOUND -> CLASS üzerinden referans
    val unBoundRef: (Person) -> Boolean = Person::isAdult

    // Nesneyi elle vermelisin
    println(unBoundRef(alice)) // false
    // Nesneyi elle vermelisin
    println(unBoundRef(derek)) // true

    // BOUND: Object üzerinden referans
    val boundRef: () -> Boolean = alice::isAdult
    // Nesne vermene gerek yok, o zaten 'alice'e bağlı!
    println(boundRef()) // false
}

data class Person(val name: String, val age: Int)

fun Person.isAdult() = age >= 18
```

### Niçin Kullanılır? (Avantajları).

1. Kod Okunabilirliği ve Kısalık.

Eğer bir fonksiyonu sürekli aynı nesne üzerindeçağıracaksan, her seferinde lambda içinde o nesneyi yazmak yerine bound
reference kullanmak çok daha temizdir.

* Lambda ile: val action = { alice.isAdult() }

* Bound Ref ile: val action = alice::isAdult

2. Higher-Order Fonksiyonlara Kolayca Geçirmek

Bir fonksiyon, parametre olarak hiçbir şey almayan bir fonksiyon bekliyorsa ama senin elindeki fonksiyon bir nesneye
ihtiyaç duyuyorsa, bound reference bir "adaptör" görevi görür.

```kotlin
fun checkCondition(condition: () -> Boolean) {
    if (condition()) println("Şart sağlandı!")
}

// checkCondition(Person::isAdult) -> HATA! Çünkü Person bekliyor.
checkCondition(alice::isAdult) // ÇALIŞIR! Çünkü zaten alice'e bağlı.
```