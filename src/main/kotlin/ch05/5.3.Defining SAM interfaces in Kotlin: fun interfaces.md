# Defining SAM interfaces in Kotlin: fun interfaces

Kotlin’de, aksi halde bir functional interface kullanman gereken behavior’ı ifade etmek için çoğu zaman function
type’larını kullanabilirsin. Kotlin’de type alias’lar aracılığıyla function type’lara daha expressive isimler vermenin
bir yolunu göreceğiz. Ancak, kodunda daha explicit olmak isteyeceğin bazı durumlar olabilir. Kotlin’de bir fun interface
declare ederek kendi functional interface’lerini tanımlayabilirsin. Kotlin’deki functional interface’ler tam olarak bir
abstract method içerir, ancak buna ek olarak birkaç non-abstract method da içerebilir. Bu, bir function type’ın
signature’ına sığdıramayacağın daha complex construct’ları ifade etmene yardımcı olabilir. Aşağıdaki example’da, check
adlı abstract method’a sahip IntCondition adlı bir functional interface define edersin. Parameter’ını integer’a
dönüştürdükten sonra check’i invoke eden, checkString adlı ek bir non-abstract method define edersin. Java SAM’lerinde
olduğu gibi, check’in implementation’ını belirleyen bir lambda ile interface’i instantiate etmek için SAM constructor
kullanırsın.

```kotlin
fun interface IntCondition {
    // Single Abstract Method
    fun check(i: Int): Boolean

    // Additional nonabstract methodlar
    fun checkString(s: String) = check(s.toInt())
    fun checkChar(c: Char) = check(c.digitToInt())
}
```

Bir function, type’ı bir fun interface olarak defined edilmiş bir parameter kabul ettiğinde, yine doğrudan bir lambda
implementation sağlayabilir veya bir lambda’ya reference pass edebilirsin; her ikisi de interface implementation’ını
dynamic olarak instantiate eder. Aşağıdaki example’da, daha önce tanımladığımız IntCondition’ı alan bir checkCondition
function’ı define ediyorsun. Daha sonra bu function’ı çağırmanın birden fazla yolu vardır—örneğin, doğrudan bir lambda
pass ederek veya doğru type’a sahip bir function’a reference pass ederek.

```kotlin
fun main() {
    /* SAM Conversion (En Yaygın Kullanım)
    Eğer bir fonksiyon (burada checkCondition), bir fun interface bekliyorsa, Kotlin doğrudan bir lambda ({ }) geçmenize
    izin verir. En kısa ve temiz yol budur.*/
    // Doğrudan lambda ile kullanım
    val result = checkCondition(12) { it % 2 == 0 }
    println(result) // true

    /* SAM Constructor (Explicit Conversion)
    Bir lambdayı açıkça (explicit) bir IntCondition nesnesine dönüştürmek istediğinde kullanılır. Özellikle bir
    değişkene atama yaparken çok kullanışlıdır.*/
    // SAM Constructor kullanarak bir değişkene atama
    val isEven = IntCondition { it % 2 == 0 }
    // Değişkeni fonksiyona geçirme
    val checkCondition = checkCondition(12, isEven)
    println(checkCondition)

    // Interface içindeki diğer metotlara erişim
    println(isEven.checkString("5")) // false
    println(isEven.checkChar('4')) // true
}

fun interface IntCondition {
    // Single Abstract Method
    fun check(i: Int): Boolean

    // Additional nonabstract methodlar
    fun checkString(s: String) = check(s.toInt())
    fun checkChar(c: Char) = check(c.digitToInt())
}

fun checkCondition(i: Int, condition: IntCondition): Boolean {
    return condition.check(i)
}
```

IntCondition interface'inde ki nonabstract methodların (checkString ve checkChar) SAM Constructor ile oluşturulan bir
object üzerinde nasıl çalıştığını gösteren kapsamlı bir örnek şöyle olacaktır.

```kotlin
fun main() {
    // SAM Constructor ile kuralımızı tanımlayalım (Örn: Sayı çift mi?)
    val isEven = IntCondition { it % 2 == 0 }

    println("9 çift bir sayı mı? : ${isEven.check(9)}") // 9 çift bir sayı mı? : false

    val stringResult = isEven.checkString("42")
    println("'42' stringi çift bir sayı mı? -> $stringResult") // '42' stringi çift bir sayı mı? -> true

    // Yazdığın checkCondition fonksiyonuna bu nesneyi gönderiyoruz
    val finalResult = checkCondition(100, isEven)
    println("100 sayısı koşulu sağlıyor mu? -> $finalResult") // 100 sayısı koşulu sağlıyor mu? -> true
}

fun interface IntCondition {
    fun check(i: Int): Boolean

    fun checkString(s: String) = check(s.toInt())
    fun checkChar(c: Char) = check(c.digitToInt())
}

fun checkCondition(i: Int, condition: IntCondition): Boolean {
    return condition.check(i)
}
```

Buradaki en kritik nokta, SAM Constructor sayesinde lambdanın sadece bir kod bloğu olmaktan çıkıp, interface'de ki tüm
yeteneklere (diğer metotlara) sahip gerçek bir nesneye dönüşmesidir.

```kotlin
fun main() {
    // (Int) -> Boolean — bu syntax ve genel olarak lambda’lar hakkında daha fazlasını bölüm 10.1’de öğreneceksin).
    val isOdd: (Int) -> Boolean = { it % 2 != 0 }
    checkCondition(5, isOdd)
}
```

Hem Java hem de Kotlin kodundan kullanılmasını beklediğin code yazıyorsan, bir fun interface kullanmak Java call
site’larının clean olmasını da iyileştirebilir. Kotlin function type’ları, generic type’ları parameter ve return
type’lar olan object’ler olarak translate edilir. Herhangi bir şey return etmeyen function’lar için Kotlin, Java’nın
void’ine analog olarak Unit kullanır. Bu aynı zamanda, böyle bir Kotlin function type Java’dan invoke edildiğinde,
çağıranın açıkça Unit.INSTANCE return etmesi gerektiği anlamına gelir. Bir fun interface kullanmak bu gerekliliği
ortadan kaldırır ve call site’ı daha concise hâle getirir. Bu example’da, consumeHello ve consumeHelloFunctional
function’ları aynı şeyi yapar; ancak biri functional interface kullanılarak, diğeri ise Kotlin function type’ları
kullanılarak define edilmiştir.

```kotlin
fun main() {
    consumeHello { s ->
        println("$s, ben bir interface üzerinden geldim!")
        // Hello, ben bir interface üzerinden geldim!
    }

    val myConsumer = StringConsumer { s ->
        println("$s SAM constructor ile oluşturuldum")
    }
    consumeHello(myConsumer) // Hello SAM constructor ile oluşturuldum

    // (String) -> Unit (Function Type) Kullanımı
    // Bu doğrudan bir fonksiyondur, interface değildir
    consumeHelloFunctional { s -> println("$s ben doğrudan bir function'ım") }
    // Hello ben doğrudan bir function'ım

    val simpleLambda: (String) -> Unit = { println(it) }
    consumeHello(simpleLambda)
}

fun interface StringConsumer {
    fun consume(s: String)
}

fun consumeHello(s: StringConsumer) {
    s.consume("Hello")
}

fun consumeHelloFunctional(t: (String) -> Unit) {
    t("Hello")
}
```

Burada önemli bir açıklama yapmak gerekiyor;

```kotlin
val simpleLambda: (String) -> Unit = { println(it) }
consumeHello(simpleLambda)
```

Aslında teorik olarak (String) -> Unit ile StringConsumer farklı tiplerdir. Ancak Kotlin derleyicisi seni yormamak için
arka planda bir "iyileştirme" yapar. Kotlin derleyicisi, bir fonksiyona parametre gönderirken eğer beklenen tip bir
Functional Interface (SAM) ise ve senin gönderdiğin değer bir Lambda/Fonksiyon ise, aradaki dönüşümü otomatik olarak
yapar. Buna SAM Conversion denir. Derleyici şu mantığı yürütür:

* consumeHello benden bir StringConsumer istiyor.

* Kullanıcı ise bana (String) -> Unit tipinde bir lambda/değişken veriyor.

* StringConsumer zaten tek bir metoda sahip ve o da (String) -> Unit imzasını taşıyor.

* O halde ben bunu otomatik olarak sarmalayabilirim!

Eğer simpleLambda değişkenini bir val olarak değil de, başka bir yerden gelen belirsiz bir tip olarak kullansaydın veya
Kotlin'in çok eski bir versiyonunu (1.4 öncesi) kullansaydın hata alabilirdin.

Ancak şu ayrımı bilmek hala çok önemli:

```kotlin
fun main() {
    val simpleLambda : (String) -> Unit = {println(it)}

    // 1. Durum: Otomatik Dönüşüm (Senin yaptığın)
    // Derleyici "arka planda" SAM Constructor kullanır.
    consumeHello(simpleLambda) // Hello

    // 2. Durum: Manuel (Explicit) Dönüşüm
    val explicit = StringConsumer(simpleLambda)
    consumeHello(explicit) // Hello
}

fun interface StringConsumer {
    fun consume(s: String)
}

fun consumeHello(s: StringConsumer) {
    s.consume("Hello")
}

fun consumeHelloFunctional(t: (String) -> Unit) {
    t("Hello")
}
```

Java’dan kullanıldığında, fun interface kullanan function varyantı basit bir lambda ile call edilebilirken, Kotlin
function type’larını kullanan varyant, lambda’nın açıkça Kotlin’in Unit.INSTANCE’ini return etmesini gerektirir.

```java
import kotlin.Unit;
public class MyApp {
    public static void main(String[] args) {
        /* Java */
        MainKt.consumeHello(s -> System.out.println(s.toUpperCase()));
        MainKt.consumeHelloFunctional(s -> {
            System.out.println(s.toUpperCase());
            return Unit.INSTANCE;
        });
    }
}
```

Genel bir kural olarak, basit functional type’lar, API’nin belirli bir parameter set’i alan ve belirli bir type
döndüren herhangi bir function’ı kabul edebildiği durumlarda iyi çalışır. Functional type signature’ı içinde ifade
edemeyeceğin daha complex contract’ları veya operation’ları ifade etmen gerektiğinde ise, bir functional interface iyi
bir seçimdir. Lambda syntax’ı ve kullanımına ilişkin tartışmamızı bitirmek için, receiver’lı lambda’lara ve bunların
built-in construct’lar gibi görünen kullanışlı library function’ları tanımlamak için nasıl kullanıldığına bakalım.