# SAM constructors: Explicit conversion of lambdas to functional interfaces

Bir SAM constructor, single abstract method’a sahip bir interface’in instance’ına bir lambda’yı açıkça dönüştürmeni
sağlayan, compiler tarafından generated edilmiş bir function’dır. Compiler’ın dönüşümü automatically uygulamadığı
context’lerde bunu kullanabilirsin. Örneğin, functional interface’in bir instance’ını döndüren bir method’un varsa,
doğrudan bir lambda return edemezsin; onu bir SAM constructor içine wrap etmen gerekir. İşte basit bir example.

```kotlin
fun createAllDoneRunnable(): Runnable {
    return Runnable { println("All done!") }
}
```

SAM constructor’ın adı, alttaki functional interface’in adıyla aynıdır. SAM constructor tek bir argument alır —
functional interface’teki single abstract method’un body’si olarak kullanılacak bir lambda — ve interface’i implement
eden class’ın bir instance’ını döndürür. Value döndürmenin yanı sıra, SAM constructor’lar bir lambda’dan generated
edilmiş bir functional interface instance’ını bir variable’da store etmen gerektiğinde de kullanılır. Diyelim ki
aşağıdaki listede olduğu gibi birden fazla button için tek bir listener’ı reuse etmek istiyorsun (bir Android
application’da bu kod, Activity.onCreate method’unun bir parçası olabilir).

```kotlin
val listener = OnClickListener { view ->
    val text = when (view.id) {
        button1.id -> "First button"
        button2.id -> "Second button"
        else -> "Unknown button"
    }
    toast(text)
}

button1.setOnClickListener(listener)
button2.setOnClickListener(listener)
```

Listener, click’in kaynağının hangi button olduğunu kontrol eder ve buna göre behavior sergiler. OnClickListener’ı
implement eden bir object declaration kullanarak bir listener define edebilirsin, ancak SAM constructor’lar daha concise
bir seçenek sunar. Bir lambda’da, anonymous object’te olduğu gibi bir this yoktur; lambda’nın dönüştürüldüğü anonymous
class instance’ına referans vermenin bir yolu yoktur. Compiler açısından lambda bir object değil, bir code block’tur ve
onu bir object olarak referans edemezsin. Lambda’daki this referansı, surrounding class’a referans verir. Eğer event
listener, bir event’i handle ederken kendisini unsubscribe etmek zorundaysa, bunun için lambda kullanamazsın. Bunun
yerine, listener’ı implement etmek için bir anonymous object kullan. Anonymous object’te this keyword’ü o object’in
instance’ına referans verir ve listener’ı kaldıran API’ye onu pass edebilirsin. Ayrıca, method call’larda SAM conversion
genellikle automatically gerçekleşse bile, overloaded bir method’a lambda’yı argument olarak pass ettiğinde compiler’ın
doğru overload’u seçemediği durumlar vardır. Bu durumlarda, explicit bir SAM constructor uygulamak compilation error’ı
çözmenin iyi bir yoludur.

### Extra Description : (https://www.baeldung.com/kotlin/sam-conversions)

Bu tutorial’da, Kotlin lambda expressions’ın Java functional interfaces ile SAM conversions kullanılarak nasıl
interoperable olduğunu göreceğiz. Bu süreçte, bu interoperability’nin bytecode level’daki internal representation’ını
daha derinlemesine inceleyeceğiz.

Java’da lambda expressions, functional interfaces terimleri üzerinden implement edilir. Functional interfaces, implement
edilmesi gereken yalnızca tek bir abstract method’a sahiptir. Kotlin’de ise bunun aksine, compile-time aşamasında gerçek
function type’ları vardır. Örneğin `(String) -> Int`, input olarak bir String alan ve output olarak bir Int döndüren bir
function type’ıdır. Implementation farklarına rağmen, Kotlin lambda’ları Java’daki functional interface’lerle tamamen
interoperable’dır. Bunu daha somut hâle getirmek için `java.lang.Thread` class’ını ele alalım. Bu class, input olarak
bir `Runnable` interface instance’ı alan bir constructor’a sahiptir:

```java
public Thread(Runnable target) {
    // omitted
}
```

Java 8’den önce, bir Thread instance oluşturmak için Runnable’dan bir anonymous inner class oluşturmak zorundaydık:

```java
 Thread thread = new Thread(new Runnable() {
    @Override
    public void run() {
        // the logic
    }
});
```

Burada aynı anda hem bir alt sınıf hem de bir instance oluşturuyoruz.

Kotlin’de benzer şekilde, aynı şeyi gerçekleştirmek için object expressions kullanabiliriz:

```kotlin
val thread = Thread(object : Runnable {
    override fun run() {
        // the logic   
    }
})
```

Ancak bu pek doğru hissettirmiyor ve zarif ve öz olmaktan oldukça uzak.

İyi haber şu ki, Kotlin’deki lambda expression’lar Java’daki functional interfaces ile oldukça interoperable olduğu
için, Thread constructor’a bir lambda geçebiliriz. Son parameter bir lambda olduğu için, parantezleri atlayabilir ve
lambda bloğunu bunun dışına taşıyabiliriz:

```kotlin
val thread = Thread {
    // the logic
}
```

Basitçe ifade etmek gerekirse, Java API bizden bir functional interface bekliyor olsa bile, buna karşılık gelen
lambda’yı yine de ona geçebiliyoruz. Under the hood, Kotlin Compiler lambda’yı bir functional interface’e
dönüştürecektir.

Artık bu olasılığı bildiğimize göre, biraz daha derine inelim ve her şeyin under the hood nasıl çalıştığını görelim.

### SAM Conversions

Lambda’dan functional interface’e dönüşüm, functional interfaces’lerin yalnızca tek bir abstract method’a sahip olması
sayesinde çalışır. Bu tür interfaces’lere Single Abstract Method veya SAM interfaces denir. Ayrıca, bu otomatik dönüşüm
SAM conversions olarak da bilinir.

Ancak under the hood, Kotlin Compiler SAM conversions için hâlâ bir anonymous inner class oluşturur. Örneğin, aynı
Thread örneğini ele alalım:

```kotlin
val thread = Thread {
    // the logic
}
```

Kodu kotlinc kullanarak compile edersek: ```kotlinc SamConversions.kt```

Ardından bytecode’u javap kullanarak inceleyebiliriz: ```javap -v -p -c SamConversionsKt```

```
$ javap -v -p -c SamConversionsKt
// truncated
0: new           #11       // class java/lang/Thread
3: dup
4: getstatic     #17       // Field SamConversionsKt$main$thread$1.INSTANCE:LSamConversionsKt$main$thread$1;
7: checkcast     #19       // class java/lang/Runnable
10: invokespecial #23      // Method java/lang/Thread."<init>":(Ljava/lang/Runnable;)V
13: astore_0
// truncated
InnerClasses:
  static final #13;        // class SamConversionsKt$main$thread$1
```

İşte Kotlin Compiler’ın bizim için ürettiği şey:

1. Bir anonymous inner class tanımlar — SamConversionsKt$main$thread$1 kısmı

2. Bu sınıfın singleton instance’ını alır — SamConversionsKt$main$thread$1.INSTANCE kısmı

3. Ardından bunun bir Runnable instance’ı olduğundan emin olur ve ondan sonra

4. Bu instance’ı Thread constructor’a geçirir

Daha önce belirttiğimiz gibi, aynı şeyi object expressions kullanarak da gerçekleştirebiliriz:

```kotlin
Thread(object : Runnable {
    override fun run() {
        // the logic
    }
})
```

Ancak aşağıda gösterilen bytecode’un da gösterdiği gibi, bu yaklaşım her bir Thread instance oluşturduğumuzda bir
anonymous inner class oluşturacaktır:

```
0: new           #11      // class java/lang/Thread
3: dup
4: new           #13      // class SamConversionsKt$main$thread$1
7: dup
8: invokespecial #16      // Method SamConversionsKt$main$thread$1."<init>":()V
11: checkcast     #18     // class java/lang/Runnable
14: invokespecial #21     // Method java/lang/Thread."<init>":(Ljava/lang/Runnable;)V
17: astore_0
```

index 8 de, JVM anonymous inner class’ın bir instance’ını oluşturuyor ve onun instance initialization method’unu, yani
constructor’unu çağırıyor. Öte yandan, lambda bir singleton instance oluşturur ve ona her ihtiyaç duyduğumuzda bu
instance’ı yeniden kullanır:

```
4: getstatic #17 // Field SamConversionsKt$main$thread$1.INSTANCE:LSamConversionsKt$main$thread$1;
```

Dolayısıyla, daha öz olmasının yanı sıra, lambda expression ve SAM conversion daha az object oluşturur ve bu nedenle
daha iyi bir memory footprint sergiler. Ancak bu performance kazanımı, outer scope’lardaki bir variable’ı capture
edersek kırılgan olabilir:

```kotlin
var answer = 42
val thread = Thread {
    println(answer)
}
```

Bu durumda, önemli bir değişiklik görürüz:

```
23: invokespecial #25   // Method SamConversionsKt$main$thread$1."<init>":(Lkotlin/jvm/internal/Ref$IntRef;)V
26: checkcast     #27   // class java/lang/Runnable
```

Yukarıda gösterildiği gibi, anonymous inner class artık constructor’ında bir argument kabul eder. Aslında, Kotlin
Compiler capture edilen variable’ı bir IntRef instance’ı içine sarar ve onu inner class constructor’una geçirir.
Dolayısıyla, bir lambda içinde bir variable capture edersek, JVM her invocation için bir instance oluşturacaktır.
Böylece bu performance kazanımını kaybederiz. Bunu önlemek için Kotlin’de inline functions kullanabiliriz.

### SAM Constructors

Genellikle, lambda expression’ların karşılık gelen functional interfaces’e dönüşümü Compiler tarafından otomatik olarak
gerçekleştirilir. Ancak bazı durumlarda bu dönüşümü manuel olarak yapmamız gerekir. Örneğin, ExecutorService interface’i
submit() için iki overloaded sürüm sağlar:

```java
Future<T> submit(Callable task);

Future<?> submit(Runnable task);
```

Hem Callable hem de Runnable functional interfaces’tir. Dolayısıyla şunu yazarsak:

```kotlin
val result = executor.submit {
    return@submit 42
}
```

Bu durumda Kotlin Compiler hangi overloaded sürümü kullandığımızı infer edemez. Bu karışıklığı gidermek için SAM
constructor’ları kullanabiliriz:

```kotlin
val submit = executor.submit(Callable {
    return@Callable 42
})
```

Yukarıda gösterildiği gibi, bir SAM constructor’ın adı, underlying (altında yatan) functional interface’in adıyla
aynıdır. Ayrıca constructor’ın kendisi, bir lambda’nın bir functional interface instance’ına açıkça dönüştürülmesini
sağlayan, Compiler tarafından üretilmiş özel bir function’dır. Ayrıca, SAM constructor’lar bir functional interface
döndürürken de kullanışlıdır:

```kotlin
fun doSomething(): Runnable = Runnable {
    // doing something
}
```

Hatta bir lambda’yı bir variable’a store ederken bile:

```kotlin
val runnable = Runnable {
    // doing something
}
```

Lütfen SAM conversions’ın yalnızca functional interfaces için çalıştığını ve yalnızca tek bir abstract method’a sahip
olsalar bile abstract class’lar için geçerli olmadığını unutmayın.

### SAM Conversion for Kotlin Interfaces

Kotlin 1.4 itibarıyla, Kotlin interfaces için de SAM conversions kullanabiliriz. Yapmamız gereken tek şey, bir Kotlin
interface’i fun modifier ile işaretlemektir:

```
fun interface Predicate<T> {
    fun accept(element: T): Boolean
}
```

Artık bu interface’in instance’larına SAM conversions uygulayabiliriz:

```kotlin
val isAnswer = Predicate<Int> { i -> i == 42 }
```

Lütfen bir Kotlin interface’e fun modifier uyguladığımızda, interface’in tam olarak tek bir abstract method içerdiğinden
emin olmamız gerektiğini unutmayın. Aksi takdirde, kod compile olmayacaktır.