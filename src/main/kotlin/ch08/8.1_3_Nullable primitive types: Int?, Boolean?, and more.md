# Nullable primitive types: Int?, Boolean?, and more

Kotlin’de nullable type’lar Java primitive type’lar ile temsil edilemez; çünkü null yalnızca Java reference type’a sahip
bir variable içinde saklanabilir. Bu da Kotlin’de bir primitive type’ın nullable versiyonunu kullandığın her durumda,
bunun karşılık gelen wrapper type’a compiled edildiği anlamına gelir.

Nullable type’ları kullanımda görmek için, kitabın açılış örneğine geri dönelim ve orada declared edilen Person
class’ını hatırlayalım. Bu class, adı her zaman bilinen ve yaşı bilinen ya da belirtilmemiş olabilen bir kişiyi
represent eder. Bir kişinin diğerinden daha yaşlı olup olmadığını kontrol eden bir function ekleyelim.

```kotlin
data class Person(
    val name: String,
    val age: Int? = null
) {
    fun isOlderThan(other: Person): Boolean? {
        if (age == null || other.age == null)
            return null
        return age > other.age
    }
}

fun main() {
    val person1 = Person("Sam", 25)
    val person2 = Person("Ari", 29)

    println(person1.isOlderThan(person2))
    println(Person("Dimitri", 41).isOlderThan(Person("Iva"))) // null
}
```

Burada regular nullability kurallarının nasıl uygulandığına dikkat et. Int? type’ına sahip iki value’yu doğrudan
compared edemezsin; çünkü bunlardan biri null olabilir. Bunun yerine, her iki value’nun da null olmadığını kontrol etmen
gerekir. Bundan sonra Compiler, onlarla normal şekilde çalışmana izin verir. Aynı örneği bir de `let` ile yazalım;

```kotlin
data class People(
    val name: String,
    val age: Int? = null
) {
    fun isOlderThan(other: People): Boolean? {
        return age?.let { currentAge ->
            other.age?.let { otherAge ->
                currentAge > otherAge
            }
        }
    }
}

fun main() {
    val people1 = People("Dimitri", 16)
    val people2 = People("Ari", 19)

    println(people1.isOlderThan(people2)) // false
    println(People("Jax").isOlderThan(People("Jamie", 21))) // null
}
```

Person class’ında declared edilen age property’sinin value’su java.lang.Integer olarak saklanır. Ancak bu detay yalnızca
class ile Java’dan çalışıyorsan önemlidir. Kotlin’de doğru type’ı seçmek için, variable veya property için null’ın olası
bir value olup olmadığını dikkate alman yeterlidir.

Daha önce de belirtildiği gibi, generic class’lar wrapper type’ların devreye girdiği bir başka case’tir. Bir class’ın
type argument’ı olarak primitive bir type kullandığında, Kotlin type’ın boxed temsilini kullanır. Örneğin, nullable bir
type belirtmemiş veya null bir value kullanmamış olsan bile, bu durum boxed Integer value’lardan oluşan bir liste
oluşturur.

```kotlin
val listOfInts = listOf(1, 2, 3)
```

Bu durum, generic’lerin JVM üzerinde implement edilme biçiminden kaynaklanır. JVM şu anda bir primitive type’ın type
argument olarak kullanılmasını desteklemez; bu nedenle generic bir class (hem Java’da hem de Kotlin’de) her zaman
type’ın boxed temsilini kullanmak zorundadır. Sonuç olarak, primitive type’lardan oluşan büyük collection’ları verimli
biçimde saklaman gerekiyorsa, Eclipse Collections (https://github.com/eclipse/eclipse-collections) gibi bu tür
collection’lar için destek sağlayan bir third-party library kullanmalı ya da bunları array’ler içinde saklamalısın.
Array’leri bu bölümün sonunda ayrıntılı olarak ele alacağız. Şimdi, farklı primitive type’lar arasında value’ları nasıl
dönüştürebileceğine bakalım.