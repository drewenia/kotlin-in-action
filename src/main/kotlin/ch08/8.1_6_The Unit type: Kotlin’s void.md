# The Unit type: Kotlin’s void

Kotlin’de Unit type, Java’daki void ile aynı işlevi görür. Hiçbir ilginç value döndürmeyen bir function’ın return type’ı
olarak kullanılabilir:

```kotlin
fun f(): Unit {}
```

Sözdizimsel olarak, type declaration olmadan block body’e sahip bir function yazmakla aynıdır:

```kotlin
fun f() {}
```

Çoğu durumda, void ile Unit arasındaki farkı fark etmezsin. Kotlin function’ının return type’ı Unit ise ve generic bir
function’ı override etmiyorsa, perde arkasında klasik bir void function olarak compiled edilir. Java’dan override
edersen, Java function sadece void döndürmelidir.

Peki Kotlin’in Unit’ini Java’daki void’den ayıran nedir? Unit tam teşekküllü bir type’tır ve void’in aksine type
argument olarak kullanılabilir. Bu type’ın yalnızca bir value’su vardır; bu value da Unit olarak adlandırılır ve
implicit olarak döndürülür. Bu, generic bir parameter döndüren bir function’ı override ederken ve Unit type’ından bir
value döndürürken faydalıdır:

```kotlin
interface Processor<T> {
    fun process(): T
}

class NoResultProcessor : Processor<Unit> {
    // Unit döner, ancak type specification’ı atlıyorsun.
    override fun process() {
        val tax = 100 * 0.18
        println("Tax : $tax")
    } // Burada explicit bir return’a gerek yok.
}

fun main() {
    val nrs = NoResultProcessor()
    println(nrs.process())
    // Tax : 18.0
    // kotlin.Unit
}
```

Interface’in signature’ı, process function’ın bir value döndürmesini gerektirir ve Unit type’ının bir value’su olduğu
için bunu method’tan döndürmek sorun değildir. Ancak NoResultProcessor.process içinde explicit bir return statement
yazmana gerek yok; çünkü return Unit compiler tarafından implicit olarak eklenir.

Bunu Java ile karşılaştır. Java’da “no value”u type argument olarak kullanma sorununu çözmenin olasılıkları, Kotlin
çözümü kadar iyi değildir. Bir seçenek, value döndürmeyen ve döndüren interface’leri temsil etmek için ayrı
interface’ler (örneğin Callable ve Runnable) kullanmaktır. Diğer seçenek, type parameter olarak özel java.lang.Void
type’ını kullanmaktır. İkinci seçeneği kullanırsan, yine de explicit olarak return null yazman gerekir; çünkü return
type void değilse, her zaman explicit bir return statement olmalıdır ve bu type’a uyan tek olası value’yu döndürmen
gerekir.

Unit için neden farklı bir isim seçtiğimizi ve neden Void demediğimizi merak edebilirsin. Unit ismi, functional
language’larda geleneksel olarak “sadece bir instance” anlamında kullanılır ve işte bu, Kotlin’in Unit’ini Java’daki
void’den ayıran özelliktir. Geleneksel Void ismini kullanabilirdik, ancak Kotlin’de tamamen farklı bir işlev gören
Nothing adlı bir type vardır. Void ve Nothing adlı iki type olması kafa karıştırıcı olurdu; çünkü anlamları çok
yakındır. Peki, bu Nothing type nedir? Hadi öğrenelim.