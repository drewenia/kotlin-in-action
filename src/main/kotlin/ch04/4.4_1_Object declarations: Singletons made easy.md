# Object declarations: Singletons made easy

Object-oriented sistemlerin tasarımında oldukça yaygın bir durum, yalnızca tek bir instance’ına ihtiyaç duyulan bir
class’ın bulunmasıdır. Bu genellikle Java gibi language’lerde singleton pattern kullanılarak implement edilir: private
bir constructor’a sahip bir class define edilir ve class’ın var olan tek instance’ını tutan static bir field bulunur.
Kotlin, object declaration feature’ını kullanarak bunun için first-class language support sağlar. Object declaration,
bir class declaration’ını ve bu class’ın tek bir instance’ının declaration’ını birleştirir. Örneğin, bir organization’ın
payroll’unu (maaş bordrosu) represent etmek için object declaration kullanabilirsin. Muhtemelen birden fazla payroll’a
sahip değilsindir, bu nedenle—uygulamanın genel karmaşıklığına bağlı olarak—bunun için bir object kullanmak mantıklı
olabilir.

Object declaration’lar object keyword’ü ile tanıtılır. Bir object declaration, etkili bir şekilde bir class ve aynı
isimde bir variable’ı tek bir statement içinde define eder. Tıpkı bir class gibi, bir object declaration property,
method, initializer block ve benzeri declaration’lar içerebilir. Tek izin verilmeyen şeyler constructor’lardır
(primary veya secondary). Normal class’ların instance’larının aksine, object declaration’lar tanımlandıkları noktada
hemen oluşturulur, kodun diğer yerlerinden constructor call edilerek değil. Bu nedenle, bir object declaration için
constructor define etmek mantıklı değildir. Benzer şekilde, object declaration’a vermek istediğin initial state,
o object’in body’sinin bir parçası olarak sağlanmalıdır. Ve tıpkı bir variable gibi, bir object declaration method call
etmene ve property’lerine erişmene olanak tanır; . karakterinin solunda object ismini kullanarak:

```kotlin
fun main() {
    Payroll.employees.add(
        Person("Alice")
    )
    Payroll.calculateSalary() // Calculated salary -> Alice
}

data class Person(val name: String)

object Payroll {
    val employees = mutableListOf<Person>()
    fun calculateSalary() {
        for (person in employees) {
            println("Calculated salary -> ${person.name}")
        }
    }
}
```

Object declaration’lar aynı zamanda class ve interface’lerden inherit edebilir. Bu, genellikle kullandığın framework’ün
bir interface implement etmeni gerektirdiği ancak implementation’ının herhangi bir state içermediği durumlarda
faydalıdır. Örneğin, Comparator interface’ini ele alalım. Bir Comparator implementation’ı iki object alır ve hangi
object’in daha büyük olduğunu gösteren bir integer döner. Comparator’lar neredeyse hiç veri saklamaz, bu nedenle
object’leri karşılaştırmanın belirli bir yolu için genellikle yalnızca tek bir Comparator instance’ına ihtiyaç duyarsın.
Bu, object declaration için mükemmel bir kullanım durumudur. Bir örnek olarak, dosya path’lerini case insensitive
olarak karşılaştıran bir comparator implement edelim:

```kotlin
fun main() {
    val compare = CaseInsensitiveFileComparator.compare(File("/User"), File("/user"))
    println(compare) // 0

    // < 0 → file1 < file2
    // 0 → file1 = file2
    // > 0 → file1 > file2
}

object CaseInsensitiveFileComparator : Comparator<File> {
    override fun compare(file1: File, file2: File): Int {
        /* compareTo(..., ignoreCase = true) → String karşılaştırması yapıyor, büyük/küçük harf farkını görmezden
        geliyor. */
        return file1.path.compareTo(file2.path, ignoreCase = true)
    }
}
```

Singleton object’ları, normal bir object’in (bir class instance’ının) kullanılabileceği her context’te kullanabilirsin.
Örneğin, bu object’i Comparator alan bir function’a argument olarak geçirebilirsin. sortedWith bir comparator alır:

```kotlin
fun main() {
    val files = listOf(
        File("/Z"),
        File("/D"),
        File("/a"),
    )

    val sortedList = files.sortedWith(CaseInsensitiveFileComparator)
    print(sortedList) // [/a, /D, /Z]
}

object CaseInsensitiveFileComparator : Comparator<File> {
    override fun compare(file1: File, file2: File): Int {
        return file1.path.compareTo(file2.path, ignoreCase = true)
    }
}
```

Tıpkı singleton pattern’da olduğu gibi, object declaration’lar büyük yazılım sistemlerinde her zaman ideal değildir.
Az veya hiç dependency içermeyen küçük kod parçaları için mükemmeldirler, ancak sistemin birçok diğer kısmıyla etkileşen
büyük componentler için uygun değildirler. Bunun başlıca nedeni, object’lerin instantiation’ı üzerinde hiçbir kontrolün
olmaması ve constructor’lar için parameter belirleyememendir. Bu, unit test’lerde veya yazılım sisteminin farklı
konfigürasyonlarında object’in kendi implementation’larını veya object’in bağımlı olduğu diğer class’ları
değiştiremeyeceğin anlamına gelir. Bunu yapman gerekiyorsa, normal Kotlin class’ları ve dependency injection
kullanmalısın.

Ayrıca class içinde de object declare edebilirsin. Bu tür object’lerin de yalnızca tek bir instance’ı vardır;
containing class’ın her instance’ı için ayrı bir instance oluşturulmaz. Örneğin, belirli bir class’ın object’lerini
karşılaştıran bir comparator’ı o class’ın içinde bulundurmak mantıklıdır.

```kotlin
fun main() {
    val persons = listOf(
        Person("Bob"),
        Person("Alex"),
        Person("Derek"),
        Person("Ocean"),
        Person("Alice"),
    )

    val sortedPersons = persons.sortedWith(Person.NameComparator)
    println(sortedPersons)
    // [Person(name=Alex), Person(name=Alice), Person(name=Bob), Person(name=Derek), Person(name=Ocean)]
}

data class Person(val name: String) {
    object NameComparator : Comparator<Person> {
        override fun compare(p1: Person, p2: Person): Int {
            return p1.name.compareTo(p2.name)
        }
    }
}
```

Kotlin’de bir object declaration, tek instance’ını tutan static bir field ile bir class olarak compile edilir ve bu
field her zaman INSTANCE olarak adlandırılır. Eğer Java’da singleton pattern implement ettiysen, muhtemelen aynı şeyi
manuel olarak yapardın. Bu nedenle, bir Kotlin object’ini Java code’undan kullanmak için static INSTANCE field’a
erişirsin:

```
CaseInsensitiveFileComparator.INSTANCE.compare(file1, file2);
Person.NameComparator.INSTANCE.compare(person1, person2)
```

Şimdi, bir class içinde nested object’ların özel bir durumu olan companion object’lara bakalım.

### Object declaration extra description

Kotlin'de object anahtar kelimesi aslında Singleton (Tekil) tasarım deseninin dil seviyesinde basitleştirilmiş
halidir. "Neden kullanıldığını" anlamak için önce normal bir sınıftan farkını görmek çok yardımcı olur. Normal bir
sınıftan (class) binlerce kopya (instance) üretebilirsiniz, ancak bir object deklarasyonundan tüm uygulama boyunca
sadece bir tane bulunur.

Neden Kullanılır? (Temel Mantık)

Bir şeyi object olarak tanımlamanızın temel sebebi, o yapıya uygulamanın her yerinden aynı verilerle erişmek
istemenizdir.

* Global Ayarlar/Config: Uygulamanın her yerinde aynı veri tabanı ismini veya API anahtarını kullanmak istersiniz.

* Utility (Yardımcı) Fonksiyonlar: Matematiksel hesaplamalar veya dosya işlemleri gibi, içinde veri saklamayan sadece
  işlem yapan fonksiyonlar için sürekli yeni nesne oluşturmak israftır.

* Paylaşılan Kaynaklar: Bir veri tabanı bağlantısı veya ağ istemcisi (Network Client) gibi ağır nesnelerin tek bir
  merkezden yönetilmesi gerekir.

Diyelim ki bir veri tabanı bağlantısını yönetmek istiyorsunuz. Her ihtiyaç duyduğunuzda yeni bir bağlantı açmak yerine,
tek bir merkezi nokta istersiniz.

```kotlin
fun main() {
    DatabaseManager.connect() // UserDatabase connected. Total connection : 1

    DatabaseManager.connect() // UserDatabase connected. Total connection : 2

    // Uygulamanın neresinde çağırırsanız çağırın hep AYNI connectionCount artar.
}

object DatabaseManager {
    val dbName = "UserDatabase"
    var connectionCount = 0

    fun connect(){
        connectionCount++
        println("$dbName connected. Total connection : $connectionCount")
    }
}
```

Class ve Object Arasındaki Farklar:

![img_8.png](assets/img_8.png)

### Object declaration extra description

```kotlin
fun main() {
    Logger.log("Hello, World!") // Hello, World!
}

object Logger{
    fun log(msg : String){
        println(msg)
    }
}
```

Tek instance mantıksal olarak doğruysa kullanılır:

```kotlin
fun main() {
    println(Config.apiUrl) // https://api.example.com
}

object Config {
    val apiUrl = "https://api.example.com"
}
```

* Tek config

* Global erişim

* Thread-safe (Kotlin garanti eder)

Stateless helper / utility :

```kotlin
fun main() {
    MathUtils.square(4)
}

object MathUtils{
    fun square(x : Int) = x * x
}
```

Factory / Strategy:

```kotlin
interface IdGenerator{
    fun generate() : Int
}

object RandomIdGenerator : IdGenerator {
    override fun generate() = (0..1000).random()
}
```